name: Content Management Automation

on:
  issues:
    types: [opened, edited, labeled, closed]
  pull_request:
    types: [opened, closed]
    paths:
      - 'public/posts/**'
      - 'src/posts/**'
      - 'content/**'

permissions:
  issues: write
  pull-requests: write
  contents: read

jobs:
  # Auto-label new content issues
  auto-label-content:
    runs-on: ubuntu-latest
    if: github.event.action == 'opened' && github.event_name == 'issues'
    steps:
      - name: Auto-label content issues
        uses: actions/github-script@v7
        with:
          script: |
            const issue = context.payload.issue;
            const title = issue.title.toLowerCase();
            const body = issue.body || '';
            
            const labels = [];
            
            // Auto-detect content type from title/body
            if (title.includes('tutorial') || body.includes('tutorial')) {
              labels.push('content-type:tutorial');
            }
            if (title.includes('deep dive') || body.includes('deep dive')) {
              labels.push('content-type:deep-dive');
            }
            if (title.includes('series') || body.includes('series')) {
              labels.push('content-type:series');
            }
            
            // Auto-detect topic from keywords
            const securityKeywords = ['security', 'auth', 'oauth', 'encryption', 'vulnerability'];
            const algorithmKeywords = ['algorithm', 'data structure', 'complexity', 'sorting'];
            const systemKeywords = ['system design', 'architecture', 'scalability', 'distributed'];
            const devopsKeywords = ['devops', 'ci/cd', 'docker', 'kubernetes', 'cloud'];
            
            const contentLower = (title + ' ' + body).toLowerCase();
            
            if (securityKeywords.some(keyword => contentLower.includes(keyword))) {
              labels.push('topic:security');
            }
            if (algorithmKeywords.some(keyword => contentLower.includes(keyword))) {
              labels.push('topic:algorithms');
            }
            if (systemKeywords.some(keyword => contentLower.includes(keyword))) {
              labels.push('topic:system-design');
            }
            if (devopsKeywords.some(keyword => contentLower.includes(keyword))) {
              labels.push('topic:devops');
            }
            
            // Auto-detect priority from keywords
            const highPriorityKeywords = ['urgent', 'trending', 'interview', 'critical'];
            if (highPriorityKeywords.some(keyword => contentLower.includes(keyword))) {
              labels.push('priority:high');
            }
            
            // Add default status if it's a content request
            if (title.includes('[CONTENT]') || body.includes('Content Overview')) {
              labels.push('status:research');
            }
            
            if (labels.length > 0) {
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                labels: labels
              });
              
              console.log(`Auto-labeled issue #${issue.number} with: ${labels.join(', ')}`);
            }

  # Move issues through content pipeline based on PR activity
  update-content-status:
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    steps:
      - name: Update content status based on PR
        uses: actions/github-script@v7
        with:
          script: |
            const pr = context.payload.pull_request;
            const action = context.payload.action;
            
            // Extract issue number from PR title or body
            const issueMatch = (pr.title + ' ' + pr.body).match(/#(\d+)/);
            if (!issueMatch) return;
            
            const issueNumber = issueMatch[1];
            
            try {
              const issue = await github.rest.issues.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber
              });
              
              const currentLabels = issue.data.labels.map(label => label.name);
              const newLabels = [...currentLabels];
              
              // Remove old status labels
              const statusLabels = ['status:research', 'status:outline', 'status:draft', 'status:review', 'status:ready'];
              statusLabels.forEach(label => {
                const index = newLabels.indexOf(label);
                if (index > -1) newLabels.splice(index, 1);
              });
              
              // Add new status based on PR action
              if (action === 'opened') {
                newLabels.push('status:draft');
                
                // Add comment to issue
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNumber,
                  body: `ðŸš€ Content development started! Draft PR created: #${pr.number}`
                });
              } else if (action === 'closed' && pr.merged) {
                newLabels.push('status:ready');
                
                // Add comment and close issue
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNumber,
                  body: `âœ… Content published! PR #${pr.number} merged successfully. Content is now live on the website.`
                });
                
                await github.rest.issues.update({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNumber,
                  state: 'closed'
                });
              }
              
              // Update labels
              await github.rest.issues.setLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber,
                labels: newLabels
              });
              
            } catch (error) {
              console.log(`Could not update issue #${issueNumber}: ${error.message}`);
            }

  # Generate content analytics report
  content-analytics:
    runs-on: ubuntu-latest
    if: github.event.action == 'closed' && github.event.issue.state == 'closed'
    steps:
      - name: Generate content completion report
        uses: actions/github-script@v7
        with:
          script: |
            // Get all content issues
            const issues = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              labels: 'status:ready',
              state: 'closed',
              per_page: 100
            });
            
            const completedContent = issues.data.length;
            
            // Get open content issues by status
            const openIssues = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              per_page: 100
            });
            
            const contentIssues = openIssues.data.filter(issue => 
              issue.labels.some(label => label.name.startsWith('content-type:'))
            );
            
            const statusCounts = {
              research: 0,
              outline: 0,
              draft: 0,
              review: 0
            };
            
            contentIssues.forEach(issue => {
              const statusLabel = issue.labels.find(label => label.name.startsWith('status:'));
              if (statusLabel) {
                const status = statusLabel.name.split(':')[1];
                if (statusCounts.hasOwnProperty(status)) {
                  statusCounts[status]++;
                }
              }
            });
            
            // Create or update analytics issue
            const analyticsTitle = 'ðŸ“Š Content Pipeline Analytics';
            const analyticsBody = `
            # ðŸ“Š Content Pipeline Analytics
            
            **Last Updated:** ${new Date().toISOString().split('T')[0]}
            
            ## ðŸ“ˆ Content Status Overview
            
            | Status | Count |
            |--------|-------|
            | ðŸ“ Research | ${statusCounts.research} |
            | âœï¸ Outline | ${statusCounts.outline} |
            | ðŸ–‹ï¸ Draft | ${statusCounts.draft} |
            | ðŸ‘€ Review | ${statusCounts.review} |
            | âœ… Published | ${completedContent} |
            
            ## ðŸŽ¯ Topic Distribution
            
            Content by topic area:
            - ðŸ” Security: ${contentIssues.filter(i => i.labels.some(l => l.name === 'topic:security')).length}
            - ðŸ§  Algorithms: ${contentIssues.filter(i => i.labels.some(l => l.name === 'topic:algorithms')).length}
            - ðŸ§± System Design: ${contentIssues.filter(i => i.labels.some(l => l.name === 'topic:system-design')).length}
            - â˜ï¸ DevOps: ${contentIssues.filter(i => i.labels.some(l => l.name === 'topic:devops')).length}
            - ðŸ§‘â€ðŸŽ“ Career: ${contentIssues.filter(i => i.labels.some(l => l.name === 'topic:career')).length}
            
            ## âš¡ Priority Breakdown
            
            - ðŸ”´ High Priority: ${contentIssues.filter(i => i.labels.some(l => l.name === 'priority:high')).length}
            - ðŸŸ¡ Medium Priority: ${contentIssues.filter(i => i.labels.some(l => l.name === 'priority:medium')).length}
            - ðŸŸ¢ Low Priority: ${contentIssues.filter(i => i.labels.some(l => l.name === 'priority:low')).length}
            
            ## ðŸ“… Recent Activity
            
            **Recently Completed:** Issue #${context.payload.issue.number} - ${context.payload.issue.title}
            
            ---
            *This report is automatically updated when content issues are completed.*
            `;
            
            // Try to find existing analytics issue
            const existingIssues = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              creator: 'github-actions[bot]',
              state: 'open'
            });
            
            const analyticsIssue = existingIssues.data.find(issue => 
              issue.title === analyticsTitle
            );
            
            if (analyticsIssue) {
              // Update existing issue
              await github.rest.issues.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: analyticsIssue.number,
                body: analyticsBody
              });
            } else {
              // Create new analytics issue
              await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: analyticsTitle,
                body: analyticsBody,
                labels: ['analytics', 'automation']
              });
            }
