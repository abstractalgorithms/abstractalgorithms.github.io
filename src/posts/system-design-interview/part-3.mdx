# Design a Chat System (WhatsApp)

In this part, we'll design a real-time chat system similar to WhatsApp or Slack. This problem introduces complex challenges around real-time communication, message delivery, and online presence management.

## 1. Functional Requirements

### Actors
- **Chat User**: Sends and receives messages
- **Group Admin**: Manages group chats
- **System**: Handles presence and delivery

### Use Cases

**Chat User**:
- Send one-on-one messages
- Participate in group chats (up to 500 members)
- See online/offline status of contacts
- Receive messages in real-time
- View message delivery status (sent, delivered, read)
- Share media files (images, videos, documents)

**Group Admin**:
- Create and manage group chats
- Add/remove participants
- Set group permissions

**System Functions**:
- Deliver messages reliably
- Maintain message ordering
- Handle offline message delivery
- Manage user presence status

### Functional Requirements
✅ **In Scope**:
- One-on-one messaging
- Group messaging (up to 500 members)
- Real-time message delivery
- Message delivery status
- Online presence indicators
- Media file sharing
- Message history storage

❌ **Out of Scope**:
- Voice/video calling
- Message encryption (assume handled by client)
- Advanced group features (channels, threads)
- Message search functionality
- Push notifications (assume external service)

## 2. Non-Functional Requirements

### Scalability
- Support 1 billion users globally
- Handle 50 billion messages per day
- Support 10 million concurrent users

### Availability
- 99.9% uptime for message delivery
- Graceful degradation during failures
- Message ordering must be preserved

### Performance
- Message delivery: <100ms in same region
- Cross-region delivery: <300ms
- Group message fanout: <500ms
- Support real-time presence updates

### Data Consistency
- Strong consistency for message ordering
- Eventual consistency for presence status
- At-least-once message delivery guarantee

## 3. Estimations

### User Metrics
- **Total Users**: 1 billion
- **Daily Active Users**: 500 million
- **Concurrent Users**: 10 million peak
- **Average sessions per user**: 4 per day

### Message Volume
- **Messages per day**: 50 billion
- **Messages per second**: 578K average
- **Peak QPS**: 1.2 million
- **Group messages**: 20% of total volume

### Storage Estimations

**Per Message Storage**:
- Message ID: 8 bytes
- Sender ID: 8 bytes  
- Receiver/Group ID: 8 bytes
- Message content: 100 bytes average
- Metadata: 50 bytes
- **Total per message**: ~200 bytes

**Storage Growth**:
- **Per Day**: 50B × 200 bytes = 10 TB/day
- **Per Year**: 10 TB × 365 = 3.65 PB/year
- **Per 5 Years**: 18.25 PB (with compression ~9 PB)

### Connection Estimations
- **WebSocket connections**: 10 million concurrent
- **Memory per connection**: 10KB
- **Total connection memory**: 100 GB
- **Servers needed**: 200 servers (500MB per server)

## 4. Design Goals

### Performance Requirements
- **Latency**: <100ms same region, <300ms cross-region
- **Throughput**: 1.2M messages/second peak
- **Availability**: 99.9% uptime

### Architecture Patterns
- **Event-Driven**: Message routing and delivery
- **Pub/Sub**: Real-time message distribution
- **Microservices**: Decomposed by functionality

### Usage Patterns
- **Real-time Processing**: Immediate message delivery
- **Write Heavy**: High message ingestion rate
- **Connection Heavy**: Millions of persistent connections

## 5. High-Level Design

### Building Blocks

```
[Mobile/Web Client] ↔ [WebSocket Gateway] → [Message Service] → [Message Queue]
                                ↓                    ↓              ↓
                        [Presence Service] → [User Service] → [Database Cluster]
                                ↓                    ↓              ↓
                        [Notification Service] → [Analytics] → [Message Storage]
```

### Core Components

1. **WebSocket Gateway**: Manages persistent connections
2. **Message Service**: Core message processing logic
3. **Presence Service**: Tracks user online status
4. **User Service**: User profiles and friend lists
5. **Message Queue**: Reliable message delivery
6. **Database Cluster**: Distributed message storage

### API Design

**WebSocket Events**:

**Send Message**:
```json
{
  "type": "send_message",
  "data": {
    "message_id": "msg_123456",
    "chat_id": "chat_789",
    "content": "Hello World!",
    "message_type": "text",
    "timestamp": "2024-06-17T10:00:00Z"
  }
}
```

**Receive Message**:
```json
{
  "type": "new_message",
  "data": {
    "message_id": "msg_123456",
    "chat_id": "chat_789",
    "sender_id": "user_456",
    "content": "Hello World!",
    "timestamp": "2024-06-17T10:00:00Z",
    "delivery_status": "delivered"
  }
}
```

**Presence Update**:
```json
{
  "type": "presence_update",
  "data": {
    "user_id": "user_456",
    "status": "online",
    "last_seen": "2024-06-17T10:00:00Z"
  }
}
```

**REST APIs**:

**Create Chat**:
```http
POST /api/v1/chats
{
  "type": "group",
  "name": "Project Team",
  "participants": ["user_123", "user_456", "user_789"]
}
```

**Get Chat History**:
```http
GET /api/v1/chats/{chat_id}/messages?limit=50&before=msg_123
```

### Database Schema

**Users Table**:
```sql
CREATE TABLE users (
    user_id BIGINT PRIMARY KEY,
    username VARCHAR(50) UNIQUE NOT NULL,
    email VARCHAR(255) UNIQUE NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    last_seen TIMESTAMP,
    status ENUM('online', 'offline', 'away') DEFAULT 'offline'
);
```

**Chats Table**:
```sql
CREATE TABLE chats (
    chat_id BIGINT PRIMARY KEY,
    chat_type ENUM('direct', 'group') NOT NULL,
    name VARCHAR(255),
    created_by BIGINT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);
```

**Messages Table** (Partitioned by chat_id):
```sql
CREATE TABLE messages (
    message_id BIGINT PRIMARY KEY,
    chat_id BIGINT NOT NULL,
    sender_id BIGINT NOT NULL,
    content TEXT NOT NULL,
    message_type ENUM('text', 'image', 'file') DEFAULT 'text',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    INDEX idx_chat_time (chat_id, created_at),
    INDEX idx_sender (sender_id)
) PARTITION BY HASH(chat_id) PARTITIONS 100;
```

**Chat Participants Table**:
```sql
CREATE TABLE chat_participants (
    chat_id BIGINT,
    user_id BIGINT,
    joined_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    role ENUM('member', 'admin') DEFAULT 'member',
    
    PRIMARY KEY (chat_id, user_id),
    INDEX idx_user_chats (user_id)
);
```

## Detailed Design Deep Dive

### WebSocket Connection Management

**Connection Gateway**:
```python
class ConnectionGateway:
    def __init__(self):
        self.connections = {}  # user_id -> connection
        self.user_servers = {}  # user_id -> server_id
    
    def handle_connection(self, user_id, websocket):
        # Store connection mapping
        self.connections[user_id] = websocket
        self.user_servers[user_id] = self.server_id
        
        # Update presence service
        self.presence_service.set_online(user_id, self.server_id)
        
        # Subscribe to user's message queue
        self.message_queue.subscribe(f"user_{user_id}", self.deliver_message)
    
    def deliver_message(self, message):
        user_id = message['recipient_id']
        if user_id in self.connections:
            self.connections[user_id].send(message)
        else:
            # User offline, store for later delivery
            self.offline_storage.store(user_id, message)
```

**Load Balancing Connections**:
- Consistent hashing by user_id
- Session affinity for WebSocket connections
- Health checks and failover

### Message Processing Pipeline

**Message Flow**:
1. Client sends message via WebSocket
2. Gateway validates and adds metadata
3. Message service processes and stores
4. Fanout service delivers to recipients
5. Delivery confirmation sent back

**Message Service**:
```python
class MessageService:
    def process_message(self, message):
        # 1. Validate message
        if not self.validate_message(message):
            return {"error": "Invalid message"}
        
        # 2. Generate unique message ID
        message['message_id'] = self.generate_id()
        message['timestamp'] = datetime.utcnow()
        
        # 3. Store message
        self.store_message(message)
        
        # 4. Fanout to recipients
        recipients = self.get_chat_participants(message['chat_id'])
        for recipient_id in recipients:
            if recipient_id != message['sender_id']:
                self.message_queue.publish(f"user_{recipient_id}", message)
        
        # 5. Return acknowledgment
        return {"status": "sent", "message_id": message['message_id']}
```

### Group Message Fanout

**Fanout Strategies**:

**Pull Model** (Recommended for large groups):
```python
def fanout_pull_model(message, chat_id):
    # Store message once
    message_storage.store(message)
    
    # Notify online participants
    online_users = presence_service.get_online_users(chat_id)
    for user_id in online_users:
        notification_queue.publish(f"user_{user_id}", {
            "type": "new_message_notification",
            "chat_id": chat_id,
            "message_id": message['message_id']
        })
```

**Push Model** (For small groups <50 members):
```python
def fanout_push_model(message, chat_id):
    participants = chat_service.get_participants(chat_id)
    
    for user_id in participants:
        if user_id != message['sender_id']:
            # Send full message to each participant
            message_queue.publish(f"user_{user_id}", message)
```

### Presence Service

**Real-time Presence Updates**:
```python
class PresenceService:
    def __init__(self):
        self.redis_client = redis.Redis()
        self.heartbeat_interval = 30  # seconds
    
    def set_online(self, user_id, server_id):
        self.redis_client.hset("user_presence", user_id, json.dumps({
            "status": "online",
            "server_id": server_id,
            "last_seen": time.time()
        }))
        
        # Notify contacts about status change
        contacts = self.get_user_contacts(user_id)
        for contact_id in contacts:
            self.notify_presence_change(contact_id, user_id, "online")
    
    def heartbeat(self, user_id):
        # Update last seen timestamp
        presence = self.get_presence(user_id)
        if presence:
            presence['last_seen'] = time.time()
            self.redis_client.hset("user_presence", user_id, json.dumps(presence))
    
    def cleanup_offline_users(self):
        # Background job to mark users offline after timeout
        current_time = time.time()
        for user_id, presence_data in self.redis_client.hgetall("user_presence").items():
            presence = json.loads(presence_data)
            if current_time - presence['last_seen'] > 60:  # 1 minute timeout
                self.set_offline(user_id)
```

### Message Ordering and Delivery

**Message Ordering**:
- Use logical timestamps (Lamport clocks)
- Sequence numbers per chat
- Vector clocks for concurrent updates

**Delivery Guarantees**:
```python
class MessageDelivery:
    def deliver_with_retry(self, user_id, message, max_retries=3):
        for attempt in range(max_retries):
            try:
                if self.is_user_online(user_id):
                    self.send_via_websocket(user_id, message)
                else:
                    self.store_for_offline_delivery(user_id, message)
                
                # Wait for acknowledgment
                if self.wait_for_ack(message['message_id'], timeout=5):
                    return True
                    
            except Exception as e:
                if attempt == max_retries - 1:
                    # Final failure - store in dead letter queue
                    self.dead_letter_queue.store(user_id, message)
                    return False
                
                # Exponential backoff
                time.sleep(2 ** attempt)
        
        return False
```

## Scaling Considerations

### Database Sharding

**Shard by Chat ID**:
```python
def get_shard(chat_id):
    return chat_id % NUM_SHARDS

def route_message(message):
    shard = get_shard(message['chat_id'])
    return message_databases[shard]
```

**Hot Partition Problem**:
- Very active group chats can overwhelm a single shard
- Solution: Further partition by time ranges
- Move viral chats to dedicated high-performance shards

### Caching Strategy

**Multi-Level Caching**:
1. **L1 Cache**: Recent messages in application memory
2. **L2 Cache**: Redis cluster for chat metadata
3. **L3 Cache**: Chat participant lists

```python
class MessageCache:
    def get_recent_messages(self, chat_id, limit=50):
        # Try L1 cache first
        cache_key = f"recent_messages:{chat_id}"
        messages = self.memory_cache.get(cache_key)
        
        if not messages:
            # Try L2 cache (Redis)
            messages = self.redis_cache.get(cache_key)
            
            if not messages:
                # Fetch from database
                messages = self.database.get_messages(chat_id, limit)
                
                # Cache in both levels
                self.redis_cache.set(cache_key, messages, ttl=300)
            
            self.memory_cache.set(cache_key, messages, ttl=60)
        
        return messages
```

### Geographic Distribution

**Multi-Region Architecture**:
- WebSocket gateways in each region
- Message routing based on user location
- Cross-region message replication
- Regional presence services with global sync

## Chat System Design Quiz

Test your understanding of real-time chat system design with the interactive quiz that appears after each part of this series.

## Security and Privacy

### Message Security
- End-to-end encryption (client-side)
- Message integrity verification
- Forward secrecy for key rotation

### Privacy Protection
- Message retention policies
- User data anonymization
- GDPR compliance for data deletion

### Abuse Prevention
- Rate limiting for spam prevention
- Content moderation pipelines
- User reporting mechanisms

## Key Takeaways

1. **Real-time Architecture**: WebSockets enable bidirectional communication
2. **Message Ordering**: Critical for user experience, requires careful design
3. **Presence Management**: Efficient tracking reduces system overhead
4. **Fanout Strategies**: Choose between push/pull based on group size
5. **Graceful Degradation**: System should handle failures without data loss

## What's Next?

In Part 4, we'll design a social media feed system like Twitter, which introduces challenges around content ranking, timeline generation, and handling viral content.

---

**Previous:** [Part 2: Design a URL Shortener (TinyURL)](/posts/system-design-interview/part-2)  
**Next in series:** [Part 4: Design a Social Media Feed (Twitter)](/posts/system-design-interview/part-4)
