## MongoDB Indexing Strategies

### MongoDB Index Types

#### Single Field Indexes
```javascript
// Create index on a single field
db.users.createIndex({ "email": 1 })          // Ascending
db.users.createIndex({ "age": -1 })           // Descending
db.users.createIndex({ "status": 1 })

// Query using single field index
db.users.find({ "email": "john@example.com" })
db.users.find({ "age": { $gte: 25 } }).sort({ "age": -1 })
```

#### Compound Indexes
```javascript
// Create compound index (order matters!)
db.orders.createIndex({ "customer_id": 1, "order_date": -1, "status": 1 })

// Efficient queries using compound index:
db.orders.find({ "customer_id": 123 })                                    // Uses index
db.orders.find({ "customer_id": 123, "order_date": { $gte: new Date() } }) // Uses index
db.orders.find({ "customer_id": 123, "order_date": -1, "status": "active" }) // Uses full index

// Inefficient queries:
db.orders.find({ "order_date": { $gte: new Date() } })  // Can't use index efficiently
db.orders.find({ "status": "active" })                  // Can't use index efficiently
```

#### Text Indexes for Full-Text Search
```javascript
// Create text index
db.articles.createIndex({ 
    "title": "text", 
    "content": "text" 
}, { 
    weights: { "title": 10, "content": 1 },
    name: "article_text_index"
})

// Text search queries
db.articles.find({ $text: { $search: "database optimization" } })
db.articles.find({ 
    $text: { 
        $search: "\"database indexes\"",  // Exact phrase
        $caseSensitive: false 
    } 
}).sort({ score: { $meta: "textScore" } })
```

#### Geospatial Indexes
```javascript
// 2dsphere index for GeoJSON data
db.locations.createIndex({ "coordinates": "2dsphere" })

// Geospatial queries
db.locations.find({
    coordinates: {
        $near: {
            $geometry: { type: "Point", coordinates: [-122.4194, 37.7749] },
            $maxDistance: 1000  // meters
        }
    }
})

// Geospatial aggregation
db.locations.aggregate([
    {
        $geoNear: {
            near: { type: "Point", coordinates: [-122.4194, 37.7749] },
            distanceField: "distance",
            maxDistance: 5000,
            spherical: true
        }
    }
])
```

#### Partial Indexes
```javascript
// Index only documents matching a condition
db.users.createIndex(
    { "email": 1 }, 
    { partialFilterExpression: { "status": "active" } }
)

// Index only non-null values
db.products.createIndex(
    { "discount_price": 1 },
    { partialFilterExpression: { "discount_price": { $exists: true } } }
)
```

#### Sparse Indexes
```javascript
// Index only documents that contain the indexed field
db.users.createIndex({ "phone": 1 }, { sparse: true })

// Useful for optional fields to save space
db.profiles.createIndex({ "linkedin_url": 1 }, { sparse: true })
```

### MongoDB Index Performance

#### Analyzing Query Performance
```javascript
// Explain query execution
db.users.find({ "email": "john@example.com" }).explain("executionStats")

// Index usage statistics
db.users.aggregate([{ $indexStats: {} }])

// Get index information
db.users.getIndexes()
```

#### Index Hints
```javascript
// Force use of specific index
db.users.find({ "age": { $gte: 25 } }).hint({ "age": 1 })

// Use natural order (no index)
db.users.find().hint({ $natural: 1 })
```

## Cassandra Indexing

### Primary Key and Clustering

#### Partition Key and Clustering Columns
```sql
-- Table with compound primary key
CREATE TABLE user_sessions (
    user_id UUID,           -- Partition key
    session_date DATE,      -- Clustering column
    session_id TIMEUUID,    -- Clustering column
    ip_address TEXT,
    user_agent TEXT,
    PRIMARY KEY (user_id, session_date, session_id)
) WITH CLUSTERING ORDER BY (session_date DESC, session_id DESC);

-- Efficient queries (follow primary key structure):
SELECT * FROM user_sessions WHERE user_id = ?;
SELECT * FROM user_sessions WHERE user_id = ? AND session_date = ?;
SELECT * FROM user_sessions WHERE user_id = ? AND session_date >= ? AND session_date <= ?;
```

#### Secondary Indexes
```sql
-- Create secondary index
CREATE INDEX idx_user_sessions_ip ON user_sessions(ip_address);

-- Query using secondary index
SELECT * FROM user_sessions WHERE ip_address = '192.168.1.100';

-- Note: Secondary indexes in Cassandra have limitations:
-- - Can be expensive for large datasets
-- - Limited to equality comparisons
-- - Should be used with other WHERE clauses when possible
```

#### Materialized Views
```sql
-- Create materialized view for different query patterns
CREATE MATERIALIZED VIEW user_sessions_by_ip AS
    SELECT user_id, session_date, session_id, ip_address, user_agent
    FROM user_sessions
    WHERE ip_address IS NOT NULL AND user_id IS NOT NULL 
          AND session_date IS NOT NULL AND session_id IS NOT NULL
    PRIMARY KEY (ip_address, user_id, session_date, session_id);

-- Query the materialized view
SELECT * FROM user_sessions_by_ip WHERE ip_address = '192.168.1.100';
```

### Cassandra Indexing Best Practices

#### Avoid Anti-Patterns
```sql
-- BAD: Querying without partition key
SELECT * FROM user_sessions WHERE session_date = '2024-03-20';  -- Requires ALLOW FILTERING

-- BAD: Secondary index on high-cardinality column
CREATE INDEX idx_sessions_id ON user_sessions(session_id);  -- Will be slow

-- GOOD: Include partition key in queries
SELECT * FROM user_sessions 
WHERE user_id = ? AND session_date = '2024-03-20';

-- GOOD: Secondary index on low-cardinality column
CREATE INDEX idx_sessions_status ON user_sessions(status);  -- If status has few values
```

## Redis Indexing and Search

### Redis Search (RediSearch Module)

#### Creating Indexes
```redis
# Create index for hash documents
FT.CREATE user_idx 
    ON hash 
    PREFIX 1 "user:" 
    SCHEMA 
        name TEXT SORTABLE 
        email TEXT SORTABLE 
        age NUMERIC SORTABLE 
        city TAG SORTABLE
        bio TEXT

# Create index for JSON documents
FT.CREATE product_idx 
    ON JSON 
    PREFIX 1 "product:" 
    SCHEMA 
        $.name AS name TEXT SORTABLE 
        $.price AS price NUMERIC SORTABLE 
        $.category AS category TAG SORTABLE 
        $.description AS description TEXT
```

#### Searching with RediSearch
```redis
# Text search
FT.SEARCH user_idx "john"
FT.SEARCH user_idx "john doe"
FT.SEARCH user_idx "@name:john"

# Numeric range queries
FT.SEARCH user_idx "@age:[25 35]"

# Tag queries
FT.SEARCH user_idx "@city:{San Francisco}"

# Complex queries
FT.SEARCH user_idx "@name:john @age:[25 35] @city:{San Francisco}"

# Aggregation
FT.AGGREGATE user_idx "*" 
    GROUPBY 1 @city 
    REDUCE COUNT 0 AS count 
    SORTBY 2 @count DESC
```

### Redis Native Data Structure Indexing

#### Sets for Indexing
```redis
# Index users by city using sets
SADD "city:san_francisco" "user:1" "user:5" "user:10"
SADD "city:new_york" "user:2" "user:7"

# Find users in a specific city
SMEMBERS "city:san_francisco"

# Find users in multiple cities (union)
SUNION "city:san_francisco" "city:new_york"

# Find users in common cities (intersection)
SINTER "city:san_francisco" "active_users"
```

#### Sorted Sets for Range Queries
```redis
# Index users by age using sorted sets
ZADD "users_by_age" 25 "user:1" 30 "user:2" 35 "user:3"

# Range queries
ZRANGEBYSCORE "users_by_age" 25 35        # Users aged 25-35
ZREVRANGEBYSCORE "users_by_age" 35 25     # Users aged 25-35 (descending)
ZCOUNT "users_by_age" 25 35               # Count users aged 25-35
```

## DynamoDB Indexing

### Primary Key Structure
```javascript
// Hash key only
const userTable = {
    TableName: 'Users',
    KeySchema: [
        { AttributeName: 'userId', KeyType: 'HASH' }
    ],
    AttributeDefinitions: [
        { AttributeName: 'userId', AttributeType: 'S' }
    ]
};

// Hash key + Sort key
const orderTable = {
    TableName: 'Orders',
    KeySchema: [
        { AttributeName: 'customerId', KeyType: 'HASH' },    // Partition key
        { AttributeName: 'orderDate', KeyType: 'RANGE' }     // Sort key
    ],
    AttributeDefinitions: [
        { AttributeName: 'customerId', AttributeType: 'S' },
        { AttributeName: 'orderDate', AttributeType: 'S' }
    ]
};
```

### Global Secondary Indexes (GSI)
```javascript
// Create GSI for different query patterns
const gsiDefinition = {
    IndexName: 'email-index',
    KeySchema: [
        { AttributeName: 'email', KeyType: 'HASH' }
    ],
    AttributeDefinitions: [
        { AttributeName: 'email', AttributeType: 'S' }
    ],
    Projection: { ProjectionType: 'ALL' },  // Include all attributes
    ProvisionedThroughput: {
        ReadCapacityUnits: 5,
        WriteCapacityUnits: 5
    }
};

// Query using GSI
const params = {
    TableName: 'Users',
    IndexName: 'email-index',
    KeyConditionExpression: 'email = :email',
    ExpressionAttributeValues: {
        ':email': 'john@example.com'
    }
};
```

### Local Secondary Indexes (LSI)
```javascript
// LSI uses same partition key but different sort key
const lsiDefinition = {
    IndexName: 'customer-status-index',
    KeySchema: [
        { AttributeName: 'customerId', KeyType: 'HASH' },    // Same partition key
        { AttributeName: 'status', KeyType: 'RANGE' }        // Different sort key
    ],
    Projection: {
        ProjectionType: 'INCLUDE',
        NonKeyAttributes: ['orderTotal', 'items']
    }
};
```

## Elasticsearch Indexing

### Index Mapping and Analysis
```json
// Create index with custom mapping
PUT /products
{
  "mappings": {
    "properties": {
      "name": {
        "type": "text",
        "analyzer": "standard",
        "fields": {
          "keyword": {
            "type": "keyword"
          }
        }
      },
      "price": {
        "type": "float"
      },
      "category": {
        "type": "keyword"
      },
      "description": {
        "type": "text",
        "analyzer": "english"
      },
      "created_at": {
        "type": "date"
      },
      "location": {
        "type": "geo_point"
      }
    }
  }
}
```

### Elasticsearch Query Optimization
```json
// Multi-field search with boosting
GET /products/_search
{
  "query": {
    "multi_match": {
      "query": "wireless headphones",
      "fields": ["name^3", "description"],
      "type": "best_fields"
    }
  }
}

// Filtered search with aggregations
GET /products/_search
{
  "query": {
    "bool": {
      "must": [
        { "match": { "description": "wireless" } }
      ],
      "filter": [
        { "range": { "price": { "gte": 50, "lte": 200 } } },
        { "term": { "category": "electronics" } }
      ]
    }
  },
  "aggs": {
    "price_ranges": {
      "range": {
        "field": "price",
        "ranges": [
          { "to": 50 },
          { "from": 50, "to": 100 },
          { "from": 100, "to": 200 },
          { "from": 200 }
        ]
      }
    }
  }
}
```

## NoSQL Indexing Best Practices

### Design for Query Patterns
1. **Understand Access Patterns**: Design indexes based on how data will be queried
2. **Denormalization**: Accept data duplication to optimize read performance
3. **Composite Keys**: Use compound keys to support multiple query patterns

### MongoDB Specific
- **ESR Rule**: Equality, Sort, Range - order compound index fields by this priority
- **Index Intersection**: MongoDB can use multiple single-field indexes together
- **Index Prefix**: Compound indexes can support queries on index prefixes

### Cassandra Specific
- **Partition Key Design**: Ensure even data distribution across nodes
- **Clustering Columns**: Use for sorting and range queries within partitions
- **Secondary Index Limitations**: Use sparingly and with other WHERE clauses

### Document Database Patterns
```javascript
// MongoDB: Embedded vs Referenced data
// Embedded for one-to-few relationships
{
    "_id": ObjectId("..."),
    "user_id": 123,
    "order_date": ISODate("..."),
    "items": [
        { "product_id": 456, "quantity": 2, "price": 29.99 },
        { "product_id": 789, "quantity": 1, "price": 19.99 }
    ]
}

// Referenced for one-to-many relationships
// Orders collection
{ "_id": ObjectId("..."), "user_id": 123, "total": 79.97 }

// Order_items collection
{ "_id": ObjectId("..."), "order_id": ObjectId("..."), "product_id": 456 }
```

## Performance Monitoring

### MongoDB Monitoring
```javascript
// Index usage statistics
db.users.aggregate([{ $indexStats: {} }])

// Slow query profiling
db.setProfilingLevel(2, { slowms: 100 })
db.system.profile.find().sort({ ts: -1 }).limit(5)
```

### Cassandra Monitoring
```sql
-- Check table statistics
SELECT * FROM system.size_estimates WHERE keyspace_name = 'your_keyspace';

-- Monitor read/write latencies
nodetool cfstats your_keyspace.your_table
```

## Next Steps
In Part 4, we'll explore composite indexes and advanced query optimization techniques, including index intersection, covering indexes, and query plan analysis across different database systems.
