## MySQL Indexing Deep Dive

### InnoDB Storage Engine
MySQL's InnoDB engine uses clustered indexes by default:

```sql
-- Primary key automatically becomes clustered index
CREATE TABLE users (
    id INT AUTO_INCREMENT PRIMARY KEY,  -- Clustered index
    email VARCHAR(255) UNIQUE,          -- Secondary index
    name VARCHAR(100),
    age INT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    INDEX idx_email (email),            -- Explicit secondary index
    INDEX idx_age_name (age, name)      -- Composite index
);
```

### MySQL Index Types and Syntax

#### Single Column Indexes
```sql
-- Create index during table creation
CREATE TABLE products (
    id INT PRIMARY KEY,
    name VARCHAR(255),
    price DECIMAL(10,2),
    category_id INT,
    INDEX idx_price (price),
    INDEX idx_category (category_id)
);

-- Add index to existing table
ALTER TABLE products ADD INDEX idx_name (name);
CREATE INDEX idx_name_price ON products(name, price);
```

#### Composite Indexes (Multiple Columns)
```sql
-- Order matters! This index can efficiently handle:
-- 1. WHERE category_id = ?
-- 2. WHERE category_id = ? AND price > ?
-- 3. WHERE category_id = ? AND price > ? AND name LIKE ?
CREATE INDEX idx_category_price_name ON products(category_id, price, name);

-- This won't efficiently use the above index:
SELECT * FROM products WHERE price > 100;  -- Missing category_id prefix
```

#### Partial Indexes (Prefix Indexes)
```sql
-- Index only first 10 characters of name (saves space)
CREATE INDEX idx_name_prefix ON products(name(10));

-- Good for columns with long text values
CREATE INDEX idx_description_prefix ON articles(description(50));
```

### MySQL Index Optimization

#### Using EXPLAIN to Analyze Queries
```sql
-- Analyze query execution plan
EXPLAIN SELECT * FROM users WHERE age > 25 AND name LIKE 'John%';

-- Extended explain with more details
EXPLAIN FORMAT=JSON SELECT * FROM users WHERE email = 'john@example.com';
```

#### Index Hints
```sql
-- Force MySQL to use a specific index
SELECT * FROM users USE INDEX (idx_age_name) WHERE age > 25;

-- Suggest an index (MySQL may ignore)
SELECT * FROM users USE INDEX (idx_age) WHERE age > 25 AND name LIKE 'J%';

-- Force MySQL to ignore an index
SELECT * FROM users IGNORE INDEX (idx_age) WHERE age > 25;
```

## PostgreSQL Advanced Indexing

### PostgreSQL Index Types

#### GiST (Generalized Search Tree)
```sql
-- Excellent for full-text search and geometric data
CREATE INDEX idx_articles_content ON articles USING gist(to_tsvector('english', content));

-- Range types and arrays
CREATE INDEX idx_price_ranges ON products USING gist(price_range);
```

#### GIN (Generalized Inverted Index)
```sql
-- Perfect for JSONB, arrays, and full-text search
CREATE INDEX idx_user_tags ON users USING gin(tags);  -- For array columns
CREATE INDEX idx_user_metadata ON users USING gin(metadata);  -- For JSONB

-- Full-text search
CREATE INDEX idx_articles_search ON articles USING gin(to_tsvector('english', title || ' ' || content));
```

#### BRIN (Block Range Index)
```sql
-- Efficient for large tables with naturally ordered data
CREATE INDEX idx_orders_date ON orders USING brin(order_date);

-- Great for time-series data with minimal storage overhead
CREATE INDEX idx_logs_timestamp ON application_logs USING brin(created_at);
```

### PostgreSQL Partial Indexes
```sql
-- Index only active users (saves space and improves performance)
CREATE INDEX idx_active_users_email ON users(email) WHERE status = 'active';

-- Index only recent orders
CREATE INDEX idx_recent_orders ON orders(customer_id) 
WHERE order_date >= '2024-01-01';

-- Index only non-null values
CREATE INDEX idx_users_phone ON users(phone) WHERE phone IS NOT NULL;
```

### PostgreSQL Expression Indexes
```sql
-- Index on computed values
CREATE INDEX idx_users_lower_email ON users(lower(email));
CREATE INDEX idx_products_discounted_price ON products((price * 0.9)) WHERE on_sale = true;

-- Functional index for complex queries
CREATE INDEX idx_user_full_name ON users((first_name || ' ' || last_name));
```

## SQL Server Indexing Strategies

### Clustered vs Non-Clustered Indexes

#### Clustered Index Management
```sql
-- Create clustered index (only one per table)
CREATE CLUSTERED INDEX idx_orders_date ON orders(order_date);

-- Drop and recreate clustered index
DROP INDEX idx_orders_date ON orders;
CREATE CLUSTERED INDEX idx_orders_customer_date ON orders(customer_id, order_date);
```

#### Non-Clustered Indexes with Included Columns
```sql
-- Include additional columns at leaf level (covering index)
CREATE NONCLUSTERED INDEX idx_users_email_covering 
ON users(email) 
INCLUDE (first_name, last_name, phone);

-- This query uses index-only scan (no key lookup needed)
SELECT first_name, last_name, phone FROM users WHERE email = 'john@example.com';
```

### SQL Server Index Features

#### Filtered Indexes
```sql
-- Index only specific subset of data
CREATE NONCLUSTERED INDEX idx_active_users 
ON users(last_login_date) 
WHERE status = 'active' AND last_login_date IS NOT NULL;
```

#### Columnstore Indexes
```sql
-- For analytical workloads (OLAP)
CREATE NONCLUSTERED COLUMNSTORE INDEX idx_sales_columnstore 
ON sales(product_id, customer_id, sale_date, amount, quantity);

-- Clustered columnstore for data warehouse tables
CREATE CLUSTERED COLUMNSTORE INDEX idx_fact_sales ON fact_sales;
```

## Oracle Database Indexing

### Oracle Index Types

#### Function-Based Indexes
```sql
-- Index on expressions
CREATE INDEX idx_users_upper_email ON users(UPPER(email));
CREATE INDEX idx_orders_year ON orders(EXTRACT(YEAR FROM order_date));

-- Complex function-based index
CREATE INDEX idx_products_profit_margin ON products((price - cost) / price * 100);
```

#### Reverse Key Indexes
```sql
-- Distribute sequential inserts across index blocks
CREATE INDEX idx_orders_id_reverse ON orders(order_id) REVERSE;
```

#### Bitmap Join Indexes
```sql
-- Pre-join dimension tables for star schema queries
CREATE BITMAP INDEX idx_sales_customer_region 
ON sales(customers.region)
FROM sales, customers
WHERE sales.customer_id = customers.customer_id;
```

## Cross-Database Index Best Practices

### Index Naming Conventions
```sql
-- Consistent naming across databases
-- Pattern: idx_[table]_[columns]_[type]
CREATE INDEX idx_users_email_unique ON users(email);          -- Unique
CREATE INDEX idx_orders_customer_date ON orders(customer_id, order_date);  -- Composite
CREATE INDEX idx_products_name_partial ON products(name(20)); -- Partial/Prefix
CREATE INDEX idx_logs_created_filtered ON logs(created_at) WHERE level = 'ERROR';  -- Filtered
```

### Monitoring Index Usage

#### MySQL
```sql
-- Check index usage statistics
SELECT 
    TABLE_SCHEMA,
    TABLE_NAME,
    INDEX_NAME,
    CARDINALITY,
    SUB_PART
FROM INFORMATION_SCHEMA.STATISTICS 
WHERE TABLE_SCHEMA = 'your_database';

-- Performance Schema for index usage
SELECT 
    object_schema,
    object_name,
    index_name,
    count_read,
    count_write,
    sum_timer_read,
    sum_timer_write
FROM performance_schema.table_io_waits_summary_by_index_usage;
```

#### PostgreSQL
```sql
-- Index usage statistics
SELECT 
    schemaname,
    tablename,
    indexname,
    idx_scan,
    idx_tup_read,
    idx_tup_fetch
FROM pg_stat_user_indexes;

-- Unused indexes
SELECT 
    schemaname,
    tablename,
    indexname,
    idx_scan
FROM pg_stat_user_indexes 
WHERE idx_scan = 0;
```

#### SQL Server
```sql
-- Index usage statistics
SELECT 
    OBJECT_NAME(i.object_id) AS table_name,
    i.name AS index_name,
    dm_ius.user_seeks,
    dm_ius.user_scans,
    dm_ius.user_lookups,
    dm_ius.user_updates
FROM sys.indexes i
LEFT JOIN sys.dm_db_index_usage_stats dm_ius 
    ON i.object_id = dm_ius.object_id AND i.index_id = dm_ius.index_id
WHERE i.object_id = OBJECT_ID('your_table');
```

## Common SQL Indexing Patterns

### Covering Indexes
```sql
-- Include all needed columns to avoid table lookups
-- MySQL
CREATE INDEX idx_users_email_covering ON users(email, first_name, last_name, phone);

-- SQL Server with INCLUDE
CREATE INDEX idx_users_email_covering ON users(email) INCLUDE (first_name, last_name, phone);

-- PostgreSQL (covering through index-only scans)
CREATE INDEX idx_users_email_names ON users(email, first_name, last_name);
```

### Composite Index Column Order
```sql
-- Rule: Most selective column first, then by query patterns
-- Good: High selectivity on email, then commonly filtered by status
CREATE INDEX idx_users_email_status ON users(email, status);

-- Consider query patterns:
-- Query 1: WHERE email = ? AND status = ?     -- Uses index efficiently
-- Query 2: WHERE status = ?                   -- Less efficient
-- Query 3: WHERE email = ?                    -- Uses index efficiently

-- Solution: Create multiple indexes for different query patterns
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_status ON users(status);
CREATE INDEX idx_users_email_status ON users(email, status);  -- For combined queries
```

## Index Maintenance and Optimization

### Rebuilding Indexes
```sql
-- MySQL
OPTIMIZE TABLE users;
ALTER TABLE users ENGINE=InnoDB;  -- Rebuilds table and indexes

-- PostgreSQL
REINDEX INDEX idx_users_email;
REINDEX TABLE users;

-- SQL Server
ALTER INDEX idx_users_email ON users REBUILD;
ALTER INDEX ALL ON users REBUILD;

-- Oracle
ALTER INDEX idx_users_email REBUILD;
```

### Index Statistics
```sql
-- MySQL
ANALYZE TABLE users;

-- PostgreSQL
ANALYZE users;
ANALYZE users(email);  -- Specific column

-- SQL Server
UPDATE STATISTICS users;
UPDATE STATISTICS users idx_users_email;

-- Oracle
EXEC DBMS_STATS.GATHER_TABLE_STATS('schema', 'users');
```

## Performance Tuning Tips

1. **Monitor Query Patterns**: Create indexes based on actual query patterns, not assumptions
2. **Avoid Over-Indexing**: Each index has maintenance overhead
3. **Use Composite Indexes Wisely**: Column order matters for query efficiency
4. **Regular Maintenance**: Keep statistics updated and rebuild fragmented indexes
5. **Test in Production-Like Environment**: Index performance varies with data size and distribution

## Next Steps
In Part 3, we'll explore NoSQL database indexing strategies, covering MongoDB, Cassandra, Redis, and other NoSQL systems with their unique indexing approaches.
