## Advanced Indexing Techniques

### Partitioned Indexes

Partitioned indexes split large indexes across multiple physical structures, improving performance and manageability for very large tables.

#### PostgreSQL Table Partitioning with Indexes

```sql
-- Create partitioned table by date range
CREATE TABLE sales_partitioned (
    id BIGSERIAL,
    customer_id INT,
    sale_date DATE,
    amount DECIMAL(10,2),
    product_id INT,
    region VARCHAR(50)
) PARTITION BY RANGE (sale_date);

-- Create partitions for different date ranges
CREATE TABLE sales_2023 PARTITION OF sales_partitioned
    FOR VALUES FROM ('2023-01-01') TO ('2024-01-01');

CREATE TABLE sales_2024 PARTITION OF sales_partitioned
    FOR VALUES FROM ('2024-01-01') TO ('2025-01-01');

-- Create indexes on each partition
CREATE INDEX idx_sales_2023_customer ON sales_2023(customer_id, sale_date);
CREATE INDEX idx_sales_2024_customer ON sales_2024(customer_id, sale_date);

-- Create global index across all partitions
CREATE INDEX idx_sales_partitioned_customer ON sales_partitioned(customer_id);

-- Queries automatically use partition pruning
EXPLAIN (ANALYZE, BUFFERS) 
SELECT * FROM sales_partitioned 
WHERE sale_date BETWEEN '2024-01-01' AND '2024-01-31'
  AND customer_id = 1000;
```

#### SQL Server Partitioned Indexes

```sql
-- Create partition function and scheme
CREATE PARTITION FUNCTION sales_date_function (DATE)
AS RANGE RIGHT FOR VALUES (
    '2023-01-01', '2023-04-01', '2023-07-01', '2023-10-01',
    '2024-01-01', '2024-04-01', '2024-07-01', '2024-10-01'
);

CREATE PARTITION SCHEME sales_date_scheme
AS PARTITION sales_date_function
TO (
    [Partition1], [Partition2], [Partition3], [Partition4],
    [Partition5], [Partition6], [Partition7], [Partition8]
);

-- Create partitioned table
CREATE TABLE sales_partitioned (
    id BIGINT IDENTITY(1,1),
    customer_id INT,
    sale_date DATE,
    amount DECIMAL(10,2),
    product_id INT,
    region VARCHAR(50),
    CONSTRAINT PK_sales_partitioned PRIMARY KEY (id, sale_date)
) ON sales_date_scheme(sale_date);

-- Create partitioned index
CREATE INDEX idx_sales_customer_partitioned
ON sales_partitioned(customer_id, sale_date)
ON sales_date_scheme(sale_date);
```

### Columnar Indexes

Columnar indexes store data column-wise rather than row-wise, providing exceptional performance for analytical queries.

#### SQL Server Columnstore Indexes

```sql
-- Create clustered columnstore index for OLAP workload
CREATE TABLE fact_sales (
    sale_id BIGINT,
    customer_id INT,
    product_id INT,
    sale_date DATE,
    quantity INT,
    unit_price DECIMAL(10,2),
    total_amount DECIMAL(12,2),
    store_id INT,
    region_id INT
);

-- Clustered columnstore index (entire table stored as columnstore)
CREATE CLUSTERED COLUMNSTORE INDEX cci_fact_sales ON fact_sales;

-- Non-clustered columnstore index (for mixed workloads)
CREATE TABLE sales_mixed (
    id INT IDENTITY(1,1) PRIMARY KEY,
    customer_id INT,
    product_id INT,
    sale_date DATE,
    amount DECIMAL(10,2),
    created_at DATETIME2 DEFAULT GETDATE()
);

-- Non-clustered columnstore for analytics
CREATE NONCLUSTERED COLUMNSTORE INDEX ncci_sales_analytics
ON sales_mixed(customer_id, product_id, sale_date, amount);

-- Analytical query performance
SELECT 
    YEAR(sale_date) as sale_year,
    region_id,
    SUM(total_amount) as total_sales,
    AVG(total_amount) as avg_sale,
    COUNT(*) as transaction_count
FROM fact_sales
WHERE sale_date >= '2023-01-01'
GROUP BY YEAR(sale_date), region_id
ORDER BY total_sales DESC;
```

#### PostgreSQL Columnar Storage (with Citus)

```sql
-- Using columnar extension for analytics
CREATE EXTENSION columnar;

-- Create columnar table for analytics
CREATE TABLE analytics_sales (
    customer_id INT,
    product_category VARCHAR(50),
    sale_date DATE,
    amount DECIMAL(10,2),
    quantity INT,
    region VARCHAR(50)
) USING columnar;

-- Analytical queries perform much better
SELECT 
    product_category,
    region,
    DATE_TRUNC('month', sale_date) as month,
    SUM(amount) as total_sales,
    SUM(quantity) as total_quantity
FROM analytics_sales
WHERE sale_date >= '2023-01-01'
GROUP BY product_category, region, DATE_TRUNC('month', sale_date)
ORDER BY total_sales DESC;
```

### Expression-Based and Functional Indexes

Create indexes on computed values and function results for complex query patterns.

#### PostgreSQL Functional Indexes

```sql
-- Index on function result
CREATE INDEX idx_users_lower_email ON users(lower(email));
CREATE INDEX idx_products_profit_margin ON products((price - cost) / price * 100);

-- Index on extracted date parts
CREATE INDEX idx_orders_year_month ON orders(EXTRACT(YEAR FROM order_date), EXTRACT(MONTH FROM order_date));

-- Complex expression index
CREATE INDEX idx_customer_full_name ON customers((first_name || ' ' || last_name));

-- JSONB functional indexes
CREATE INDEX idx_user_preferences_theme 
ON users((preferences->>'theme')) 
WHERE preferences->>'theme' IS NOT NULL;

-- Trigram indexes for fuzzy text search
CREATE EXTENSION pg_trgm;
CREATE INDEX idx_products_name_trgm ON products USING gin(name gin_trgm_ops);

-- Usage examples
SELECT * FROM users WHERE lower(email) = 'john@example.com';
SELECT * FROM products WHERE (price - cost) / price * 100 > 50;
SELECT * FROM products WHERE name % 'wireless headphne';  -- Fuzzy match
```

#### Oracle Function-Based Indexes

```sql
-- Function-based indexes
CREATE INDEX idx_employees_upper_last_name ON employees(UPPER(last_name));
CREATE INDEX idx_orders_year ON orders(EXTRACT(YEAR FROM order_date));

-- Case-insensitive searches
CREATE INDEX idx_products_case_insensitive ON products(UPPER(product_name));

-- Complex calculations
CREATE INDEX idx_inventory_turnover ON inventory((units_sold / average_inventory) * 365);

-- Virtual columns with indexes (Oracle 11g+)
ALTER TABLE products ADD (profit_margin GENERATED ALWAYS AS ((price - cost) / price * 100));
CREATE INDEX idx_products_profit_margin ON products(profit_margin);
```

### Specialized Index Types

#### Graph Database Indexing (Neo4j)

```cypher
// Create node indexes
CREATE INDEX customer_email_idx FOR (c:Customer) ON (c.email);
CREATE INDEX product_sku_idx FOR (p:Product) ON (p.sku);
CREATE INDEX order_date_idx FOR (o:Order) ON (o.date);

// Composite indexes
CREATE INDEX customer_region_status FOR (c:Customer) ON (c.region, c.status);

// Full-text indexes
CREATE FULLTEXT INDEX product_search FOR (p:Product) ON EACH [p.name, p.description];

// Range indexes for relationships
CREATE RANGE INDEX purchase_amount FOR ()-[r:PURCHASED]-() ON (r.amount);

// Query using indexes
MATCH (c:Customer {email: 'john@example.com'})-[r:PURCHASED]->(p:Product)
WHERE r.amount > 100
RETURN c.name, p.name, r.amount;

// Full-text search
CALL db.index.fulltext.queryNodes('product_search', 'wireless bluetooth') 
YIELD node, score
RETURN node.name, node.description, score;
```

#### Time-Series Database Indexing (InfluxDB)

```sql
-- InfluxDB automatically creates indexes on tags
-- Tags are indexed, fields are not

-- Example schema design
-- Measurement: cpu_usage
-- Tags: host, region, environment (automatically indexed)
-- Fields: usage_percent, load_average (not indexed)

-- Query using tag indexes (fast)
SELECT mean(usage_percent) 
FROM cpu_usage 
WHERE host = 'server-01' 
  AND region = 'us-west' 
  AND time >= now() - 1h 
GROUP BY time(5m);

-- Query on field (slower, requires scan)
SELECT * FROM cpu_usage WHERE usage_percent > 90;

-- Best practices for time-series indexing:
-- 1. Use tags for dimensions you filter/group by
-- 2. Keep tag cardinality reasonable (< 1M unique combinations)
-- 3. Use fields for measured values
-- 4. Design retention policies for old data
```

### Vector Indexes for AI/ML Workloads

#### PostgreSQL with pgvector

```sql
-- Install pgvector extension
CREATE EXTENSION vector;

-- Create table with vector column
CREATE TABLE document_embeddings (
    id BIGSERIAL PRIMARY KEY,
    document_id INT,
    title TEXT,
    content_vector vector(384),  -- 384-dimensional embeddings
    created_at TIMESTAMP DEFAULT NOW()
);

-- Create HNSW index for fast similarity search
CREATE INDEX idx_embeddings_hnsw 
ON document_embeddings 
USING hnsw (content_vector vector_cosine_ops);

-- Alternative: IVFFlat index
CREATE INDEX idx_embeddings_ivf 
ON document_embeddings 
USING ivfflat (content_vector vector_cosine_ops) 
WITH (lists = 100);

-- Similarity search queries
SELECT 
    document_id,
    title,
    content_vector <=> '[0.1, 0.2, 0.3, ...]'::vector AS distance
FROM document_embeddings
ORDER BY content_vector <=> '[0.1, 0.2, 0.3, ...]'::vector
LIMIT 10;

-- K-nearest neighbors with filters
SELECT 
    document_id,
    title,
    content_vector <-> '[0.1, 0.2, 0.3, ...]'::vector AS distance
FROM document_embeddings
WHERE created_at >= '2024-01-01'
ORDER BY content_vector <-> '[0.1, 0.2, 0.3, ...]'::vector
LIMIT 5;
```

#### Elasticsearch Vector Search

```json
// Create index mapping with dense vector field
PUT /documents
{
  "mappings": {
    "properties": {
      "title": { "type": "text" },
      "content": { "type": "text" },
      "embedding": {
        "type": "dense_vector",
        "dims": 384,
        "index": true,
        "similarity": "cosine"
      },
      "created_at": { "type": "date" }
    }
  }
}

// Index document with vector
POST /documents/_doc/1
{
  "title": "Machine Learning Basics",
  "content": "Introduction to machine learning concepts...",
  "embedding": [0.1, 0.2, 0.3, ...],
  "created_at": "2024-01-15"
}

// Vector similarity search
GET /documents/_search
{
  "knn": {
    "field": "embedding",
    "query_vector": [0.1, 0.2, 0.3, ...],
    "k": 10,
    "num_candidates": 100
  },
  "filter": {
    "range": {
      "created_at": {
        "gte": "2024-01-01"
      }
    }
  }
}
```

## Big Data Indexing Strategies

### Apache Spark with Delta Lake

```scala
// Create Delta table with optimized layout
import io.delta.tables._

// Create partitioned Delta table
spark.sql("""
CREATE TABLE sales_delta (
    customer_id LONG,
    product_id LONG,
    sale_date DATE,
    amount DECIMAL(10,2),
    region STRING
) 
USING DELTA
PARTITIONED BY (region, date_format(sale_date, 'yyyy-MM'))
""")

// Z-ORDER optimization for multi-dimensional clustering
spark.sql("OPTIMIZE sales_delta ZORDER BY (customer_id, product_id)")

// Data skipping with statistics
spark.sql("ANALYZE TABLE sales_delta COMPUTE STATISTICS FOR ALL COLUMNS")

// Bloom filters for high-cardinality columns
spark.sql("""
ALTER TABLE sales_delta 
SET TBLPROPERTIES (
    'delta.bloomFilter.customer_id' = 'true',
    'delta.bloomFilter.product_id' = 'true'
)
""")
```

### Apache Iceberg Indexing

```sql
-- Create Iceberg table with hidden partitioning
CREATE TABLE sales_iceberg (
    customer_id BIGINT,
    product_id BIGINT,
    sale_date DATE,
    amount DECIMAL(10,2),
    region STRING
) 
USING iceberg
PARTITIONED BY (bucket(16, customer_id), days(sale_date));

-- Iceberg automatically maintains partition statistics
-- Query planning uses these statistics for pruning

-- Sort order for better clustering
ALTER TABLE sales_iceberg WRITE ORDERED BY (customer_id, sale_date);
```

### ClickHouse Specialized Indexes

```sql
-- Primary key acts as sparse index
CREATE TABLE events (
    user_id UInt64,
    event_time DateTime,
    event_type String,
    page_url String,
    session_id String
) 
ENGINE = MergeTree()
ORDER BY (user_id, event_time);

-- Skip indexes for non-primary key columns
ALTER TABLE events ADD INDEX idx_event_type event_type TYPE set(100) GRANULARITY 4;
ALTER TABLE events ADD INDEX idx_page_url page_url TYPE bloom_filter(0.01) GRANULARITY 1;

-- Projection for pre-aggregated data
ALTER TABLE events ADD PROJECTION daily_stats (
    SELECT 
        user_id,
        toDate(event_time) as date,
        event_type,
        count()
    GROUP BY user_id, date, event_type
);

-- Materialize the projection
ALTER TABLE events MATERIALIZE PROJECTION daily_stats;
```

## Index Design for Specific Workloads

### OLTP (Online Transaction Processing) Optimization

```sql
-- Optimize for frequent point lookups and small range scans
-- High concurrency, low latency requirements

-- Order processing system indexes
CREATE TABLE orders_oltp (
    order_id BIGINT PRIMARY KEY,
    customer_id INT,
    order_date TIMESTAMP,
    status VARCHAR(20),
    total_amount DECIMAL(10,2),
    shipping_address_id INT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- OLTP-optimized indexes
CREATE INDEX idx_orders_customer_status ON orders_oltp(customer_id, status);  -- Customer order lookup
CREATE INDEX idx_orders_date_status ON orders_oltp(order_date, status);       -- Date range queries
CREATE INDEX idx_orders_status_updated ON orders_oltp(status, updated_at);    -- Status monitoring
CREATE UNIQUE INDEX idx_orders_customer_date ON orders_oltp(customer_id, order_date, order_id);  -- Avoid duplicates

-- Covering index for order summary
CREATE INDEX idx_orders_customer_covering ON orders_oltp(customer_id) 
INCLUDE (order_date, status, total_amount);  -- SQL Server syntax
```

### OLAP (Online Analytical Processing) Optimization

```sql
-- Optimize for complex aggregations and analytical queries
-- Lower concurrency, higher latency acceptable

-- Sales analytics table
CREATE TABLE sales_olap (
    sale_id BIGINT,
    customer_id INT,
    product_id INT,
    category_id INT,
    sale_date DATE,
    quantity INT,
    unit_price DECIMAL(10,2),
    total_amount DECIMAL(12,2),
    store_id INT,
    region_id INT,
    salesperson_id INT
);

-- OLAP-optimized indexes (wider, covering more columns)
CREATE INDEX idx_sales_time_hierarchy ON sales_olap(sale_date, category_id, region_id, store_id);
CREATE INDEX idx_sales_product_analysis ON sales_olap(product_id, category_id, sale_date);
CREATE INDEX idx_sales_customer_behavior ON sales_olap(customer_id, sale_date, product_id);

-- Columnstore index for analytics (SQL Server)
CREATE NONCLUSTERED COLUMNSTORE INDEX ncci_sales_analytics 
ON sales_olap(sale_date, customer_id, product_id, category_id, quantity, total_amount, region_id);

-- Aggregate tables with appropriate indexes
CREATE TABLE sales_daily_summary (
    sale_date DATE,
    category_id INT,
    region_id INT,
    total_sales DECIMAL(15,2),
    total_quantity INT,
    transaction_count INT,
    PRIMARY KEY (sale_date, category_id, region_id)
);
```

### Hybrid Workload (HTAP) Optimization

```sql
-- Balance between OLTP and OLAP requirements
-- Use read replicas or specialized engines

-- Main OLTP table with minimal indexes
CREATE TABLE transactions_htap (
    transaction_id BIGINT PRIMARY KEY,
    account_id INT,
    transaction_date TIMESTAMP,
    amount DECIMAL(12,2),
    transaction_type VARCHAR(20),
    description TEXT,
    status VARCHAR(20),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- OLTP indexes (lean and focused)
CREATE INDEX idx_transactions_account_date ON transactions_htap(account_id, transaction_date);
CREATE INDEX idx_transactions_status ON transactions_htap(status) WHERE status != 'completed';

-- Analytical read replica with additional indexes
-- (This could be a separate analytical database)
CREATE INDEX idx_transactions_analytics_time ON transactions_htap(transaction_date, transaction_type, amount);
CREATE INDEX idx_transactions_analytics_type ON transactions_htap(transaction_type, transaction_date, account_id);

-- Use database-specific features for HTAP
-- SQL Server: In-Memory OLTP with columnstore
-- MySQL: HeatWave analytics engine
-- PostgreSQL: Parallel query execution
-- Oracle: In-Memory column store
```

## Performance Optimization Patterns

### Index Design Principles for Scale

1. **Minimize Index Count**: Each index has maintenance overhead
2. **Maximize Index Utilization**: Design for multiple query patterns
3. **Consider Data Distribution**: Account for skewed data
4. **Plan for Growth**: Design for future data volumes

### Advanced Optimization Techniques

```sql
-- Filtered indexes for skewed data
CREATE INDEX idx_orders_recent ON orders(customer_id, order_date) 
WHERE order_date >= '2024-01-01';

-- Partial unique indexes
CREATE UNIQUE INDEX idx_users_active_email ON users(email) 
WHERE status = 'active';

-- Conditional indexes for sparse data
CREATE INDEX idx_products_discount ON products(discount_percentage) 
WHERE discount_percentage > 0;

-- Descending indexes for recent-first queries
CREATE INDEX idx_logs_timestamp_desc ON application_logs(timestamp DESC);
```

## Next Steps
In Part 7, we'll explore client-side optimization strategies including connection pooling, query caching, application-level indexing, and CDN optimization techniques to complement database indexing strategies.
