# Algorithm Analysis Techniques

Calculating Big O complexity isn't guesswork – it's a systematic process. Master these analysis techniques and you'll be able to determine the complexity of any algorithm with confidence.

## The Step-by-Step Analysis Method

### 1. Identify the Input
- What parameter determines the algorithm's workload?
- Is it array length, string length, tree height, or something else?

### 2. Count Basic Operations
- Focus on the most frequently executed operation
- Usually: comparisons, assignments, arithmetic operations

### 3. Express as a Function of Input Size
- How many times does the basic operation execute?
- Create a mathematical expression: T(n) = ...

### 4. Apply Big O Rules
- Drop constants and lower-order terms
- Focus on the dominant growth factor

## Loop Analysis Patterns

### Single Loop = O(n)

```javascript
function sumArray(arr) {
  let sum = 0;                    // O(1)
  for (let i = 0; i < arr.length; i++) {  // Loop runs n times
    sum += arr[i];                // O(1) operation × n times
  }
  return sum;                     // O(1)
}
// Total: O(1) + O(n) + O(1) = O(n)
```

### Nested Loops = O(n²)

```javascript
function bubbleSort(arr) {
  const n = arr.length;
  for (let i = 0; i < n; i++) {          // Outer: n iterations
    for (let j = 0; j < n - 1; j++) {    // Inner: n iterations each
      if (arr[j] > arr[j + 1]) {         // O(1) × n × n = O(n²)
        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
      }
    }
  }
}
// Total: O(n²)
```

### Variable Inner Loop

```javascript
function printPairs(arr) {
  for (let i = 0; i < arr.length; i++) {
    for (let j = i + 1; j < arr.length; j++) {
      console.log(arr[i], arr[j]);
    }
  }
}
/*
Analysis:
i=0: inner loop runs n-1 times
i=1: inner loop runs n-2 times
...
i=n-2: inner loop runs 1 time

Total: (n-1) + (n-2) + ... + 1 = n(n-1)/2 = O(n²)
*/
```

## Conditional Analysis

### Best, Average, and Worst Case

```javascript
function linearSearch(arr, target) {
  for (let i = 0; i < arr.length; i++) {
    if (arr[i] === target) {
      return i;  // Found it!
    }
  }
  return -1;  // Not found
}

/*
Best case: O(1) - element is first
Average case: O(n/2) = O(n) - element in middle
Worst case: O(n) - element last or not present

Big O focuses on worst case: O(n)
*/
```

### Complex Conditionals

```javascript
function smartSearch(arr, target) {
  // If array is small, use linear search
  if (arr.length < 10) {              // O(n) for small arrays
    return linearSearch(arr, target);
  }
  
  // If array is sorted, use binary search
  if (isSorted(arr)) {                // O(n) to check + O(log n) to search
    return binarySearch(arr, target);
  }
  
  // Otherwise, use linear search
  return linearSearch(arr, target);   // O(n)
}

/*
Analysis:
- isSorted check: O(n)
- Best case after check: O(log n)
- Worst case: O(n) + O(n) = O(n)

Overall: O(n) (worst case dominates)
*/
```

## Recursive Algorithm Analysis

### Master Method for Divide-and-Conquer

For recurrences of the form: **T(n) = aT(n/b) + f(n)**

Where:
- `a` = number of subproblems
- `n/b` = size of each subproblem  
- `f(n)` = cost of work outside recursion

### Binary Search Analysis

```javascript
function binarySearch(arr, target, left = 0, right = arr.length - 1) {
  if (left > right) return -1;               // Base case: O(1)
  
  const mid = Math.floor((left + right) / 2); // O(1)
  
  if (arr[mid] === target) return mid;       // O(1)
  
  if (arr[mid] < target) {
    return binarySearch(arr, target, mid + 1, right);  // T(n/2)
  } else {
    return binarySearch(arr, target, left, mid - 1);   // T(n/2)
  }
}

/*
Recurrence: T(n) = T(n/2) + O(1)
- a = 1 (one subproblem)
- b = 2 (problem size halved)
- f(n) = O(1) (constant work)

Solution: T(n) = O(log n)
*/
```

### Merge Sort Analysis

```javascript
function mergeSort(arr) {
  if (arr.length <= 1) return arr;           // Base case: O(1)
  
  const mid = Math.floor(arr.length / 2);
  const left = mergeSort(arr.slice(0, mid)); // T(n/2)
  const right = mergeSort(arr.slice(mid));   // T(n/2)
  
  return merge(left, right);                 // O(n)
}

/*
Recurrence: T(n) = 2T(n/2) + O(n)
- a = 2 (two subproblems)
- b = 2 (problem size halved)
- f(n) = O(n) (linear merge cost)

Solution: T(n) = O(n log n)
*/
```

### Fibonacci Analysis (Naive)

```javascript
function fibonacci(n) {
  if (n <= 1) return n;                    // Base case: O(1)
  return fibonacci(n - 1) + fibonacci(n - 2); // 2 recursive calls
}

/*
Recurrence: T(n) = T(n-1) + T(n-2) + O(1)

This creates a binary tree of height n:
- Each level roughly doubles the calls
- Total calls ≈ 2^n

Result: O(2^n) - exponential!
*/
```

## Advanced Analysis Rules

### Rule 1: Drop Constants

```javascript
// All of these are O(n)
function example1(arr) {
  for (let i = 0; i < arr.length; i++) { /* O(1) */ }
}

function example2(arr) {
  for (let i = 0; i < arr.length; i++) { /* O(1) */ }
  for (let i = 0; i < arr.length; i++) { /* O(1) */ }
}

function example3(arr) {
  for (let i = 0; i < arr.length; i += 2) { /* O(1) */ }
}
```

### Rule 2: Drop Lower-Order Terms

```javascript
function mixedComplexity(arr) {
  // O(n²) nested loops
  for (let i = 0; i < arr.length; i++) {
    for (let j = 0; j < arr.length; j++) {
      console.log(arr[i], arr[j]);
    }
  }
  
  // O(n) single loop
  for (let i = 0; i < arr.length; i++) {
    console.log(arr[i]);
  }
  
  // O(1) constant operation
  console.log("Done");
}

// Total: O(n²) + O(n) + O(1) = O(n²)
```

### Rule 3: Different Inputs = Different Variables

```javascript
function compareArrays(arr1, arr2) {
  for (let i = 0; i < arr1.length; i++) {     // O(m)
    for (let j = 0; j < arr2.length; j++) {   // O(n)
      if (arr1[i] === arr2[j]) {
        console.log("Match found");
      }
    }
  }
}

// This is O(m × n), NOT O(n²)!
// Different inputs need different variables
```

## Common Analysis Mistakes

### Mistake 1: Confusing Best and Worst Case

```javascript
function quicksort(arr) {
  // Best/Average case: O(n log n)
  // Worst case: O(n²) - already sorted array
  
  // Big O reports worst case: O(n²)
  // But average case performance matters too!
}
```

### Mistake 2: Ignoring Hidden Complexity

```javascript
function hasCommonElements(arr1, arr2) {
  for (let item1 of arr1) {              // O(n)
    if (arr2.includes(item1)) {          // includes() is O(m)!
      return true;
    }
  }
  return false;
}

// Total: O(n × m), not O(n)!
```

### Mistake 3: Recursive Space Complexity

```javascript
function factorial(n) {
  if (n <= 1) return 1;
  return n * factorial(n - 1);
}

/*
Time: O(n) - n recursive calls
Space: O(n) - call stack grows to depth n

Don't forget space complexity in recursive algorithms!
*/
```

## Practical Analysis Workflow

### Step 1: Identify the Input Size
```javascript
function processMatrix(matrix) {
  // Input size could be:
  // - Total elements: m × n
  // - Number of rows: m
  // - Number of columns: n
  // Choose based on the algorithm's behavior
}
```

### Step 2: Count Operations
```javascript
function example(arr) {
  let count = 0;
  
  // Count each operation type:
  for (let i = 0; i < arr.length; i++) {     // n iterations
    count++;                                 // 1 assignment per iteration
    if (arr[i] > 0) {                       // 1 comparison per iteration
      console.log(arr[i]);                  // 1 output per iteration (worst case)
    }
  }
  
  // Total: n × (1 + 1 + 1) = 3n = O(n)
}
```

### Step 3: Simplify Using Rules
```javascript
// Before simplification
function complex(arr) {
  // Phase 1: O(n)
  for (let i = 0; i < arr.length; i++) { /* ... */ }
  
  // Phase 2: O(n²)
  for (let i = 0; i < arr.length; i++) {
    for (let j = 0; j < arr.length; j++) { /* ... */ }
  }
  
  // Phase 3: O(log n)
  binarySearch(arr, target);
}

// After simplification: O(n) + O(n²) + O(log n) = O(n²)
```

## Key Takeaways

1. **Follow systematic steps**: input → operations → expression → simplification
2. **Count the dominant operation** in the innermost loop
3. **Consider all cases** but report the worst case for Big O
4. **Use different variables** for different inputs
5. **Don't ignore space complexity** in recursive algorithms
6. **Practice with real code** to build intuition

---

Ready to master space complexity? Next, we'll explore memory analysis and learn when space-time tradeoffs make sense.

### What's Next?

**Part 4: Space Complexity Deep Dive** - Memory analysis, auxiliary space calculations, and understanding space-time tradeoffs in algorithm design.
