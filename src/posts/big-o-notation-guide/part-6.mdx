# Practical Analysis Methods

Master the mathematical tools and systematic approaches that computer scientists use to analyze complex algorithms. These techniques will give you confidence to tackle any algorithm analysis challenge.

## The Master Theorem

The Master Theorem is a powerful tool for analyzing divide-and-conquer recurrences of the form:

**T(n) = aT(n/b) + f(n)**

Where:
- `a ≥ 1` = number of subproblems
- `b > 1` = factor by which subproblem size is reduced
- `f(n)` = work done outside the recursive calls

### Three Cases

Let **c = log_b(a)** (the critical exponent)

**Case 1**: If `f(n) = O(n^k)` where `k < c`, then `T(n) = Θ(n^c)`

**Case 2**: If `f(n) = O(n^c log^k n)` where `k ≥ 0`, then `T(n) = Θ(n^c log^(k+1) n)`

**Case 3**: If `f(n) = Ω(n^k)` where `k > c`, and `af(n/b) ≤ cf(n)` for some `c < 1`, then `T(n) = Θ(f(n))`

### Practical Applications

#### Binary Search
```javascript
function binarySearch(arr, target, left = 0, right = arr.length - 1) {
  if (left > right) return -1;
  
  const mid = Math.floor((left + right) / 2);
  
  if (arr[mid] === target) return mid;
  
  if (arr[mid] < target) {
    return binarySearch(arr, target, mid + 1, right);
  } else {
    return binarySearch(arr, target, left, mid - 1);
  }
}

/*
Recurrence: T(n) = T(n/2) + O(1)
- a = 1 (one subproblem)
- b = 2 (problem size halved)
- f(n) = O(1)
- c = log₂(1) = 0

Case comparison: f(n) = O(1) = O(n⁰), k = 0, c = 0
This is Case 2: k = c
Result: T(n) = Θ(n⁰ log n) = Θ(log n)
*/
```

#### Merge Sort
```javascript
function mergeSort(arr) {
  if (arr.length <= 1) return arr;
  
  const mid = Math.floor(arr.length / 2);
  const left = mergeSort(arr.slice(0, mid));    // T(n/2)
  const right = mergeSort(arr.slice(mid));      // T(n/2)
  
  return merge(left, right);                    // O(n)
}

/*
Recurrence: T(n) = 2T(n/2) + O(n)
- a = 2 (two subproblems)
- b = 2 (problem size halved)
- f(n) = O(n)
- c = log₂(2) = 1

Case comparison: f(n) = O(n¹), k = 1, c = 1
This is Case 2: k = c
Result: T(n) = Θ(n¹ log n) = Θ(n log n)
*/
```

#### Karatsuba Multiplication
```javascript
function karatsuba(x, y) {
  // Base case for small numbers
  if (x < 10 || y < 10) return x * y;
  
  const n = Math.max(x.toString().length, y.toString().length);
  const half = Math.floor(n / 2);
  
  const high1 = Math.floor(x / Math.pow(10, half));
  const low1 = x % Math.pow(10, half);
  const high2 = Math.floor(y / Math.pow(10, half));
  const low2 = y % Math.pow(10, half);
  
  // Three recursive multiplications instead of four
  const z0 = karatsuba(low1, low2);                    // T(n/2)
  const z1 = karatsuba((low1 + high1), (low2 + high2)); // T(n/2)
  const z2 = karatsuba(high1, high2);                   // T(n/2)
  
  return z2 * Math.pow(10, 2 * half) + 
         (z1 - z2 - z0) * Math.pow(10, half) + z0;     // O(n)
}

/*
Recurrence: T(n) = 3T(n/2) + O(n)
- a = 3 (three subproblems)
- b = 2 (problem size halved)
- f(n) = O(n)
- c = log₂(3) ≈ 1.585

Case comparison: f(n) = O(n¹), k = 1, c ≈ 1.585
Since k < c, this is Case 1
Result: T(n) = Θ(n^1.585)

This is faster than traditional O(n²) multiplication!
*/
```

### Master Theorem Limitations

```javascript
// Doesn't apply to: T(n) = 2T(n/2) + O(n log n)
function complexRecurrence(arr) {
  if (arr.length <= 1) return arr;
  
  const mid = Math.floor(arr.length / 2);
  const left = complexRecurrence(arr.slice(0, mid));
  const right = complexRecurrence(arr.slice(mid));
  
  return expensiveMerge(left, right); // O(n log n) work
}

/*
Can't use Master Theorem because f(n) = O(n log n)
doesn't fit any of the three cases cleanly.
Need other analysis techniques.
*/
```

## Recursion Trees

Recursion trees visualize the recursive call structure and help calculate total work.

### Building a Recursion Tree

#### Merge Sort Tree
```
                    T(n)                     Level 0: 1 × O(n) = O(n)
                   /    \
               T(n/2)   T(n/2)               Level 1: 2 × O(n/2) = O(n)
               /   \     /   \
           T(n/4) T(n/4) T(n/4) T(n/4)      Level 2: 4 × O(n/4) = O(n)
              ...                           ...
                                            Level log n: n × O(1) = O(n)

Total levels: log₂(n)
Work per level: O(n)
Total work: O(n log n)
```

#### Fibonacci Tree (Naive)
```
                    fib(n)
                   /      \
               fib(n-1)   fib(n-2)
               /    \      /     \
          fib(n-2) fib(n-3) fib(n-3) fib(n-4)
             ...

Height: n
Nodes at level k: approximately 2^k
Total nodes: approximately 2^n
Time complexity: O(2^n)
```

### Calculating Work with Trees

```javascript
function complexDivideConquer(arr, depth = 0) {
  if (arr.length <= 1) return arr;
  
  // Work at this level: O(n^1.5)
  preprocessing(arr); // O(n^1.5)
  
  const third = Math.floor(arr.length / 3);
  
  // Three recursive calls
  const part1 = complexDivideConquer(arr.slice(0, third), depth + 1);
  const part2 = complexDivideConquer(arr.slice(third, 2 * third), depth + 1);
  const part3 = complexDivideConquer(arr.slice(2 * third), depth + 1);
  
  return combine(part1, part2, part3); // O(n)
}

/*
Recursion tree analysis:
Level 0: 1 × O(n^1.5) = O(n^1.5)
Level 1: 3 × O((n/3)^1.5) = 3 × O(n^1.5/3^1.5) = O(n^1.5/√3)
Level 2: 9 × O((n/9)^1.5) = 9 × O(n^1.5/9^1.5) = O(n^1.5/3)
...

Geometric series with ratio 1/√3 < 1
Sum converges, dominated by first level
Total: O(n^1.5)
*/
```

## Advanced Loop Analysis

### Multiple Variables

```javascript
function complexLoops(n, m) {
  let operations = 0;
  
  for (let i = 1; i <= n; i *= 2) {      // O(log n) iterations
    for (let j = 0; j < m; j++) {        // O(m) iterations each
      for (let k = 0; k < i; k++) {      // O(i) iterations each
        operations++;                    // O(1)
      }
    }
  }
  
  return operations;
}

/*
Analysis:
i takes values: 1, 2, 4, 8, ..., up to n
For each i: m × i operations

Total: m × (1 + 2 + 4 + 8 + ... + n)
     = m × (2n - 1)  [geometric series]
     = O(mn)
*/
```

### Nested Loop with Dependencies

```javascript
function triangularLoop(n) {
  let operations = 0;
  
  for (let i = 0; i < n; i++) {
    for (let j = i; j < n; j++) {        // j starts at i
      for (let k = 0; k < j - i + 1; k++) { // k depends on i and j
        operations++;
      }
    }
  }
  
  return operations;
}

/*
Analysis by counting:
i = 0: j goes 0 to n-1, k goes 0 to (j-0+1) = 1+2+...+n = n(n+1)/2
i = 1: j goes 1 to n-1, k goes 0 to (j-1+1) = 1+2+...+(n-1) = (n-1)n/2
...

This is complex - use summation formulas:
Total ≈ Σ(i=0 to n-1) Σ(j=i to n-1) (j-i+1)
      = O(n³)
*/
```

## Amortized Analysis Techniques

### Accounting Method

Assign different "costs" to operations to balance expensive and cheap operations.

```javascript
class Stack {
  constructor() {
    this.items = [];
    this.size = 0;
  }
  
  push(item) {
    this.items[this.size] = item;
    this.size++;
    // Accounting cost: $3
    // Actual cost: $1 (store $2 credit)
  }
  
  pop() {
    if (this.size === 0) return null;
    const item = this.items[--this.size];
    // Accounting cost: $1
    // Actual cost: $1 (use stored credit if needed)
    return item;
  }
  
  multiPop(k) {
    const result = [];
    for (let i = 0; i < k && this.size > 0; i++) {
      result.push(this.pop());
      // Uses credits stored by previous pushes
    }
    return result;
  }
}

/*
Accounting analysis:
- Push: Pay $3, use $1, store $2
- Pop: Pay $1, use $1
- MultiPop: Uses stored credits

Amortized cost per operation: O(1)
*/
```

### Potential Method

Define a potential function that captures "stored energy" in the data structure.

```javascript
class DynamicArray {
  constructor() {
    this.data = new Array(1);
    this.size = 0;
    this.capacity = 1;
  }
  
  // Potential function: Φ(D) = 2 × size - capacity
  getPotential() {
    return 2 * this.size - this.capacity;
  }
  
  push(item) {
    const oldPotential = this.getPotential();
    
    if (this.size === this.capacity) {
      this.resize(); // Actual cost: O(n)
    }
    
    this.data[this.size++] = item; // Actual cost: O(1)
    
    const newPotential = this.getPotential();
    const potentialDiff = newPotential - oldPotential;
    
    // Amortized cost = Actual cost + Potential difference
    return { actualCost: this.size === 1 ? this.capacity : 1, 
             amortizedCost: 1 + potentialDiff };
  }
}

/*
Analysis:
- Before resize: Φ = 2n - n = n
- After resize: Φ = 2n - 2n = 0
- Potential decrease = n
- Actual resize cost = n
- Amortized cost = n - n = 0

Overall amortized cost per push: O(1)
*/
```

## Advanced Mathematical Techniques

### Solving Complex Recurrences

#### Substitution Method
```javascript
// Prove T(n) = O(n log n) for T(n) = 2T(n/2) + n

/*
Guess: T(n) ≤ c × n log n for some constant c

Inductive step:
T(n) = 2T(n/2) + n
     ≤ 2 × c × (n/2) × log(n/2) + n
     = c × n × log(n/2) + n
     = c × n × (log n - log 2) + n
     = c × n × log n - c × n + n
     = c × n × log n + n(1 - c)

For this to be ≤ c × n × log n, we need:
1 - c ≤ 0, so c ≥ 1

Therefore, T(n) = O(n log n) with c ≥ 1
*/
```

#### Characteristic Equation Method
```javascript
// For linear homogeneous recurrences like:
// T(n) = 5T(n-1) - 6T(n-2)

/*
Characteristic equation: r² - 5r + 6 = 0
Factoring: (r - 2)(r - 3) = 0
Roots: r₁ = 2, r₂ = 3

General solution: T(n) = A × 2ⁿ + B × 3ⁿ

Since 3ⁿ grows faster: T(n) = Θ(3ⁿ)
*/
```

### Generating Functions

```javascript
// Fibonacci generating function
function fibonacciGeneratingFunction() {
  /*
  F(x) = Σ(n=0 to ∞) fib(n) × xⁿ
  
  From recurrence fib(n) = fib(n-1) + fib(n-2):
  F(x) = x + x²F(x) + xF(x)
  F(x) = x / (1 - x - x²)
  
  Partial fractions and series expansion give:
  fib(n) = (φⁿ - ψⁿ) / √5
  
  Where φ = (1 + √5)/2 ≈ 1.618 (golden ratio)
        ψ = (1 - √5)/2 ≈ -0.618
  
  Since |ψ| < 1, for large n:
  fib(n) ≈ φⁿ / √5 = O(φⁿ) = O(1.618ⁿ)
  */
}
```

## Practical Analysis Workflow

### Step-by-Step Method

```javascript
function analyzeAlgorithm(code) {
  /*
  1. Identify the input size parameter(s)
  2. Set up recurrence relation or count operations
  3. Choose appropriate analysis technique:
     - Simple loops: Direct counting
     - Divide-and-conquer: Master theorem or recursion tree
     - Complex patterns: Amortized analysis
     - Linear recurrences: Characteristic equations
  4. Simplify using Big O rules
  5. Verify with small examples
  */
}
```

### Common Pitfalls and Solutions

```javascript
// Pitfall: Hidden complexity in library functions
function badAnalysis(arr) {
  const result = [];
  for (let item of arr) {
    result.push(...item.sort()); // sort() is O(k log k)!
  }
  return result;
}
// Actual complexity: O(n × k log k), not O(n)

// Pitfall: Ignoring best-case optimizations
function quicksort(arr) {
  // Worst case: O(n²) - sorted array
  // Average case: O(n log n) - random array
  // Best case: O(n log n) - optimal pivot
  
  // Report: O(n²) worst case, but mention average case
}
```

## Key Takeaways

1. **Master Theorem** handles most divide-and-conquer recurrences efficiently
2. **Recursion trees** provide intuitive visualization of recursive algorithms
3. **Advanced loop analysis** requires careful counting of nested dependencies
4. **Amortized analysis** reveals true cost over operation sequences
5. **Mathematical techniques** provide rigorous proofs for complex cases
6. **Systematic workflow** prevents analysis errors and oversights
7. **Consider hidden complexity** in library functions and nested calls

---

Next up: understanding when Big O doesn't tell the whole story and how to optimize for real-world performance.

### What's Next?

**Part 7: Real-World Performance** - When Big O isn't enough: constants, cache effects, and practical optimization strategies that matter in production systems.
