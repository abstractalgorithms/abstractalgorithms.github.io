## What Is Big O Notation?

At its core, Big O notation characterizes the worst-case scenario for an algorithm's growth rate. By focusing on dominant terms and discarding constants, developers can compare approaches objectively and identify potential bottlenecks.

### Key Time Complexities

| Complexity        | Description                                   | Example                          |
|-------------------|-----------------------------------------------|----------------------------------|
| O(1)              | Constant time, unaffected by input size       | Accessing an array element      |
| O(log n)          | Logarithmic time, halves the input each step  | Binary search in a sorted list |
| O(n)              | Linear time, scales directly with input size | Iterating through all items     |
| O(n log n)        | Linearithmic time, combination of n and log n | Efficient sorting algorithms    |
| O(nÂ²)             | Quadratic time, nested loops                  | Simple sorting, matrix ops      |

<img src="./assets/complexity-table.png" alt="Complexity chart" className="w-full my-6 rounded" />

## Practical Examples

### Linear Search â€” O(n)

```javascript
function linearSearch(arr, target) {
  for (let i = 0; i < arr.length; i++) {
    if (arr[i] === target) return i;
  }
  return -1;
}
```

> Linear search inspects each element sequentially, resulting in a linear growth of operations.

### Binary Search â€” O(log n)

```javascript
function binarySearch(arr, target) {
  let left = 0, right = arr.length - 1;
  while (left <= right) {
    const mid = Math.floor((left + right) / 2);
    if (arr[mid] === target) return mid;
    arr[mid] < target ? (left = mid + 1) : (right = mid - 1);
  }
  return -1;
}
```

> By halving the search space each iteration, binary search achieves logarithmic performance.

## Space Complexity

Algorithms also consume memory. Understanding space requirements helps avoid excessive resource usage, especially in constrained environments.

| Complexity | Memory Usage                             |
|------------|------------------------------------------|
| O(1)       | Fixed extra space (in-place algorithms)  |
| O(n)       | Linear extra space (e.g., data copies)   |
| O(nÂ²)      | Quadratic space (e.g., 2D structures)    |

## Best Practices

- Analyze worst-case scenarios for reliability.
- Simplify expressions by removing constants and lower-order terms.
- Balance theoretical analysis with empirical testing.

<blockquote className="italic">â€œPremature optimization is the root of all evil.â€ â€” Donald Knuth</blockquote>

By mastering Big O notation, developers can write code that not only works but performs efficiently at scale.
