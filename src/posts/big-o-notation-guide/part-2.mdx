# Common Time Complexities

Understanding the most frequent complexity classes is essential for algorithm analysis. Let's explore each one with practical examples, optimization techniques, and real-world applications.

## O(1) - Constant Time

**Definition**: Performance remains constant regardless of input size.

### Key Characteristics
- **Same execution time** for any input size
- **Most efficient** possible complexity
- **Direct access** operations

### Examples

```javascript
// Array element access
function getFirstElement(arr) {
  return arr[0]; // Always one operation
}

// Hash table operations
const userMap = new Map();
function getUser(id) {
  return userMap.get(id); // O(1) average case
}

// Mathematical operations
function isEven(n) {
  return n % 2 === 0; // Always constant time
}
```

### Real-World Applications
- Database primary key lookups
- Hash table operations
- Stack push/pop operations
- Array index access

> **Pro Tip**: Strive for O(1) operations in critical code paths. Hash tables and arrays with direct indexing are your best friends.

## O(log n) - Logarithmic Time

**Definition**: Divides the problem in half with each step.

### Key Characteristics
- **Extremely efficient** for large datasets
- **Divide-and-conquer** approach
- Growth rate slows as input increases

### Binary Search Example

```javascript
function binarySearch(sortedArr, target) {
  let left = 0;
  let right = sortedArr.length - 1;
  
  while (left <= right) {
    const mid = Math.floor((left + right) / 2);
    
    if (sortedArr[mid] === target) {
      return mid; // Found it!
    }
    
    if (sortedArr[mid] < target) {
      left = mid + 1; // Search right half
    } else {
      right = mid - 1; // Search left half
    }
  }
  
  return -1; // Not found
}

// Performance: 1 million items = ~20 comparisons max!
```

### Tree Operations

```javascript
// Binary search tree lookup
class BST {
  find(value, node = this.root) {
    if (!node) return null;
    
    if (value === node.value) return node;
    if (value < node.value) return this.find(value, node.left);
    return this.find(value, node.right);
  }
}
```

### Real-World Applications
- Binary search in sorted data
- Balanced tree operations
- Database B-tree indexes
- Logarithmic algorithms (merge sort's divide step)

## O(n) - Linear Time

**Definition**: Performance scales directly with input size.

### Key Characteristics
- **One pass** through the data
- **Proportional growth** to input size
- Often **unavoidable** when processing all data

### Examples

```javascript
// Linear search
function findElement(arr, target) {
  for (let i = 0; i < arr.length; i++) {
    if (arr[i] === target) return i;
  }
  return -1;
}

// Array sum
function calculateSum(numbers) {
  let sum = 0;
  for (let num of numbers) {
    sum += num; // Must visit each element
  }
  return sum;
}

// String operations
function countVowels(str) {
  let count = 0;
  const vowels = 'aeiouAEIOU';
  
  for (let char of str) {
    if (vowels.includes(char)) count++;
  }
  return count;
}
```

### Optimization Techniques

```javascript
// Bad: O(n) inside O(n) = O(n²)
function hasDuplicates(arr) {
  for (let i = 0; i < arr.length; i++) {
    for (let j = i + 1; j < arr.length; j++) {
      if (arr[i] === arr[j]) return true;
    }
  }
  return false;
}

// Better: O(n) using Set
function hasDuplicatesOptimized(arr) {
  const seen = new Set();
  for (let item of arr) {
    if (seen.has(item)) return true;
    seen.add(item);
  }
  return false;
}
```

## O(n log n) - Linearithmic Time

**Definition**: Combination of linear and logarithmic factors.

### Key Characteristics
- **Optimal** for comparison-based sorting
- **Divide-and-conquer** with linear work per level
- **Efficient** for large datasets

### Merge Sort Example

```javascript
function mergeSort(arr) {
  if (arr.length <= 1) return arr;
  
  // Divide: O(log n) levels
  const mid = Math.floor(arr.length / 2);
  const left = mergeSort(arr.slice(0, mid));
  const right = mergeSort(arr.slice(mid));
  
  // Conquer: O(n) work per level
  return merge(left, right);
}

function merge(left, right) {
  const result = [];
  let i = 0, j = 0;
  
  while (i < left.length && j < right.length) {
    if (left[i] <= right[j]) {
      result.push(left[i++]);
    } else {
      result.push(right[j++]);
    }
  }
  
  return result.concat(left.slice(i), right.slice(j));
}
```

### Real-World Applications
- Efficient sorting algorithms (merge sort, heap sort)
- Building balanced trees
- Fast Fourier Transform
- Closest pair problems

## O(n²) - Quadratic Time

**Definition**: Performance grows quadratically with input size.

### Key Characteristics
- **Nested loops** over the same dataset
- **Rapid performance degradation**
- Often indicates **optimization opportunity**

### Examples

```javascript
// Bubble sort
function bubbleSort(arr) {
  const n = arr.length;
  
  for (let i = 0; i < n - 1; i++) {      // Outer loop: n times
    for (let j = 0; j < n - i - 1; j++) { // Inner loop: n times
      if (arr[j] > arr[j + 1]) {
        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
      }
    }
  }
  return arr;
}

// Matrix multiplication
function multiplyMatrices(A, B) {
  const rows = A.length;
  const cols = B[0].length;
  const result = Array(rows).fill().map(() => Array(cols).fill(0));
  
  for (let i = 0; i < rows; i++) {
    for (let j = 0; j < cols; j++) {
      for (let k = 0; k < A[0].length; k++) {
        result[i][j] += A[i][k] * B[k][j];
      }
    }
  }
  return result;
}
```

### When O(n²) Is Acceptable

```javascript
// Small datasets (n < 50)
function insertionSort(arr) {
  for (let i = 1; i < arr.length; i++) {
    let current = arr[i];
    let j = i - 1;
    
    while (j >= 0 && arr[j] > current) {
      arr[j + 1] = arr[j];
      j--;
    }
    arr[j + 1] = current;
  }
  return arr;
}
```

## Performance Comparison

```javascript
// Performance test for different complexities
const sizes = [100, 1000, 10000];

sizes.forEach(n => {
  console.log(`Input size: ${n}`);
  console.log(`O(1):       1 operation`);
  console.log(`O(log n):   ${Math.ceil(Math.log2(n))} operations`);
  console.log(`O(n):       ${n} operations`);
  console.log(`O(n log n): ${Math.ceil(n * Math.log2(n))} operations`);
  console.log(`O(n²):      ${n * n} operations`);
  console.log('---');
});
```

## Optimization Strategies

### 1. Cache Results
```javascript
// Memoization for expensive O(n) operations
const cache = new Map();
function expensiveOperation(arr) {
  const key = arr.join(',');
  if (cache.has(key)) return cache.get(key);
  
  const result = arr.reduce((sum, num) => sum + num, 0);
  cache.set(key, result);
  return result;
}
```

### 2. Use Better Data Structures
```javascript
// O(n²) approach
function findIntersection(arr1, arr2) {
  const result = [];
  for (let item1 of arr1) {
    for (let item2 of arr2) {
      if (item1 === item2 && !result.includes(item1)) {
        result.push(item1);
      }
    }
  }
  return result;
}

// O(n) approach
function findIntersectionOptimized(arr1, arr2) {
  const set1 = new Set(arr1);
  const result = new Set();
  
  for (let item of arr2) {
    if (set1.has(item)) {
      result.add(item);
    }
  }
  return Array.from(result);
}
```

## Key Takeaways

1. **O(1) and O(log n)** scale excellently - prioritize these when possible
2. **O(n)** is often unavoidable but efficient for single-pass operations
3. **O(n log n)** is optimal for comparison-based sorting
4. **O(n²)** should be avoided for large datasets - look for optimization opportunities
5. **Choose algorithms** based on expected input size and performance requirements

---

Next up: **Algorithm Analysis Techniques** - Learn systematic methods for calculating complexity and master the rules that govern Big O analysis.

### What's Next?

**Part 3: Algorithm Analysis Techniques** - Step-by-step methods for calculating complexity, mathematical rules, and practical analysis strategies.
