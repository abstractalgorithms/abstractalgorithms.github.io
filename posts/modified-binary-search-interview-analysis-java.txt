3:I[4707,[],""]
5:I[36423,[],""]
6:I[84603,["4358","static/chunks/bc9e92e6-efe8e590a66d5f90.js","139","static/chunks/69806262-2f26cb68a64de63d.js","2972","static/chunks/2972-d93db4598907ce23.js","244","static/chunks/244-82cb246e390bd4ab.js","5973","static/chunks/5973-8e1d3ee0452991f9.js","5605","static/chunks/5605-ff89f570335e541e.js","993","static/chunks/993-c0a909a101b8ac62.js","3185","static/chunks/app/layout-aeb48df118a688fa.js"],"AuthProvider"]
7:I[85754,["4358","static/chunks/bc9e92e6-efe8e590a66d5f90.js","139","static/chunks/69806262-2f26cb68a64de63d.js","2972","static/chunks/2972-d93db4598907ce23.js","244","static/chunks/244-82cb246e390bd4ab.js","5973","static/chunks/5973-8e1d3ee0452991f9.js","5605","static/chunks/5605-ff89f570335e541e.js","993","static/chunks/993-c0a909a101b8ac62.js","3185","static/chunks/app/layout-aeb48df118a688fa.js"],"default"]
8:I[90688,["4358","static/chunks/bc9e92e6-efe8e590a66d5f90.js","139","static/chunks/69806262-2f26cb68a64de63d.js","2972","static/chunks/2972-d93db4598907ce23.js","244","static/chunks/244-82cb246e390bd4ab.js","5973","static/chunks/5973-8e1d3ee0452991f9.js","5605","static/chunks/5605-ff89f570335e541e.js","993","static/chunks/993-c0a909a101b8ac62.js","3185","static/chunks/app/layout-aeb48df118a688fa.js"],"default"]
9:I[66302,["2972","static/chunks/2972-d93db4598907ce23.js","7601","static/chunks/app/error-9da606d33a8d3ef9.js"],"default"]
a:I[75292,["2972","static/chunks/2972-d93db4598907ce23.js","9160","static/chunks/app/not-found-edac72d6e3280fcc.js"],"default"]
4:["slug","modified-binary-search-interview-analysis-java","d"]
0:["80WeAE6V92OTMbNZnMuvS",[[["",{"children":["posts",{"children":[["slug","modified-binary-search-interview-analysis-java","d"],{"children":["__PAGE__?{\"slug\":\"modified-binary-search-interview-analysis-java\"}",{}]}]}]},"$undefined","$undefined",true],["",{"children":["posts",{"children":[["slug","modified-binary-search-interview-analysis-java","d"],{"children":["__PAGE__",{},[["$L1","$L2",null],null],null]},[null,["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children","posts","children","$4","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined"}]],null]},[null,["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children","posts","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined"}]],null]},[[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/275ed64cc4367444.css","precedence":"next","crossOrigin":"$undefined"}],["$","link","1",{"rel":"stylesheet","href":"/_next/static/css/1db3e144610ce9c6.css","precedence":"next","crossOrigin":"$undefined"}]],["$","html",null,{"lang":"en","children":[["$","head",null,{"children":[["$","script",null,{"type":"application/ld+json","dangerouslySetInnerHTML":{"__html":"{\"@context\":\"https://schema.org\",\"@type\":\"WebSite\",\"name\":\"Abstract Algorithms\",\"description\":\"A comprehensive blog about algorithms, data structures, system design, and software engineering best practices\",\"url\":\"https://abstractalgorithms.github.io\",\"potentialAction\":{\"@type\":\"SearchAction\",\"target\":{\"@type\":\"EntryPoint\",\"urlTemplate\":\"https://abstractalgorithms.github.io/posts/{search_term_string}\"},\"query-input\":\"required name=search_term_string\"},\"publisher\":{\"@type\":\"Organization\",\"name\":\"Abstract Algorithms\",\"url\":\"https://abstractalgorithms.github.io\"}}"}}],["$","link",null,{"rel":"manifest","href":"/manifest.json"}],["$","meta",null,{"name":"theme-color","content":"#00D885"}],["$","link",null,{"rel":"icon","type":"image/png","sizes":"32x32","href":"/logo/header.png"}],["$","link",null,{"rel":"icon","type":"image/png","sizes":"16x16","href":"/logo/header.png"}],["$","link",null,{"rel":"apple-touch-icon","sizes":"180x180","href":"/logo/header.png"}],["$","meta",null,{"name":"google-site-verification","content":"D5v1M3nD8oO9DNaZKujCwBLNNqf35CTJo114uv8yMNU"}],["$","script",null,{"async":true,"src":"https://www.googletagmanager.com/gtag/js?id=G-VZR168MHE2"}],["$","script",null,{"dangerouslySetInnerHTML":{"__html":"\n            window.dataLayer = window.dataLayer || [];\n            function gtag(){dataLayer.push(arguments);}\n            gtag('js', new Date());\n            gtag('config', 'G-VZR168MHE2');\n          "}}]]}],["$","body",null,{"className":"__className_e8ce0c","children":["$","$L6",null,{"children":[["$","$L7",null,{}],["$","$L8",null,{"children":["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children"],"error":"$9","errorStyles":[],"errorScripts":[],"template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":["$","$La",null,{}],"notFoundStyles":[]}]}]]}]}]]}]],null],null],["$Lb",null]]]]
c:I[72972,["2972","static/chunks/2972-d93db4598907ce23.js","5878","static/chunks/5878-7524eb3ca8c56965.js","462","static/chunks/462-2612914b1a0c798c.js","333","static/chunks/app/posts/%5Bslug%5D/page-c5ee75ac2170c3bf.js"],""]
d:I[16743,["2972","static/chunks/2972-d93db4598907ce23.js","5878","static/chunks/5878-7524eb3ca8c56965.js","462","static/chunks/462-2612914b1a0c798c.js","333","static/chunks/app/posts/%5Bslug%5D/page-c5ee75ac2170c3bf.js"],"default"]
e:I[65878,["2972","static/chunks/2972-d93db4598907ce23.js","5878","static/chunks/5878-7524eb3ca8c56965.js","462","static/chunks/462-2612914b1a0c798c.js","333","static/chunks/app/posts/%5Bslug%5D/page-c5ee75ac2170c3bf.js"],"Image"]
f:I[43449,["2972","static/chunks/2972-d93db4598907ce23.js","5878","static/chunks/5878-7524eb3ca8c56965.js","462","static/chunks/462-2612914b1a0c798c.js","333","static/chunks/app/posts/%5Bslug%5D/page-c5ee75ac2170c3bf.js"],"default"]
10:I[20703,["2972","static/chunks/2972-d93db4598907ce23.js","5878","static/chunks/5878-7524eb3ca8c56965.js","462","static/chunks/462-2612914b1a0c798c.js","333","static/chunks/app/posts/%5Bslug%5D/page-c5ee75ac2170c3bf.js"],"default"]
11:I[87966,["2972","static/chunks/2972-d93db4598907ce23.js","5878","static/chunks/5878-7524eb3ca8c56965.js","462","static/chunks/462-2612914b1a0c798c.js","333","static/chunks/app/posts/%5Bslug%5D/page-c5ee75ac2170c3bf.js"],"default"]
18:I[79798,["2972","static/chunks/2972-d93db4598907ce23.js","5878","static/chunks/5878-7524eb3ca8c56965.js","462","static/chunks/462-2612914b1a0c798c.js","333","static/chunks/app/posts/%5Bslug%5D/page-c5ee75ac2170c3bf.js"],"default"]
12:T871,<blockquote>
<p><strong>TLDR:</strong> Backtracking is a recursive strategy for solving constraint satisfaction problems like permutations, combinations, and puzzles. This guide covers the core concept, example problems, and practical tips for Java interviews.</p>
</blockquote>
<p><strong>Navigation:</strong></p>
<ul>
<li><a href="#what-is-backtracking">What is Backtracking?</a></li>
<li><a href="#example-problem-permutations-of-array">Example Problem: Permutations of Array</a></li>
<li><a href="#interview-scenarios">Interview Scenarios</a></li>
<li><a href="#practice-problems">Practice Problems</a></li>
<li><a href="#key-takeaways">Key Takeaways</a></li>
</ul>
<h2>What is Backtracking?</h2>
<p>Backtracking is a recursive algorithm for solving constraint satisfaction problems by exploring all possible options and undoing choices when necessary.</p>
<p><strong>Why is it important for interviews?</strong></p>
<ul>
<li>Used in permutations, combinations, and puzzles.</li>
<li>Tests recursion and pruning skills.</li>
</ul>
<h2>Example Problem: Permutations of Array</h2>
<p><strong>Problem:</strong> Print all permutations of an array.</p>
<p><strong>Solution:</strong> Use recursion and swapping.</p>
<pre><code class="language-java">public static void permute(int[] arr, int l, int r) {
    if (l == r) {
        System.out.println(Arrays.toString(arr));
        return;
    }
    for (int i = l; i &#x3C;= r; i++) {
        swap(arr, l, i);
        permute(arr, l + 1, r);
        swap(arr, l, i); // backtrack
    }
}

private static void swap(int[] arr, int i, int j) {
    int temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}
</code></pre>
<h2>Interview Scenarios</h2>
<ul>
<li><strong>Combinations and Subsets</strong></li>
<li><strong>Sudoku Solver</strong></li>
<li><strong>N-Queens Problem</strong></li>
</ul>
<h2>Practice Problems</h2>
<ol>
<li>LeetCode 46. Permutations</li>
<li>LeetCode 77. Combinations</li>
<li>LeetCode 51. N-Queens</li>
</ol>
<h2>Key Takeaways</h2>
<ul>
<li>Backtracking is essential for constraint and search problems.</li>
<li>Practice with recursion and pruning for interviews.</li>
</ul>
13:T795,<blockquote>
<p><strong>TLDR:</strong> Binary tree traversal (inorder, preorder, postorder) is fundamental for tree problems and interviews. This guide covers the core concept, example problems, and practical tips for Java interviews.</p>
</blockquote>
<p><strong>Navigation:</strong></p>
<ul>
<li><a href="#what-is-binary-tree-traversal">What is Binary Tree Traversal?</a></li>
<li><a href="#example-problem-inorder-traversal">Example Problem: Inorder Traversal</a></li>
<li><a href="#interview-scenarios">Interview Scenarios</a></li>
<li><a href="#practice-problems">Practice Problems</a></li>
<li><a href="#key-takeaways">Key Takeaways</a></li>
</ul>
<h2>What is Binary Tree Traversal?</h2>
<p>Binary tree traversal is the process of visiting all nodes in a tree in a specific order: inorder, preorder, or postorder.</p>
<p><strong>Why is it important for interviews?</strong></p>
<ul>
<li>Appears in tree problems, serialization, and more.</li>
<li>Tests recursion and iterative skills.</li>
</ul>
<h2>Example Problem: Inorder Traversal</h2>
<p><strong>Problem:</strong> Print the inorder traversal of a binary tree.</p>
<p><strong>Solution:</strong> Use recursion or a stack.</p>
<pre><code class="language-java">public static void inorder(TreeNode root) {
    if (root == null) return;
    inorder(root.left);
    System.out.print(root.val + " ");
    inorder(root.right);
}
</code></pre>
<h2>Interview Scenarios</h2>
<ul>
<li><strong>Preorder Traversal</strong></li>
<li><strong>Postorder Traversal</strong></li>
<li><strong>Level Order Traversal</strong></li>
</ul>
<h2>Practice Problems</h2>
<ol>
<li>LeetCode 94. Binary Tree Inorder Traversal</li>
<li>LeetCode 144. Binary Tree Preorder Traversal</li>
<li>LeetCode 102. Binary Tree Level Order Traversal</li>
</ol>
<h2>Key Takeaways</h2>
<ul>
<li>Tree traversal is fundamental for tree problems.</li>
<li>Practice recursive and iterative approaches for interviews.</li>
</ul>
14:T154e,<p>import ResponsiveImage from '@/components/ResponsiveImage';</p>
<blockquote>
<p><strong>TLDR:</strong> Breadth-First Search (BFS) is a must-know for tree and graph interviews, used for shortest path, level order traversal, and connectivity. This guide covers the core concept, example problems, and practical tips for Java interviews.</p>
</blockquote>
<p><strong>Navigation:</strong></p>
<ul>
<li><a href="#what-is-breadth-first-search-bfs">What is Breadth-First Search (BFS)?</a></li>
<li><a href="#example-problem-bfs-in-binary-tree">Example Problem: BFS in Binary Tree</a></li>
<li><a href="#time--space-complexity">Time &#x26; Space Complexity</a></li>
<li><a href="#bfs-vs-dfs-quick-comparison">BFS vs DFS: Quick Comparison</a></li>
<li><a href="#interview-scenarios-with-analogies">Interview Scenarios (with Analogies)</a></li>
<li><a href="#interview-tips-what-recruiters-look-for">Interview Tips: What Recruiters Look For</a></li>
<li><a href="#practice-problems--algorithmic-patterns">Practice Problems &#x26; Algorithmic Patterns</a></li>
<li><a href="#key-takeaways">Key Takeaways</a></li>
</ul>
<h2>What is Breadth-First Search (BFS)?</h2>
<blockquote>
<p>Breadth-First Search (BFS) is like exploring a city block by block: you visit all your immediate neighbors before venturing further. In trees and graphs, BFS systematically explores nodes level by level, ensuring you reach every node in the shortest possible path.</p>
</blockquote>
<hr>
<h3></h3>
<p><em>Illustration: BFS traversal in a binary tree (level order)</em></p>
<h3></h3>
<p><em>Illustration: BFS traversal in a graph (shortest path)</em></p>
<hr>
<p><strong>Why is BFS a favorite in interviews?</strong></p>
<ul>
<li>Used for shortest path, level order traversal, and finding connected components.</li>
<li>Demonstrates your ability to use queues and iterative logic.</li>
<li>Shows you can break down problems into manageable steps.</li>
</ul>
<h2>Example Problem: BFS in Binary Tree</h2>
<p><strong>Problem:</strong> Print nodes level by level in a binary tree (level order traversal).</p>
<p><strong>Solution:</strong> Use a queue to keep track of nodes at each level.</p>
<pre><code class="language-java">public static void bfs(TreeNode root) {
    if (root == null) return; // Handle empty tree
    Queue&#x3C;TreeNode> queue = new LinkedList&#x3C;>(); // Queue for BFS
    queue.offer(root); // Start with root node
    while (!queue.isEmpty()) {
        TreeNode node = queue.poll(); // Remove node from queue
        System.out.print(node.val + " "); // Visit the node
        // Add left child to queue if it exists
        if (node.left != null) queue.offer(node.left);
        // Add right child to queue if it exists
        if (node.right != null) queue.offer(node.right);
    }
}
</code></pre>
<hr>
<h3>Time &#x26; Space Complexity</h3>
<ul>
<li><strong>Time Complexity:</strong> O(N), where N is the number of nodes (each node is visited once).</li>
<li><strong>Space Complexity:</strong> O(W), where W is the maximum width of the tree (max nodes at any level).</li>
</ul>
<hr>
<h2>BFS vs DFS: Quick Comparison</h2>
<table>
<thead>
<tr>
<th>Feature</th>
<th>BFS (Breadth-First Search)</th>
<th>DFS (Depth-First Search)</th>
</tr>
</thead>
<tbody>
<tr>
<td>Data Structure</td>
<td>Queue</td>
<td>Stack / Recursion</td>
</tr>
<tr>
<td>Traversal Order</td>
<td>Level by level</td>
<td>Depth before breadth</td>
</tr>
<tr>
<td>Finds Shortest Path?</td>
<td>Yes (unweighted graphs)</td>
<td>Not guaranteed</td>
</tr>
<tr>
<td>Memory Usage</td>
<td>Can be high (wide graphs)</td>
<td>Can be high (deep trees)</td>
</tr>
<tr>
<td>Use Cases</td>
<td>Shortest path, connectivity</td>
<td>Topological sort, cycles</td>
</tr>
</tbody>
</table>
<hr>
<h2>Interview Scenarios (with Analogies)</h2>
<ul>
<li><strong>Shortest Path in Graph</strong>: Like finding the quickest route in a subway system—BFS ensures you reach your destination in the fewest stops.</li>
<li><strong>Level Order Traversal</strong>: Imagine reading a book chapter by chapter, not skipping ahead—BFS processes each level before moving deeper.</li>
<li><strong>Connected Components</strong>: Like grouping friends at a party—BFS helps you find all people connected in a social network.</li>
</ul>
<hr>
<h2>Interview Tips: What Recruiters Look For</h2>
<ul>
<li>Can you clearly explain BFS and its intuition?</li>
<li>Do you choose the right data structure (queue) and handle edge cases?</li>
<li>Are your solutions scalable for large graphs or trees?</li>
<li>Can you compare BFS and DFS and pick the right one for the problem?</li>
<li>Do you write clean, well-commented code?</li>
<li>Can you relate BFS to real-world scenarios?</li>
</ul>
<hr>
<h2>Practice Problems &#x26; Algorithmic Patterns</h2>
<ol>
<li><strong>LeetCode 102. Binary Tree Level Order Traversal</strong><br>
<em>Pattern: Tree Traversal</em></li>
<li><strong>LeetCode 279. Perfect Squares</strong><br>
<em>Pattern: Shortest Path in Graph</em></li>
<li><strong>LeetCode 542. 01 Matrix</strong><br>
<em>Pattern: Multi-source BFS</em></li>
</ol>
<hr>
<h2>Key Takeaways</h2>
<ul>
<li>BFS is a must-know for tree and graph interviews—think level order, shortest path, and connectivity.</li>
<li>Use diagrams and analogies to explain your approach.</li>
<li>Practice writing clean, commented code and analyzing complexity.</li>
<li>Relate BFS to larger algorithmic patterns for deeper understanding.</li>
</ul>
15:T2fc1,<p>import ResponsiveImage from '@/components/ResponsiveImage';</p>
<h1>Depth-First Search (DFS): Interview Scenarios, Analysis, and Java Implementation</h1>
<blockquote>
<p><strong>Master DFS for Graphs and Trees: Java Code, Scenarios, and Interview Tips</strong></p>
</blockquote>
<blockquote>
<p><strong>TLDR:</strong> Ace your next interview with a deep understanding of Depth-First Search (DFS)! This guide covers what DFS is, how to implement it in Java (recursively and iteratively), cycle detection, complexity analysis, common variants, real-world use cases, and pro tips to impress interviewers.</p>
</blockquote>
<p><strong>Navigation:</strong></p>
<ul>
<li><a href="#what-is-dfs-">What is DFS? 🚀</a></li>
<li><a href="#dfs-vs-bfs-key-differences">DFS vs. BFS: Key Differences</a></li>
<li><a href="#what-interviewers-look-for-">What Interviewers Look For 👀</a></li>
<li><a href="#dfs-implementations-in-java-">DFS Implementations in Java 💻</a></li>
<li><a href="#cycle-detection-in-graphs-">Cycle Detection in Graphs 🔄</a></li>
<li><a href="#dfs-complexity-table-">DFS Complexity Table 📊</a></li>
<li><a href="#common-dfs-interview-variants-">Common DFS Interview Variants 🧩</a></li>
<li><a href="#real-world-use-cases--analogies-">Real-World Use Cases &#x26; Analogies 🌍</a></li>
<li><a href="#pro-tips-for-interviews-">Pro Tips for Interviews 💡</a></li>
<li><a href="#actionable-takeaways--next-steps">Actionable Takeaways &#x26; Next Steps</a></li>
</ul>
<h2>What is DFS? 🚀</h2>
<p>Depth-First Search (DFS) is a fundamental algorithm for traversing or searching tree and graph data structures. It explores as far as possible along each branch before backtracking, making it ideal for problems that require exhaustive search or path finding.</p>
<p><strong>Purpose:</strong></p>
<ul>
<li>Visit all nodes in a structure (tree/graph)</li>
<li>Find paths, connected components, cycles, and more</li>
</ul>
<blockquote>
<p><strong>Analogy:</strong> Imagine exploring a maze by always taking the next available path until you hit a dead end, then backtracking to try other options. That's DFS in action!</p>
</blockquote>
<hr>
<h2>DFS vs. BFS: Key Differences</h2>
<table>
<thead>
<tr>
<th>Feature</th>
<th>DFS (Depth-First Search)</th>
<th>BFS (Breadth-First Search)</th>
</tr>
</thead>
<tbody>
<tr>
<td>Traversal Order</td>
<td>Deepest nodes first (backtrack)</td>
<td>Nearest nodes first (level order)</td>
</tr>
<tr>
<td>Data Structure</td>
<td>Stack (explicit or recursion)</td>
<td>Queue</td>
</tr>
<tr>
<td>Space Complexity</td>
<td>O(h) for trees, O(V) for graphs</td>
<td>O(w) (max width)</td>
</tr>
<tr>
<td>Cycle Handling</td>
<td>Must track visited nodes</td>
<td>Must track visited nodes</td>
</tr>
<tr>
<td>Use Cases</td>
<td>Path finding, cycle detection,</td>
<td>Shortest path, level order,</td>
</tr>
<tr>
<td></td>
<td>topological sort, backtracking</td>
<td>connectivity, minimal hops</td>
</tr>
<tr>
<td>Performance</td>
<td>Can be memory efficient on trees</td>
<td>Can use more memory on wide trees</td>
</tr>
</tbody>
</table>
<hr>
<h2>What Interviewers Look For 👀</h2>
<ul>
<li>Can you explain DFS clearly and concisely?</li>
<li>Do you know both recursive and iterative approaches?</li>
<li>Can you handle edge cases (cycles, disconnected graphs)?</li>
<li>Do you understand time/space complexity?</li>
<li>Can you adapt DFS for variants (e.g., topological sort, backtracking)?</li>
</ul>
<hr>
<h2>DFS Implementations in Java 💻</h2>
<h3>1. Recursive DFS (Binary Tree)</h3>
<pre><code class="language-java">// Classic recursive DFS for binary tree
void dfs(TreeNode root) {
    // Base case: if the node is null, return (end of branch)
    if (root == null) return;
    // Visit the current node (pre-order)
    System.out.print(root.val + " ");
    // Traverse left subtree
    dfs(root.left);
    // Traverse right subtree
    dfs(root.right);
}
</code></pre>
<p><strong>Annotations:</strong></p>
<ul>
<li>Handles null nodes (edge case)</li>
<li>Pre-order traversal (visit node before children)</li>
<li>Recursion depth = tree height (risk of stack overflow for deep trees)</li>
</ul>
<h3>2. Iterative DFS (Graph, using Stack)</h3>
<pre><code class="language-java">// Iterative DFS for graph (adjacency list)
void dfsIterative(int start, List&#x3C;List&#x3C;Integer>> graph, boolean[] visited) {
    Stack&#x3C;Integer> stack = new Stack&#x3C;>();
    stack.push(start); // Start from the given node
    while (!stack.isEmpty()) {
        int node = stack.pop();
        if (!visited[node]) {
            visited[node] = true; // Mark as visited
            System.out.print(node + " "); // Process node
            // Add all unvisited neighbors to the stack
            for (int neighbor : graph.get(node)) {
                if (!visited[neighbor]) stack.push(neighbor);
            }
        }
    }
}
</code></pre>
<p><strong>Annotations:</strong></p>
<ul>
<li>Uses explicit stack to avoid recursion</li>
<li>Handles cycles and disconnected graphs (if called for each component)</li>
<li>Suitable for large/deep graphs (avoids stack overflow)</li>
</ul>
<hr>
<h2>Cycle Detection in Graphs 🔄</h2>
<p>Cycle detection is a classic DFS interview follow-up. For undirected graphs, track parent nodes. For directed graphs, use a recursion stack.</p>
<h3>Example: Cycle Detection in Directed Graph (Java)</h3>
<pre><code class="language-java">// Returns true if a cycle is detected starting from 'node'
boolean hasCycle(int node, List&#x3C;List&#x3C;Integer>> graph, boolean[] visited, boolean[] recStack) {
    if (recStack[node]) return true; // Node is in the current path (cycle found)
    if (visited[node]) return false; // Already checked, no cycle from here
    visited[node] = true;
    recStack[node] = true; // Add to recursion stack
    for (int neighbor : graph.get(node)) {
        if (hasCycle(neighbor, graph, visited, recStack)) return true;
    }
    recStack[node] = false; // Remove from recursion stack
    return false;
}
</code></pre>
<p><strong>Annotations:</strong></p>
<ul>
<li><code>recStack</code> tracks nodes in the current DFS path</li>
<li>Detects cycles in directed graphs (e.g., for dependency resolution)</li>
<li>For undirected graphs, track parent to avoid false positives</li>
</ul>
<hr>
<h2>DFS Complexity Table 📊</h2>
<table>
<thead>
<tr>
<th>Structure</th>
<th>Time Complexity</th>
<th>Space Complexity</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td>Tree (n nodes)</td>
<td>O(n)</td>
<td>O(h) (height)</td>
<td>h = height; stack depth = h</td>
</tr>
<tr>
<td>Graph (V,E)</td>
<td>O(V+E)</td>
<td>O(V)</td>
<td>V = vertices, E = edges</td>
</tr>
<tr>
<td>Dense Graph</td>
<td>O(V^2)</td>
<td>O(V)</td>
<td>Adjacency matrix, all nodes connected</td>
</tr>
<tr>
<td>Sparse Graph</td>
<td>O(V+E)</td>
<td>O(V)</td>
<td>Adjacency list, few edges</td>
</tr>
</tbody>
</table>
<p><strong>Performance Considerations:</strong></p>
<ul>
<li><strong>Stack Overflow:</strong> Recursive DFS can fail on very deep trees/graphs (use iterative for safety)</li>
<li><strong>Memory Usage:</strong> Iterative DFS uses explicit stack; both need O(V) space for visited tracking</li>
<li><strong>Graph Representation:</strong> Adjacency lists are more space-efficient for sparse graphs</li>
<li><strong>Disconnected Graphs:</strong> To visit all nodes, run DFS from every unvisited node</li>
</ul>
<hr>
<h2>Common DFS Interview Variants 🧩</h2>
<ul>
<li><strong>Topological Sort</strong> (DAGs)</li>
<li><strong>Backtracking</strong> (e.g., Sudoku, N-Queens)</li>
<li><strong>Connected Components</strong></li>
<li><strong>Path Finding</strong> (all paths, shortest/longest path)</li>
<li><strong>Cycle Detection</strong></li>
<li><strong>Flood Fill</strong></li>
</ul>
<blockquote>
<p><strong>Tip:</strong> Interviewers may ask you to adapt DFS for these variants. Practice writing modular code that can be easily extended.</p>
</blockquote>
<hr>
<h2>Real-World Use Cases &#x26; Analogies 🌍</h2>
<p>DFS is not just an academic concept—it's the backbone of many real-world systems and interview problems. Here are some practical scenarios and analogies:</p>
<ul>
<li>
<p><strong>Social Network Analysis:</strong></p>
<ul>
<li><em>Problem Statement:</em> Find all users connected to a given user (community detection).</li>
<li><em>Why DFS?</em> Like exploring a friend-of-a-friend network, DFS helps you exhaustively visit everyone in a social circle before moving to another.</li>
<li></li>
</ul>
</li>
<li>
<p><strong>Web Crawling:</strong></p>
<ul>
<li><em>Problem Statement:</em> Visit all pages reachable from a starting URL.</li>
<li><em>Why DFS?</em> Imagine following every link on a page as deep as possible before backtracking—DFS mimics this behavior, making it ideal for crawling deep site structures.</li>
<li></li>
</ul>
</li>
<li>
<p><strong>Maze Solving &#x26; Puzzle Games:</strong></p>
<ul>
<li><em>Problem Statement:</em> Find a path from entrance to exit in a maze.</li>
<li><em>Why DFS?</em> Like putting your hand on a wall and following it until you reach a dead end, then backtracking—DFS explores all possible paths.</li>
<li></li>
</ul>
</li>
<li>
<p><strong>Dependency Resolution (Build Systems, Package Managers):</strong></p>
<ul>
<li><em>Problem Statement:</em> Determine the order to build software modules or install packages with dependencies.</li>
<li><em>Why DFS?</em> DFS can be used for topological sorting, ensuring all dependencies are resolved before a module is built or installed.</li>
</ul>
</li>
<li>
<p><strong>Network Connectivity:</strong></p>
<ul>
<li><em>Problem Statement:</em> Check if all computers in a network are reachable from a given node.</li>
<li><em>Why DFS?</em> DFS traverses the network graph, ensuring every node is visited, which is crucial for connectivity checks and network reliability.</li>
</ul>
</li>
</ul>
<hr>
<h2>Pro Tips for Interviews 💡</h2>
<ul>
<li><strong>Clarify graph type:</strong> Ask if the graph is directed/undirected, cyclic/acyclic, connected/disconnected.</li>
<li><strong>Edge cases:</strong> Discuss null/empty inputs, self-loops, and multiple components.</li>
<li><strong>Iterative vs. recursive:</strong> Know both, and mention stack overflow risks in deep recursion.</li>
<li><strong>Explain your thought process:</strong> Use diagrams or dry runs if allowed.</li>
<li><strong>Practice coding on a whiteboard:</strong> Interviewers value clarity and structure.</li>
<li><strong>Use clear variable names and annotate your code.</strong></li>
<li><strong>Relate to real-world analogies when explaining.</strong></li>
</ul>
<hr>
<h2>Actionable Takeaways &#x26; Next Steps</h2>
<blockquote>
<p><strong>Summary:</strong>
DFS is a must-know for technical interviews. Master both recursive and iterative approaches, understand cycle detection, and be ready to adapt DFS for variants. Practice, explain clearly, and you'll stand out!</p>
</blockquote>
<p><strong>Practical Steps:</strong></p>
<ol>
<li><strong>Practice:</strong> Implement DFS recursively and iteratively for both trees and graphs.</li>
<li><strong>Edge Cases:</strong> Test your code on disconnected graphs, cycles, and large/deep structures.</li>
<li><strong>Variants:</strong> Try adapting DFS for topological sort, backtracking, and flood fill problems.</li>
<li><strong>Visualize:</strong> Draw diagrams for sample problems to solidify your understanding.</li>
<li><strong>Mock Interviews:</strong> Explain your approach out loud, annotate code, and use analogies.</li>
<li><strong>Further Reading:</strong>
<ul>
<li><a href="../breadth-first-search-bfs-interview-analysis-java">Breadth-First Search (BFS) Explained</a></li>
<li><a href="../topological-sort-dependency-resolution">Topological Sort and Dependency Resolution</a></li>
<li><a href="../backtracking-algorithms">Backtracking Algorithms</a></li>
<li><a href="../graph-theory-fundamentals">Graph Theory Fundamentals</a></li>
</ul>
</li>
</ol>
<p><strong>Project Ideas:</strong></p>
<ul>
<li>Build a simple web-based DFS visualizer</li>
<li>Implement a maze solver or web crawler using DFS</li>
<li>Analyze your own social network connections with DFS</li>
</ul>
16:T1b12,<blockquote>
<p><strong>TLDR:</strong> Dynamic Programming (DP) is a must-know technique for interviews. This guide covers what DP is, how to implement it in Java (memoization and tabulation), common pitfalls, complexity analysis, real-world use cases, and pro tips to impress interviewers.</p>
</blockquote>
<p><strong>Navigation:</strong></p>
<ul>
<li><a href="#what-is-dynamic-programming-dp-">What is Dynamic Programming (DP)? 🚀</a></li>
<li><a href="#what-interviewers-look-for-">What Interviewers Look For 👀</a></li>
<li><a href="#dp-implementations-in-java-">DP Implementations in Java 💻</a></li>
<li><a href="#common-pitfalls--advanced-tips-%EF%B8%8F">Common Pitfalls &#x26; Advanced Tips ⚠️</a></li>
<li><a href="#dp-complexity-table-">DP Complexity Table 📊</a></li>
<li><a href="#common-dp-interview-variants-">Common DP Interview Variants 🧩</a></li>
<li><a href="#real-world-use-cases--problem-statements-">Real-World Use Cases &#x26; Problem Statements 🌍</a></li>
<li><a href="#pro-tips-for-interviews-">Pro Tips for Interviews 💡</a></li>
</ul>
<h2>What is Dynamic Programming (DP)? 🚀</h2>
<p>Dynamic Programming (DP) is an optimization technique for solving complex problems by breaking them into overlapping subproblems, solving each just once, and storing their solutions. DP is ideal for problems with optimal substructure and overlapping subproblems.</p>
<p><strong>Purpose:</strong></p>
<ul>
<li>Avoid redundant computation by storing results</li>
<li>Solve problems efficiently that would otherwise have exponential time complexity</li>
</ul>
<hr>
<h2>What Interviewers Look For 👀</h2>
<ul>
<li>Can you identify if a problem can be solved with DP?</li>
<li>Do you understand recursion, memoization (top-down), and tabulation (bottom-up)?</li>
<li>Can you explain optimal substructure and overlapping subproblems?</li>
<li>Do you know how to analyze time and space complexity?</li>
<li>Can you optimize space or reconstruct solutions?</li>
</ul>
<hr>
<h2>DP Implementations in Java 💻</h2>
<h3>1. Memoization (Top-Down)</h3>
<pre><code class="language-java">// Fibonacci with memoization (top-down DP)
int fibMemo(int n, Map&#x3C;Integer, Integer> memo) {
    if (n &#x3C;= 1) return n;
    if (memo.containsKey(n)) return memo.get(n);
    int result = fibMemo(n - 1, memo) + fibMemo(n - 2, memo);
    memo.put(n, result);
    return result;
}
// Usage: fibMemo(n, new HashMap&#x3C;>())
</code></pre>
<h3>2. Tabulation (Bottom-Up)</h3>
<pre><code class="language-java">// Fibonacci with tabulation (bottom-up DP)
int fibTab(int n) {
    if (n &#x3C;= 1) return n;
    int[] dp = new int[n + 1];
    dp[0] = 0; dp[1] = 1;
    for (int i = 2; i &#x3C;= n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2];
    }
    return dp[n];
}
</code></pre>
<hr>
<h2>Common Pitfalls &#x26; Advanced Tips ⚠️</h2>
<ul>
<li><strong>Space Optimization:</strong> Many DP problems can be optimized to use less space (e.g., Fibonacci can use two variables instead of an array).</li>
<li><strong>Reconstructing Solutions:</strong> For path problems, store extra info (like parent pointers) to reconstruct the actual solution, not just its value.</li>
<li><strong>Initialization Errors:</strong> Always initialize your DP array or memo table correctly.</li>
<li><strong>Off-by-One Mistakes:</strong> Be careful with array indices, especially in tabulation.</li>
</ul>
<h3>Example: Space-Optimized Fibonacci</h3>
<pre><code class="language-java">// Space-optimized Fibonacci
int fibOpt(int n) {
    if (n &#x3C;= 1) return n;
    int prev2 = 0, prev1 = 1;
    for (int i = 2; i &#x3C;= n; i++) {
        int curr = prev1 + prev2;
        prev2 = prev1;
        prev1 = curr;
    }
    return prev1;
}
</code></pre>
<hr>
<h2>DP Complexity Table 📊</h2>
<table>
<thead>
<tr>
<th>Problem</th>
<th>Time Complexity</th>
<th>Space Complexity</th>
</tr>
</thead>
<tbody>
<tr>
<td>Fibonacci (DP)</td>
<td>O(n)</td>
<td>O(n) / O(1)*</td>
</tr>
<tr>
<td>0/1 Knapsack</td>
<td>O(nW)</td>
<td>O(nW)</td>
</tr>
<tr>
<td>Longest Inc. Subseq.</td>
<td>O(n^2)</td>
<td>O(n)</td>
</tr>
<tr>
<td>Edit Distance</td>
<td>O(mn)</td>
<td>O(mn)</td>
</tr>
</tbody>
</table>
<p>*O(1) space for space-optimized Fibonacci</p>
<hr>
<h2>Common DP Interview Variants 🧩</h2>
<ul>
<li><strong>0/1 Knapsack Problem</strong></li>
<li><strong>Longest Increasing Subsequence</strong></li>
<li><strong>Coin Change</strong></li>
<li><strong>Edit Distance</strong></li>
<li><strong>Climbing Stairs</strong></li>
<li><strong>Grid Unique Paths</strong></li>
<li><strong>Palindrome Partitioning</strong></li>
</ul>
<hr>
<h2>Real-World Use Cases &#x26; Problem Statements 🌍</h2>
<p>DP is everywhere in real-world systems and interview questions. Here are some practical scenarios and analogies:</p>
<ul>
<li>
<p><strong>Resource Allocation (Knapsack):</strong></p>
<ul>
<li><em>Problem Statement:</em> Maximize value with limited resources (e.g., packing a bag, budgeting).</li>
<li><em>Why DP?</em> Like packing a suitcase for a trip, DP helps you make optimal choices by considering all combinations efficiently.</li>
</ul>
</li>
<li>
<p><strong>Spell Checkers &#x26; DNA Alignment (Edit Distance):</strong></p>
<ul>
<li><em>Problem Statement:</em> Find the minimum number of edits to convert one string to another.</li>
<li><em>Why DP?</em> Like transforming one word into another by changing, adding, or removing letters, DP efficiently finds the shortest path of edits.</li>
</ul>
</li>
<li>
<p><strong>Stock Trading (Max Profit):</strong></p>
<ul>
<li><em>Problem Statement:</em> Maximize profit from buying and selling stocks with constraints.</li>
<li><em>Why DP?</em> DP tracks the best choices at each step, like planning when to buy/sell for maximum gain.</li>
</ul>
</li>
<li>
<p><strong>Route Planning (Grid Paths):</strong></p>
<ul>
<li><em>Problem Statement:</em> Count the number of ways to reach a destination in a grid.</li>
<li><em>Why DP?</em> Like navigating a city with blocks, DP counts all possible routes by building up from smaller subproblems.</li>
</ul>
</li>
</ul>
<hr>
<h2>Pro Tips for Interviews 💡</h2>
<ul>
<li><strong>Clarify constraints:</strong> Ask about input size, negative numbers, and edge cases.</li>
<li><strong>Draw subproblem relationships:</strong> Visualize the DP table or recursion tree.</li>
<li><strong>Explain your approach:</strong> Walk through a small example out loud.</li>
<li><strong>Know when to use memoization vs. tabulation:</strong> Some problems are easier one way or the other.</li>
<li><strong>Practice coding both styles:</strong> Interviewers may ask for either.</li>
</ul>
<hr>
<p><strong>Summary:</strong>
Dynamic Programming is a cornerstone of technical interviews. Master both memoization and tabulation, understand common pitfalls, and practice real-world problems. Clear explanations and structured thinking will set you apart!</p>
17:T1c97,<blockquote>
<p><strong>TLDR:</strong> Fast &#x26; Slow Pointers (Floyd’s Tortoise and Hare) are a must-know technique for interviews. This guide covers what they are, how to use them in Java, common pitfalls, complexity analysis, real-world use cases, and pro tips to impress interviewers.</p>
</blockquote>
<p><strong>Navigation:</strong></p>
<ul>
<li><a href="#what-are-fast--slow-pointers-">What are Fast &#x26; Slow Pointers? 🚀</a></li>
<li><a href="#what-interviewers-look-for-">What Interviewers Look For 👀</a></li>
<li><a href="#classic-implementations-in-java-">Classic Implementations in Java 💻</a></li>
<li><a href="#common-pitfalls--advanced-tips-%EF%B8%8F">Common Pitfalls &#x26; Advanced Tips ⚠️</a></li>
<li><a href="#complexity-table-">Complexity Table 📊</a></li>
<li><a href="#common-interview-variants-">Common Interview Variants 🧩</a></li>
<li><a href="#real-world-use-cases--problem-statements-">Real-World Use Cases &#x26; Problem Statements 🌍</a></li>
<li><a href="#pro-tips-for-interviews-">Pro Tips for Interviews 💡</a></li>
</ul>
<h2>What are Fast &#x26; Slow Pointers? 🚀</h2>
<p>Fast &#x26; Slow Pointers (Floyd’s Tortoise and Hare) is a two-pointer technique used to solve linked list and array problems efficiently. The idea is to move one pointer faster than the other to detect cycles, find the middle, or solve other problems in linear time and constant space.</p>
<p><strong>Purpose:</strong></p>
<ul>
<li>Detect cycles in linked lists or arrays</li>
<li>Find the middle of a linked list</li>
<li>Check for palindromes in linked lists</li>
</ul>
<hr>
<h2>What Interviewers Look For 👀</h2>
<ul>
<li>Can you explain the intuition behind fast &#x26; slow pointers?</li>
<li>Do you know how to implement cycle detection, find the middle, and other variants?</li>
<li>Can you handle edge cases (empty list, single node, even/odd length)?</li>
<li>Do you understand time and space complexity?</li>
<li>Can you adapt the technique to new problems?</li>
</ul>
<hr>
<h2>Classic Implementations in Java 💻</h2>
<h3>1. Detect Cycle in Linked List</h3>
<pre><code class="language-java">// Floyd's Tortoise and Hare: Detect cycle
boolean hasCycle(ListNode head) {
    ListNode slow = head, fast = head;
    while (fast != null &#x26;&#x26; fast.next != null) {
        slow = slow.next;
        fast = fast.next.next;
        if (slow == fast) return true;
    }
    return false;
}
</code></pre>
<h3>2. Find Middle of Linked List</h3>
<pre><code class="language-java">// Find the middle node
ListNode findMiddle(ListNode head) {
    ListNode slow = head, fast = head;
    while (fast != null &#x26;&#x26; fast.next != null) {
        slow = slow.next;
        fast = fast.next.next;
    }
    return slow;
}
</code></pre>
<h3>3. Check if Linked List is Palindrome</h3>
<pre><code class="language-java">// Check if linked list is palindrome
boolean isPalindrome(ListNode head) {
    if (head == null || head.next == null) return true;
    // Find middle
    ListNode slow = head, fast = head;
    while (fast != null &#x26;&#x26; fast.next != null) {
        slow = slow.next;
        fast = fast.next.next;
    }
    // Reverse second half
    ListNode prev = null;
    while (slow != null) {
        ListNode next = slow.next;
        slow.next = prev;
        prev = slow;
        slow = next;
    }
    // Compare halves
    ListNode left = head, right = prev;
    while (right != null) {
        if (left.val != right.val) return false;
        left = left.next;
        right = right.next;
    }
    return true;
}
</code></pre>
<hr>
<h2>Common Pitfalls &#x26; Advanced Tips ⚠️</h2>
<ul>
<li><strong>Finding the Start of Cycle:</strong> After detecting a cycle, reset one pointer to head and move both one step at a time to find the cycle's entry point.</li>
<li><strong>Edge Cases:</strong> Always check for null pointers and single-node lists.</li>
<li><strong>Even vs. Odd Length:</strong> Be careful when finding the middle in even-length lists.</li>
</ul>
<h3>Example: Find Start of Cycle</h3>
<pre><code class="language-java">// Find the node where the cycle begins
ListNode detectCycle(ListNode head) {
    ListNode slow = head, fast = head;
    while (fast != null &#x26;&#x26; fast.next != null) {
        slow = slow.next;
        fast = fast.next.next;
        if (slow == fast) {
            slow = head;
            while (slow != fast) {
                slow = slow.next;
                fast = fast.next;
            }
            return slow;
        }
    }
    return null;
}
</code></pre>
<hr>
<h2>Complexity Table 📊</h2>
<table>
<thead>
<tr>
<th>Problem</th>
<th>Time Complexity</th>
<th>Space Complexity</th>
</tr>
</thead>
<tbody>
<tr>
<td>Detect Cycle in Linked List</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>Find Middle of Linked List</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>Palindrome Linked List</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>Find Start of Cycle</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
</tbody>
</table>
<hr>
<h2>Common Interview Variants 🧩</h2>
<ul>
<li><strong>Linked List Cycle Detection</strong></li>
<li><strong>Find Middle of Linked List</strong></li>
<li><strong>Palindrome Linked List</strong></li>
<li><strong>Find Start of Cycle</strong></li>
<li><strong>Happy Number (Cycle in Digits)</strong></li>
<li><strong>Circular Array Loop</strong></li>
</ul>
<hr>
<h2>Real-World Use Cases &#x26; Problem Statements 🌍</h2>
<p>Fast &#x26; slow pointers are not just for interviews—they solve real problems! Here are some scenarios and analogies:</p>
<ul>
<li>
<p><strong>Network Packet Routing:</strong></p>
<ul>
<li><em>Problem Statement:</em> Detect loops in network routing tables.</li>
<li><em>Why Fast &#x26; Slow?</em> Like two cars driving at different speeds on a circular track—if there's a loop, they'll eventually meet.</li>
</ul>
</li>
<li>
<p><strong>Music Playlist Loops:</strong></p>
<ul>
<li><em>Problem Statement:</em> Detect if a playlist repeats songs in a cycle.</li>
<li><em>Why Fast &#x26; Slow?</em> Like two friends skipping through a playlist at different speeds—if they land on the same song, there's a cycle.</li>
</ul>
</li>
<li>
<p><strong>DNA Sequence Analysis:</strong></p>
<ul>
<li><em>Problem Statement:</em> Detect repeating patterns in DNA sequences.</li>
<li><em>Why Fast &#x26; Slow?</em> Like two readers moving through a book at different speeds—if they meet, a pattern repeats.</li>
</ul>
</li>
</ul>
<hr>
<h2>Pro Tips for Interviews 💡</h2>
<ul>
<li><strong>Clarify constraints:</strong> Ask about list length, possible cycles, and value ranges.</li>
<li><strong>Draw pointer movement:</strong> Visualize how fast and slow pointers move.</li>
<li><strong>Explain your approach:</strong> Walk through a small example out loud.</li>
<li><strong>Handle edge cases:</strong> Always check for nulls and single-node lists.</li>
<li><strong>Practice coding pointer logic:</strong> Interviewers value clarity and pointer safety.</li>
</ul>
<hr>
<p><strong>Summary:</strong>
Fast &#x26; Slow Pointers are a staple of technical interviews. Master the classic patterns, understand edge cases, and practice explaining your logic. Clear thinking and pointer safety will set you apart!</p>
2:["$","article",null,{"className":"min-h-screen bg-gradient-to-br from-slate-50 via-white to-emerald-50 relative","children":[["$","div",null,{"className":"bg-white/90 backdrop-blur-sm border-b border-emerald-100 shadow-sm","children":["$","div",null,{"className":"bg-white","children":["$","div",null,{"className":"max-w-4xl mx-auto px-6 py-8","children":[["$","nav",null,{"className":"flex items-center space-x-2 text-sm text-gray-600 mb-8","children":[["$","$Lc",null,{"href":"/","className":"hover:text-gray-900 transition-colors","children":"Home"}],["$","svg",null,{"xmlns":"http://www.w3.org/2000/svg","width":24,"height":24,"viewBox":"0 0 24 24","fill":"none","stroke":"currentColor","strokeWidth":2,"strokeLinecap":"round","strokeLinejoin":"round","className":"lucide lucide-chevron-right w-4 h-4","children":[["$","path","mthhwq",{"d":"m9 18 6-6-6-6"}],"$undefined"]}],["$","$Lc",null,{"href":"/posts","className":"hover:text-gray-900 transition-colors","children":"Blog"}],["$","svg",null,{"xmlns":"http://www.w3.org/2000/svg","width":24,"height":24,"viewBox":"0 0 24 24","fill":"none","stroke":"currentColor","strokeWidth":2,"strokeLinecap":"round","strokeLinejoin":"round","className":"lucide lucide-chevron-right w-4 h-4","children":[["$","path","mthhwq",{"d":"m9 18 6-6-6-6"}],"$undefined"]}],["$","$Lc",null,{"href":"/posts?category=binary-search","className":"hover:text-gray-900 transition-colors","children":"Binary Search"}],["$","svg",null,{"xmlns":"http://www.w3.org/2000/svg","width":24,"height":24,"viewBox":"0 0 24 24","fill":"none","stroke":"currentColor","strokeWidth":2,"strokeLinecap":"round","strokeLinejoin":"round","className":"lucide lucide-chevron-right w-4 h-4","children":[["$","path","mthhwq",{"d":"m9 18 6-6-6-6"}],"$undefined"]}],["$","span",null,{"className":"text-gray-900 font-medium","children":"Modified Binary Search: Interview Scenarios, Analysis, and Java Implementation"}]]}],["$","h1",null,{"className":"text-4xl md:text-5xl font-bold text-gray-900 mb-6 leading-tight","children":"Modified Binary Search: Interview Scenarios, Analysis, and Java Implementation"}],["$","div",null,{"className":"flex items-center space-x-6 text-gray-600 mb-8 flex-wrap","children":[["$","div",null,{"className":"flex items-center space-x-2","children":["$","span",null,{"children":["By ","Abstract Algorithms"]}]}],["$","div",null,{"className":"flex items-center space-x-2","children":["$","span",null,{"children":"Jul 16, 2025"}]}],["$","div",null,{"className":"flex items-center space-x-2","children":["$","span",null,{"children":"5 min read"}]}],["$","$Ld",null,{"id":"9l8m1h4i-5j6k-9g7f-4h8i-9j0k1l2m3n4o","size":"md","showTrending":true}]]}],["$","div",null,{"className":"mb-8","children":["$","div",null,{"className":"relative aspect-[16/9] rounded-xl overflow-hidden","children":["$","$Le",null,{"src":"/posts/modified-binary-search-interview-analysis-java/assets/overview-600x400.jpg","alt":"Modified Binary Search: Interview Scenarios, Analysis, and Java Implementation","fill":true,"className":"object-cover","priority":true}]}]}]]}]}]}],["$","div",null,{"className":"max-w-5xl mx-auto px-6 py-12","children":[["$","div",null,{"className":"bg-white/90 backdrop-blur-sm rounded-2xl border border-slate-200/50 shadow-xl shadow-slate-100/50 overflow-hidden","children":["$","div",null,{"className":"p-8 lg:p-12","children":["$","$Lf",null,{"slug":"modified-binary-search-interview-analysis-java"}]}]}],["$","div",null,{"className":"mt-12","children":["$","$L10",null,{"url":"https://abstractalgorithms.github.io/posts/modified-binary-search-interview-analysis-java","title":"Modified Binary Search: Interview Scenarios, Analysis, and Java Implementation","description":"Master modified binary search for rotated arrays and advanced search problems. Java code, scenarios, and interview tips.","image":"https://abstractalgorithms.github.io/posts/modified-binary-search-interview-analysis-java/assets/overview-600x400.jpg"}]}],["$","div",null,{"className":"mt-16","children":[["$","h2",null,{"className":"text-3xl font-bold text-slate-900 mb-8 text-center","children":"Related Articles"}],["$","$L11",null,{"posts":[{"slug":"backtracking-interview-analysis-java","id":"4q3r6m9n-0o1p-4l2k-9m3n-4o5p6q7r8s9t","title":"Backtracking: Interview Scenarios, Analysis, and Java Implementation","date":"2025-07-16","excerpt":"Master backtracking for permutations, combinations, and constraint problems. Java code, scenarios, and interview tips.","content":"$12","author":"Abstract Algorithms","tags":["backtracking","algorithms","interview-prep","java"],"categories":[],"readingTime":"2 min read","coverImage":"/posts/backtracking-interview-analysis-java/assets/overview-600x400.jpg","status":"published","type":"post"},{"slug":"binary-tree-traversal-interview-analysis-java","id":"0m9n2i5j-6k7l-0h8g-5i9j-0k1l2m3n4o5p","title":"Binary Tree Traversal: Interview Scenarios, Analysis, and Java Implementation","date":"2025-07-16","excerpt":"Master binary tree traversal (inorder, preorder, postorder) for interviews. Java code, scenarios, and tips.","content":"$13","author":"Abstract Algorithms","tags":["binary-tree","traversal","algorithms","interview-prep","java"],"categories":[],"readingTime":"1 min read","coverImage":"/posts/binary-tree-traversal-interview-analysis-java/assets/overview-600x400.jpg","status":"published","type":"post"},{"slug":"breadth-first-search-bfs-interview-analysis-java","id":"2o1p4k7l-8m9n-2j0i-7k1l-2m3n4o5p6q7r","title":"Breadth-First Search (BFS): Interview Scenarios, Analysis, and Java Implementation","date":"2025-07-16","excerpt":"Master BFS for graphs and trees. Java code, scenarios, and interview tips for technical interviews.","content":"$14","author":"Abstract Algorithms","tags":["bfs","graph","algorithms","interview-prep","java"],"categories":[],"readingTime":"4 min read","coverImage":"/posts/breadth-first-search-bfs-interview-analysis-java/assets/overview-600x400.jpg","status":"published","type":"post"},{"slug":"depth-first-search-dfs-interview-analysis-java","id":"1n0o3j6k-7l8m-1i9h-6j0k-1l2m3n4o5p6q","title":"Depth-First Search (DFS): Interview Scenarios, Analysis, and Java Implementation","date":"2025-07-16","excerpt":"Master DFS for graphs and trees. Java code, scenarios, and interview tips for technical interviews.","content":"$15","author":"Abstract Algorithms","tags":["dfs","graph","algorithms","interview-prep","java"],"categories":[],"readingTime":"8 min read","coverImage":"/posts/depth-first-search-dfs-interview-analysis-java/assets/overview-600x400.jpg","status":"published","type":"post"},{"slug":"dynamic-programming-patterns-interview-analysis-java","id":"5r4s7n0o-1p2q-5m3l-0n4o-5p6q7r8s9t0u","title":"Dynamic Programming Patterns: Interview Scenarios, Analysis, and Java Implementation","date":"2025-07-16","excerpt":"Master dynamic programming patterns for optimal solutions. Java code, scenarios, and interview tips for technical interviews.","content":"$16","author":"Abstract Algorithms","tags":["dynamic-programming","algorithms","interview-prep","java"],"categories":[],"readingTime":"5 min read","coverImage":"/posts/dynamic-programming-patterns-interview-analysis-java/assets/overview-600x400.jpg","status":"published","type":"post"},{"slug":"fast-slow-pointers-interview-analysis-java","id":"4g3h6c9d-0e1f-4b2a-9c3d-4e5f6g7h8i9j","title":"Fast & Slow Pointers: Interview Scenarios, Analysis, and Java Implementation","date":"2025-07-16","excerpt":"Master fast & slow pointers for cycle detection and linked list problems. Ace interviews with Java examples and tips.","content":"$17","author":"Abstract Algorithms","tags":["fast-slow-pointers","algorithms","interview-prep","java"],"categories":[],"readingTime":"5 min read","coverImage":"/posts/fast-slow-pointers-interview-analysis-java/assets/overview-600x400.jpg","status":"published","type":"post"}]}]]}],["$","div",null,{"className":"mt-16","children":["$","div",null,{"className":"bg-white/80 backdrop-blur-sm rounded-2xl p-8 border border-slate-200/50 shadow-lg shadow-slate-100/30","children":[["$","h3",null,{"className":"text-2xl font-bold text-slate-900 mb-6","children":"Discussion"}],["$","$L18",null,{}]]}]}]]}],["$","script",null,{"type":"application/ld+json","dangerouslySetInnerHTML":{"__html":"{\"@context\":\"https://schema.org\",\"@type\":\"BlogPosting\",\"headline\":\"Modified Binary Search: Interview Scenarios, Analysis, and Java Implementation\",\"description\":\"Master modified binary search for rotated arrays and advanced search problems. Java code, scenarios, and interview tips.\",\"datePublished\":\"2025-07-16\",\"dateModified\":\"2025-07-16\",\"author\":{\"@type\":\"Person\",\"name\":\"Abstract Algorithms\"},\"publisher\":{\"@type\":\"Organization\",\"name\":\"Abstract Algorithms\",\"url\":\"https://abstractalgorithms.github.io\"},\"url\":\"https://abstractalgorithms.github.io/posts/modified-binary-search-interview-analysis-java\",\"mainEntityOfPage\":{\"@type\":\"WebPage\",\"@id\":\"https://abstractalgorithms.github.io/posts/modified-binary-search-interview-analysis-java\"},\"image\":{\"@type\":\"ImageObject\",\"url\":\"https://abstractalgorithms.github.io/posts/modified-binary-search-interview-analysis-java/assets/overview-600x400.jpg\"}}"}}]]}]
b:[["$","meta","0",{"name":"viewport","content":"width=device-width, initial-scale=1"}],["$","meta","1",{"charSet":"utf-8"}],["$","title","2",{"children":"Modified Binary Search: Interview Scenarios, Analysis, and Java Implementation | AbstractAlgorithms"}],["$","meta","3",{"name":"description","content":"Master modified binary search for rotated arrays and advanced search problems. Java code, scenarios, and interview tips."}],["$","meta","4",{"name":"author","content":"Abstract Algorithms"}],["$","meta","5",{"name":"keywords","content":"algorithms,data structures,system design,software engineering,programming,computer science,performance optimization,big o notation,hash tables,database indexing"}],["$","meta","6",{"name":"creator","content":"Abstract Algorithms"}],["$","meta","7",{"name":"publisher","content":"Abstract Algorithms"}],["$","meta","8",{"name":"robots","content":"index, follow"}],["$","meta","9",{"name":"googlebot","content":"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"}],["$","meta","10",{"property":"og:title","content":"Modified Binary Search: Interview Scenarios, Analysis, and Java Implementation"}],["$","meta","11",{"property":"og:description","content":"Master modified binary search for rotated arrays and advanced search problems. Java code, scenarios, and interview tips."}],["$","meta","12",{"property":"og:image","content":"https://abstractalgorithms.github.io/posts/modified-binary-search-interview-analysis-java/assets/overview-600x400.jpg"}],["$","meta","13",{"property":"og:image:width","content":"1200"}],["$","meta","14",{"property":"og:image:height","content":"627"}],["$","meta","15",{"property":"og:image:alt","content":"Modified Binary Search: Interview Scenarios, Analysis, and Java Implementation"}],["$","meta","16",{"property":"og:type","content":"article"}],["$","meta","17",{"property":"article:published_time","content":"2025-07-16"}],["$","meta","18",{"property":"article:author","content":"Abstract Algorithms"}],["$","meta","19",{"name":"twitter:card","content":"summary_large_image"}],["$","meta","20",{"name":"twitter:title","content":"Modified Binary Search: Interview Scenarios, Analysis, and Java Implementation"}],["$","meta","21",{"name":"twitter:description","content":"Master modified binary search for rotated arrays and advanced search problems. Java code, scenarios, and interview tips."}],["$","meta","22",{"name":"twitter:image","content":"https://abstractalgorithms.github.io/posts/modified-binary-search-interview-analysis-java/assets/overview-600x400.jpg"}],["$","link","23",{"rel":"shortcut icon","href":"/logo/favicon-32x32.png"}],["$","link","24",{"rel":"icon","href":"/logo/favicon-16x16.png","type":"image/png","sizes":"16x16"}],["$","link","25",{"rel":"icon","href":"/logo/favicon-32x32.png","type":"image/png","sizes":"32x32"}],["$","link","26",{"rel":"icon","href":"/logo/favicon-48x48.png","type":"image/png","sizes":"48x48"}],["$","link","27",{"rel":"icon","href":"/logo/favicon-96x96.png","type":"image/png","sizes":"96x96"}],["$","link","28",{"rel":"icon","href":"/logo/favicon-192x192.png","type":"image/png","sizes":"192x192"}],["$","link","29",{"rel":"icon","href":"/favicon.ico","type":"image/x-icon"}],["$","link","30",{"rel":"apple-touch-icon","href":"/logo/favicon-192x192.png","type":"image/png","sizes":"192x192"}],["$","meta","31",{"name":"next-size-adjust"}]]
1:null
