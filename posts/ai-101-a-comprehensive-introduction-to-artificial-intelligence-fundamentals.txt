3:I[4707,[],""]
5:I[36423,[],""]
6:I[84603,["4358","static/chunks/bc9e92e6-efe8e590a66d5f90.js","139","static/chunks/69806262-2f26cb68a64de63d.js","2972","static/chunks/2972-d93db4598907ce23.js","244","static/chunks/244-375110144b1f5c45.js","5973","static/chunks/5973-8e1d3ee0452991f9.js","5605","static/chunks/5605-ff89f570335e541e.js","993","static/chunks/993-c0a909a101b8ac62.js","3185","static/chunks/app/layout-aeb48df118a688fa.js"],"AuthProvider"]
7:I[85754,["4358","static/chunks/bc9e92e6-efe8e590a66d5f90.js","139","static/chunks/69806262-2f26cb68a64de63d.js","2972","static/chunks/2972-d93db4598907ce23.js","244","static/chunks/244-375110144b1f5c45.js","5973","static/chunks/5973-8e1d3ee0452991f9.js","5605","static/chunks/5605-ff89f570335e541e.js","993","static/chunks/993-c0a909a101b8ac62.js","3185","static/chunks/app/layout-aeb48df118a688fa.js"],"default"]
8:I[90688,["4358","static/chunks/bc9e92e6-efe8e590a66d5f90.js","139","static/chunks/69806262-2f26cb68a64de63d.js","2972","static/chunks/2972-d93db4598907ce23.js","244","static/chunks/244-375110144b1f5c45.js","5973","static/chunks/5973-8e1d3ee0452991f9.js","5605","static/chunks/5605-ff89f570335e541e.js","993","static/chunks/993-c0a909a101b8ac62.js","3185","static/chunks/app/layout-aeb48df118a688fa.js"],"default"]
9:I[66302,["2972","static/chunks/2972-d93db4598907ce23.js","7601","static/chunks/app/error-9da606d33a8d3ef9.js"],"default"]
a:I[75292,["2972","static/chunks/2972-d93db4598907ce23.js","9160","static/chunks/app/not-found-edac72d6e3280fcc.js"],"default"]
4:["slug","ai-101-a-comprehensive-introduction-to-artificial-intelligence-fundamentals","d"]
0:["Y09OOBDoRptcPEfaxGwVM",[[["",{"children":["posts",{"children":[["slug","ai-101-a-comprehensive-introduction-to-artificial-intelligence-fundamentals","d"],{"children":["__PAGE__?{\"slug\":\"ai-101-a-comprehensive-introduction-to-artificial-intelligence-fundamentals\"}",{}]}]}]},"$undefined","$undefined",true],["",{"children":["posts",{"children":[["slug","ai-101-a-comprehensive-introduction-to-artificial-intelligence-fundamentals","d"],{"children":["__PAGE__",{},[["$L1","$L2",null],null],null]},[null,["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children","posts","children","$4","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined"}]],null]},[null,["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children","posts","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined"}]],null]},[[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/275ed64cc4367444.css","precedence":"next","crossOrigin":"$undefined"}],["$","link","1",{"rel":"stylesheet","href":"/_next/static/css/22508c5d80c84e1b.css","precedence":"next","crossOrigin":"$undefined"}]],["$","html",null,{"lang":"en","children":[["$","head",null,{"children":[["$","script",null,{"type":"application/ld+json","dangerouslySetInnerHTML":{"__html":"{\"@context\":\"https://schema.org\",\"@type\":\"WebSite\",\"name\":\"Abstract Algorithms\",\"description\":\"A comprehensive blog about algorithms, data structures, system design, and software engineering best practices\",\"url\":\"https://abstractalgorithms.github.io\",\"potentialAction\":{\"@type\":\"SearchAction\",\"target\":{\"@type\":\"EntryPoint\",\"urlTemplate\":\"https://abstractalgorithms.github.io/posts/{search_term_string}\"},\"query-input\":\"required name=search_term_string\"},\"publisher\":{\"@type\":\"Organization\",\"name\":\"Abstract Algorithms\",\"url\":\"https://abstractalgorithms.github.io\"}}"}}],["$","link",null,{"rel":"manifest","href":"/manifest.json"}],["$","meta",null,{"name":"theme-color","content":"#00D885"}],["$","link",null,{"rel":"icon","type":"image/png","sizes":"32x32","href":"/logo/header.png"}],["$","link",null,{"rel":"icon","type":"image/png","sizes":"16x16","href":"/logo/header.png"}],["$","link",null,{"rel":"apple-touch-icon","sizes":"180x180","href":"/logo/header.png"}],["$","meta",null,{"name":"google-site-verification","content":"D5v1M3nD8oO9DNaZKujCwBLNNqf35CTJo114uv8yMNU"}],["$","script",null,{"async":true,"src":"https://www.googletagmanager.com/gtag/js?id=G-VZR168MHE2"}],["$","script",null,{"dangerouslySetInnerHTML":{"__html":"\n            window.dataLayer = window.dataLayer || [];\n            function gtag(){dataLayer.push(arguments);}\n            gtag('js', new Date());\n            gtag('config', 'G-VZR168MHE2');\n          "}}]]}],["$","body",null,{"className":"__className_e8ce0c","children":["$","$L6",null,{"children":[["$","$L7",null,{}],["$","$L8",null,{"children":["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children"],"error":"$9","errorStyles":[],"errorScripts":[],"template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":["$","$La",null,{}],"notFoundStyles":[]}]}]]}]}]]}]],null],null],["$Lb",null]]]]
c:I[72972,["2972","static/chunks/2972-d93db4598907ce23.js","5878","static/chunks/5878-7524eb3ca8c56965.js","1811","static/chunks/1811-20715ce28a1807b1.js","333","static/chunks/app/posts/%5Bslug%5D/page-ce105847f4430163.js"],""]
d:I[16743,["2972","static/chunks/2972-d93db4598907ce23.js","5878","static/chunks/5878-7524eb3ca8c56965.js","1811","static/chunks/1811-20715ce28a1807b1.js","333","static/chunks/app/posts/%5Bslug%5D/page-ce105847f4430163.js"],"default"]
e:I[65878,["2972","static/chunks/2972-d93db4598907ce23.js","5878","static/chunks/5878-7524eb3ca8c56965.js","1811","static/chunks/1811-20715ce28a1807b1.js","333","static/chunks/app/posts/%5Bslug%5D/page-ce105847f4430163.js"],"Image"]
f:I[43449,["2972","static/chunks/2972-d93db4598907ce23.js","5878","static/chunks/5878-7524eb3ca8c56965.js","1811","static/chunks/1811-20715ce28a1807b1.js","333","static/chunks/app/posts/%5Bslug%5D/page-ce105847f4430163.js"],"default"]
10:I[20703,["2972","static/chunks/2972-d93db4598907ce23.js","5878","static/chunks/5878-7524eb3ca8c56965.js","1811","static/chunks/1811-20715ce28a1807b1.js","333","static/chunks/app/posts/%5Bslug%5D/page-ce105847f4430163.js"],"default"]
11:I[87966,["2972","static/chunks/2972-d93db4598907ce23.js","5878","static/chunks/5878-7524eb3ca8c56965.js","1811","static/chunks/1811-20715ce28a1807b1.js","333","static/chunks/app/posts/%5Bslug%5D/page-ce105847f4430163.js"],"default"]
18:I[79798,["2972","static/chunks/2972-d93db4598907ce23.js","5878","static/chunks/5878-7524eb3ca8c56965.js","1811","static/chunks/1811-20715ce28a1807b1.js","333","static/chunks/app/posts/%5Bslug%5D/page-ce105847f4430163.js"],"default"]
12:Tba7,<blockquote>
<p><strong>TLDR:</strong> Arrays are the most basic data structure, providing fast random access and efficient storage. This guide covers array basics, allowed operations, Java implementation, and links to advanced posts using arrays.</p>
</blockquote>
<p><strong>Navigation:</strong></p>
<ul>
<li><a href="#what-is-an-array-">What is an Array? ðŸš€</a></li>
<li><a href="#allowed-operations">Allowed Operations</a></li>
<li><a href="#how-to-use-arrays-in-java-">How to Use Arrays in Java ðŸ’»</a></li>
<li><a href="#where-arrays-are-used-">Where Arrays Are Used ðŸ§©</a></li>
<li><a href="#pro-tips-for-interviews-">Pro Tips for Interviews ðŸ’¡</a></li>
</ul>
<h2>What is an Array? ðŸš€</h2>
<p>An array is a fixed-size, contiguous block of memory that stores elements of the same type. Arrays provide constant-time access to any element by index.</p>
<p><strong>Purpose:</strong></p>
<ul>
<li>Store collections of data</li>
<li>Enable fast random access</li>
<li>Foundation for other data structures (lists, matrices, heaps)</li>
</ul>
<hr>
<h2>Allowed Operations</h2>
<ul>
<li><strong>get(index):</strong> Access element at a specific index</li>
<li><strong>set(index, value):</strong> Update element at a specific index</li>
<li><strong>length:</strong> Get the number of elements</li>
<li><strong>iterate:</strong> Loop through all elements</li>
</ul>
<hr>
<h2>How to Use Arrays in Java ðŸ’»</h2>
<p><strong>Approach:</strong>
Java provides built-in support for arrays. You can also use <code>ArrayList</code> for dynamic arrays.</p>
<h3>Using Java Arrays</h3>
<pre><code class="language-java">int[] arr = new int[5];
arr[0] = 10;
int x = arr[0];
for (int i = 0; i &#x3C; arr.length; i++) {
    System.out.println(arr[i]);
}
</code></pre>
<h3>Using ArrayList (Dynamic Array)</h3>
<pre><code class="language-java">ArrayList&#x3C;Integer> list = new ArrayList&#x3C;>();
list.add(10);
int x = list.get(0);
for (int val : list) {
    System.out.println(val);
}
</code></pre>
<hr>
<h2>Where Arrays Are Used ðŸ§©</h2>
<ul>
<li><a href="/posts/matrix-traversal-interview-analysis-java">Matrix Traversal: Interview Scenarios, Analysis, and Java Implementation</a></li>
<li><a href="/posts/dynamic-programming-patterns-interview-analysis-java">Dynamic Programming: Interview Scenarios, Analysis, and Java Implementation</a></li>
<li><a href="/posts/modified-binary-search-interview-analysis-java">Modified Binary Search: Interview Scenarios, Analysis, and Java Implementation</a></li>
</ul>
<hr>
<h2>Pro Tips for Interviews ðŸ’¡</h2>
<ul>
<li>Clarify if fixed-size or dynamic array is needed</li>
<li>Watch for out-of-bounds errors</li>
<li>Know time/space complexity for operations</li>
<li>Practice both array and ArrayList usage</li>
</ul>
<hr>
<p><strong>Summary:</strong>
Arrays are the foundation for many algorithms and data structures. Master the basics, understand allowed operations, and practice using arrays in Java to build a strong foundation.</p>
13:Tec8,<blockquote>
<p><strong>TLDR:</strong> Binary Search Trees (BSTs) are hierarchical data structures for fast ordered data access, insertion, and deletion. This guide covers BST basics, allowed operations, Java implementation, and links to advanced posts using BSTs.</p>
</blockquote>
<p><strong>Navigation:</strong></p>
<ul>
<li><a href="#what-is-a-bst-">What is a BST? ðŸš€</a></li>
<li><a href="#allowed-operations">Allowed Operations</a></li>
<li><a href="#how-to-design-a-bst-in-java-">How to Design a BST in Java ðŸ’»</a></li>
<li><a href="#where-bsts-are-used-">Where BSTs Are Used ðŸ§©</a></li>
<li><a href="#pro-tips-for-interviews-">Pro Tips for Interviews ðŸ’¡</a></li>
</ul>
<h2>What is a BST? ðŸš€</h2>
<p>A binary search tree (BST) is a binary tree where each node's left child is less than the node and the right child is greater. BSTs enable fast search, insert, and delete for ordered data.</p>
<p><strong>Purpose:</strong></p>
<ul>
<li>Fast search, insert, and delete for ordered data</li>
<li>Foundation for sets, maps, and range queries</li>
<li>Used in searching, sorting, and interval problems</li>
</ul>
<hr>
<h2>Allowed Operations</h2>
<ul>
<li><strong>insert(x):</strong> Add element x to the BST</li>
<li><strong>delete(x):</strong> Remove element x from the BST</li>
<li><strong>search(x):</strong> Check if x exists in the BST</li>
<li><strong>traverse():</strong> Visit all nodes in order (inorder, preorder, postorder)</li>
<li><strong>min()/max():</strong> Find minimum/maximum value</li>
</ul>
<hr>
<h2>How to Design a BST in Java ðŸ’»</h2>
<p><strong>Approach:</strong>
Implement a node class with left/right pointers. Java provides <code>TreeSet</code> and <code>TreeMap</code> for built-in BSTs.</p>
<h3>Custom BST Implementation</h3>
<pre><code class="language-java">class TreeNode {
    int val;
    TreeNode left, right;
    TreeNode(int val) { this.val = val; }
}
class BST {
    private TreeNode root;
    public void insert(int x) { root = insert(root, x); }
    private TreeNode insert(TreeNode node, int x) {
        if (node == null) return new TreeNode(x);
        if (x &#x3C; node.val) node.left = insert(node.left, x);
        else if (x > node.val) node.right = insert(node.right, x);
        return node;
    }
    public boolean search(int x) {
        TreeNode node = root;
        while (node != null) {
            if (x == node.val) return true;
            node = x &#x3C; node.val ? node.left : node.right;
        }
        return false;
    }
    public void inorder() { inorder(root); }
    private void inorder(TreeNode node) {
        if (node == null) return;
        inorder(node.left);
        System.out.print(node.val + " ");
        inorder(node.right);
    }
}
</code></pre>
<h3>Using TreeSet (Built-in BST)</h3>
<pre><code class="language-java">TreeSet&#x3C;Integer> set = new TreeSet&#x3C;>();
set.add(10);
set.add(5);
for (int x : set) {
    System.out.println(x);
}
</code></pre>
<hr>
<h2>Where BSTs Are Used ðŸ§©</h2>
<ul>
<li><a href="/posts/genai-mastery-series/part-9">Range Query and Interval Problems</a></li>
<li><a href="/posts/genai-mastery-series/part-10">Ordered Set/Map Implementations</a></li>
<li><a href="/posts/genai-mastery-series/part-11">Searching and Sorting Algorithms</a></li>
</ul>
<hr>
<h2>Pro Tips for Interviews ðŸ’¡</h2>
<ul>
<li>Draw BST structure for each operation</li>
<li>Know time/space complexity for operations</li>
<li>Practice both recursive and iterative traversals</li>
<li>Clarify if duplicates are allowed</li>
</ul>
<hr>
<p><strong>Summary:</strong>
BSTs are essential for many ordered data and search problems. Master the basics, understand allowed operations, and practice implementing BSTs in Java to build a strong foundation.</p>
14:Te61,<blockquote>
<p><strong>TLDR:</strong> Circular queues efficiently use fixed-size buffers for scheduling, buffering, and streaming. This guide covers circular queue basics, allowed operations, Java implementation, and links to advanced posts using circular queues.</p>
</blockquote>
<p><strong>Navigation:</strong></p>
<ul>
<li><a href="#what-is-a-circular-queue-">What is a Circular Queue? ðŸš€</a></li>
<li><a href="#allowed-operations">Allowed Operations</a></li>
<li><a href="#how-to-design-a-circular-queue-in-java-">How to Design a Circular Queue in Java ðŸ’»</a></li>
<li><a href="#where-circular-queues-are-used-">Where Circular Queues Are Used ðŸ§©</a></li>
<li><a href="#pro-tips-for-interviews-">Pro Tips for Interviews ðŸ’¡</a></li>
</ul>
<h2>What is a Circular Queue? ðŸš€</h2>
<p>A circular queue is a linear data structure that connects the end of the queue back to the front, forming a circle. It efficiently utilizes space in fixed-size buffers and is ideal for scheduling and streaming.</p>
<p><strong>Purpose:</strong></p>
<ul>
<li>Efficient use of fixed-size buffers</li>
<li>Scheduling and round-robin tasks</li>
<li>Streaming and buffering data</li>
</ul>
<hr>
<h2>Allowed Operations</h2>
<ul>
<li><strong>offer(x):</strong> Add element x to the rear</li>
<li><strong>poll():</strong> Remove and return the front element</li>
<li><strong>peek():</strong> Return the front element without removing</li>
<li><strong>isEmpty():</strong> Check if the queue is empty</li>
<li><strong>isFull():</strong> Check if the queue is full</li>
<li><strong>size():</strong> Return the number of elements</li>
</ul>
<hr>
<h2>How to Design a Circular Queue in Java ðŸ’»</h2>
<p><strong>Approach:</strong>
Implement a fixed-size array with front and rear pointers that wrap around using modulo arithmetic.</p>
<h3>Custom Circular Queue Implementation</h3>
<pre><code class="language-java">class CircularQueue {
    private int[] arr;
    private int front, rear, size, capacity;
    public CircularQueue(int capacity) {
        arr = new int[capacity];
        this.capacity = capacity;
        front = 0; rear = -1; size = 0;
    }
    public void offer(int x) {
        if (isFull()) throw new RuntimeException("Queue full");
        rear = (rear + 1) % capacity;
        arr[rear] = x;
        size++;
    }
    public int poll() {
        if (isEmpty()) throw new RuntimeException("Queue empty");
        int val = arr[front];
        front = (front + 1) % capacity;
        size--;
        return val;
    }
    public int peek() {
        if (isEmpty()) throw new RuntimeException("Queue empty");
        return arr[front];
    }
    public boolean isEmpty() { return size == 0; }
    public boolean isFull() { return size == capacity; }
    public int size() { return size; }
}
</code></pre>
<hr>
<h2>Where Circular Queues Are Used ðŸ§©</h2>
<ul>
<li><a href="/posts/genai-mastery-series/part-10">Task Scheduling and Round-Robin Algorithms</a></li>
<li><a href="/posts/genai-mastery-series/part-4">Streaming and Buffering Data</a></li>
<li><a href="/posts/genai-mastery-series/part-7">Fixed-Size Resource Management</a></li>
</ul>
<hr>
<h2>Pro Tips for Interviews ðŸ’¡</h2>
<ul>
<li>Clarify queue capacity and wrap-around logic</li>
<li>Know time/space complexity for operations</li>
<li>Practice both enqueue and dequeue operations</li>
<li>Use circular queues for buffering and scheduling</li>
</ul>
<hr>
<p><strong>Summary:</strong>
Circular queues are essential for efficient buffering and scheduling. Master the basics, understand allowed operations, and practice implementing circular queues in Java to build a strong foundation.</p>
15:T1186,<blockquote>
<p><strong>TLDR:</strong> Deques (double-ended queues) allow insertion and removal from both ends, making them versatile for sliding window, palindrome, and scheduling problems. This guide covers deque basics, allowed operations, Java implementation, and links to advanced posts using deques.</p>
</blockquote>
<p><strong>Navigation:</strong></p>
<ul>
<li><a href="#what-is-a-deque-">What is a Deque? ðŸš€</a></li>
<li><a href="#allowed-operations">Allowed Operations</a></li>
<li><a href="#how-to-use-deques-in-java-">How to Use Deques in Java ðŸ’»</a></li>
<li><a href="#where-deques-are-used-">Where Deques Are Used ðŸ§©</a></li>
<li><a href="#pro-tips-for-interviews-">Pro Tips for Interviews ðŸ’¡</a></li>
</ul>
<h2>What is a Deque? ðŸš€</h2>
<p>A deque (double-ended queue) is a linear data structure that allows insertion and removal of elements from both the front and rear. Deques generalize both stacks and queues.</p>
<p><strong>Purpose:</strong></p>
<ul>
<li>Support both stack and queue operations</li>
<li>Efficient sliding window and palindrome checks</li>
<li>Scheduling and buffering</li>
</ul>
<hr>
<h2>Allowed Operations</h2>
<ul>
<li><strong>addFirst(x):</strong> Insert x at the front</li>
<li><strong>addLast(x):</strong> Insert x at the rear</li>
<li><strong>removeFirst():</strong> Remove and return the front element</li>
<li><strong>removeLast():</strong> Remove and return the rear element</li>
<li><strong>peekFirst():</strong> Return the front element without removing</li>
<li><strong>peekLast():</strong> Return the rear element without removing</li>
<li><strong>isEmpty():</strong> Check if the deque is empty</li>
<li><strong>size():</strong> Return the number of elements</li>
</ul>
<hr>
<h2>How to Use Deques in Java ðŸ’»</h2>
<p><strong>Approach:</strong>
Java provides a built-in <code>Deque</code> interface (e.g., <code>ArrayDeque</code>). You can also implement a deque using a doubly linked list.</p>
<h3>Using Java's Built-in ArrayDeque</h3>
<pre><code class="language-java">Deque&#x3C;Integer> deque = new ArrayDeque&#x3C;>();
deque.addFirst(10);
deque.addLast(20);
int front = deque.removeFirst();
int rear = deque.removeLast();
</code></pre>
<h3>Custom Deque Implementation (Doubly Linked List)</h3>
<pre><code class="language-java">class Node {
    int val;
    Node prev, next;
    Node(int val) { this.val = val; }
}
class MyDeque {
    private Node head, tail;
    private int size;
    public void addFirst(int x) {
        Node node = new Node(x);
        if (head == null) {
            head = tail = node;
        } else {
            node.next = head;
            head.prev = node;
            head = node;
        }
        size++;
    }
    public void addLast(int x) {
        Node node = new Node(x);
        if (tail == null) {
            head = tail = node;
        } else {
            tail.next = node;
            node.prev = tail;
            tail = node;
        }
        size++;
    }
    public int removeFirst() {
        if (head == null) throw new RuntimeException("Deque empty");
        int val = head.val;
        head = head.next;
        if (head != null) head.prev = null;
        else tail = null;
        size--;
        return val;
    }
    public int removeLast() {
        if (tail == null) throw new RuntimeException("Deque empty");
        int val = tail.val;
        tail = tail.prev;
        if (tail != null) tail.next = null;
        else head = null;
        size--;
        return val;
    }
    public boolean isEmpty() { return size == 0; }
    public int size() { return size; }
}
</code></pre>
<hr>
<h2>Where Deques Are Used ðŸ§©</h2>
<ul>
<li><a href="/posts/genai-mastery-series/part-4">Sliding Window Maximum/Minimum Problems</a></li>
<li><a href="/posts/genai-mastery-series/part-6">Palindrome Checking and Reordering</a></li>
<li><a href="/posts/genai-mastery-series/part-10">Task Scheduling and Buffering</a></li>
</ul>
<hr>
<h2>Pro Tips for Interviews ðŸ’¡</h2>
<ul>
<li>Clarify if both ends need to be accessed</li>
<li>Know time/space complexity for operations</li>
<li>Practice both built-in and custom implementations</li>
<li>Use deques for sliding window and two-pointer problems</li>
</ul>
<hr>
<p><strong>Summary:</strong>
Deques are essential for many algorithms and interview problems. Master the basics, understand allowed operations, and practice using deques in Java to build a strong foundation.</p>
16:T11e8,<blockquote>
<p><strong>TLDR:</strong> Doubly linked lists allow efficient insertions and deletions from both ends, supporting bidirectional traversal. This guide covers doubly linked list basics, allowed operations, Java implementation, and links to advanced posts using doubly linked lists.</p>
</blockquote>
<p><strong>Navigation:</strong></p>
<ul>
<li><a href="#what-is-a-doubly-linked-list-">What is a Doubly Linked List? ðŸš€</a></li>
<li><a href="#allowed-operations">Allowed Operations</a></li>
<li><a href="#how-to-design-a-doubly-linked-list-in-java-">How to Design a Doubly Linked List in Java ðŸ’»</a></li>
<li><a href="#where-doubly-linked-lists-are-used-">Where Doubly Linked Lists Are Used ðŸ§©</a></li>
<li><a href="#pro-tips-for-interviews-">Pro Tips for Interviews ðŸ’¡</a></li>
</ul>
<h2>What is a Doubly Linked List? ðŸš€</h2>
<p>A doubly linked list is a linear data structure where each node contains a value, a reference to the next node, and a reference to the previous node. This enables efficient insertions and deletions from both ends and bidirectional traversal.</p>
<p><strong>Purpose:</strong></p>
<ul>
<li>Efficient insertions/deletions at both ends</li>
<li>Bidirectional traversal</li>
<li>Foundation for deques, LRU caches, and more</li>
</ul>
<hr>
<h2>Allowed Operations</h2>
<ul>
<li><strong>addFirst(x):</strong> Insert element x at the beginning</li>
<li><strong>addLast(x):</strong> Insert element x at the end</li>
<li><strong>removeFirst():</strong> Remove and return the first element</li>
<li><strong>removeLast():</strong> Remove and return the last element</li>
<li><strong>get(index):</strong> Get the value at a specific index</li>
<li><strong>isEmpty():</strong> Check if the list is empty</li>
<li><strong>size():</strong> Return the number of elements</li>
</ul>
<hr>
<h2>How to Design a Doubly Linked List in Java ðŸ’»</h2>
<p><strong>Approach:</strong>
Implement a node class with next and prev pointers. Java's <code>LinkedList</code> class is a doubly linked list.</p>
<h3>Using Java's Built-in LinkedList</h3>
<pre><code class="language-java">LinkedList&#x3C;Integer> list = new LinkedList&#x3C;>();
list.addFirst(10);
list.addLast(20);
int first = list.removeFirst();
int last = list.removeLast();
</code></pre>
<h3>Custom Doubly Linked List Implementation</h3>
<pre><code class="language-java">class Node {
    int val;
    Node prev, next;
    Node(int val) { this.val = val; }
}
class DoublyLinkedList {
    private Node head, tail;
    private int size;
    public void addFirst(int x) {
        Node node = new Node(x);
        if (head == null) {
            head = tail = node;
        } else {
            node.next = head;
            head.prev = node;
            head = node;
        }
        size++;
    }
    public void addLast(int x) {
        Node node = new Node(x);
        if (tail == null) {
            head = tail = node;
        } else {
            tail.next = node;
            node.prev = tail;
            tail = node;
        }
        size++;
    }
    public int removeFirst() {
        if (head == null) throw new RuntimeException("List empty");
        int val = head.val;
        head = head.next;
        if (head != null) head.prev = null;
        else tail = null;
        size--;
        return val;
    }
    public int removeLast() {
        if (tail == null) throw new RuntimeException("List empty");
        int val = tail.val;
        tail = tail.prev;
        if (tail != null) tail.next = null;
        else head = null;
        size--;
        return val;
    }
    public boolean isEmpty() { return size == 0; }
    public int size() { return size; }
}
</code></pre>
<hr>
<h2>Where Doubly Linked Lists Are Used ðŸ§©</h2>
<ul>
<li><a href="/posts/deque-basics-java">Deque and LRU Cache Implementations</a></li>
<li><a href="/posts/genai-mastery-series/part-10">Bidirectional Traversal Problems</a></li>
<li><a href="/posts/genai-mastery-series/part-6">Undo/Redo Functionality</a></li>
</ul>
<hr>
<h2>Pro Tips for Interviews ðŸ’¡</h2>
<ul>
<li>Draw node connections for each operation</li>
<li>Know time/space complexity for operations</li>
<li>Practice both built-in and custom implementations</li>
<li>Use doubly linked lists for bidirectional and deque problems</li>
</ul>
<hr>
<p><strong>Summary:</strong>
Doubly linked lists are essential for many algorithms and interview problems. Master the basics, understand allowed operations, and practice implementing doubly linked lists in Java to build a strong foundation.</p>
17:Tbb3,<blockquote>
<p><strong>TLDR:</strong> Fenwick trees (binary indexed trees) efficiently support prefix sum queries and updates, making them ideal for frequency and range problems. This guide covers Fenwick tree basics, allowed operations, Java implementation, and links to advanced posts using Fenwick trees.</p>
</blockquote>
<p><strong>Navigation:</strong></p>
<ul>
<li><a href="#what-is-a-fenwick-tree-">What is a Fenwick Tree? ðŸš€</a></li>
<li><a href="#allowed-operations">Allowed Operations</a></li>
<li><a href="#how-to-design-a-fenwick-tree-in-java-">How to Design a Fenwick Tree in Java ðŸ’»</a></li>
<li><a href="#where-fenwick-trees-are-used-">Where Fenwick Trees Are Used ðŸ§©</a></li>
<li><a href="#pro-tips-for-interviews-">Pro Tips for Interviews ðŸ’¡</a></li>
</ul>
<h2>What is a Fenwick Tree? ðŸš€</h2>
<p>A Fenwick tree (binary indexed tree) is a data structure that efficiently supports prefix sum queries and updates on arrays. It uses bit manipulation to achieve O(log n) time for both operations.</p>
<p><strong>Purpose:</strong></p>
<ul>
<li>Efficient prefix sum/range queries</li>
<li>Efficient point updates</li>
<li>Used in frequency and range query problems</li>
</ul>
<hr>
<h2>Allowed Operations</h2>
<ul>
<li><strong>build(arr):</strong> Build the Fenwick tree from an array</li>
<li><strong>query(i):</strong> Query the prefix sum up to index i</li>
<li><strong>update(i, x):</strong> Add x to the value at index i</li>
</ul>
<hr>
<h2>How to Design a Fenwick Tree in Java ðŸ’»</h2>
<p><strong>Approach:</strong>
Use an array to store cumulative frequencies. Use bit manipulation to traverse parent/child relationships.</p>
<h3>Custom Fenwick Tree Implementation</h3>
<pre><code class="language-java">class FenwickTree {
    private int[] tree;
    private int n;
    public FenwickTree(int n) {
        this.n = n;
        tree = new int[n + 1];
    }
    public void update(int i, int delta) {
        for (++i; i &#x3C;= n; i += i &#x26; -i) tree[i] += delta;
    }
    public int query(int i) {
        int sum = 0;
        for (++i; i > 0; i -= i &#x26; -i) sum += tree[i];
        return sum;
    }
}
</code></pre>
<hr>
<h2>Where Fenwick Trees Are Used ðŸ§©</h2>
<ul>
<li><a href="/posts/genai-mastery-series/part-9">Prefix Sum and Frequency Problems</a></li>
<li><a href="/posts/genai-mastery-series/part-11">Range Query and Update Problems</a></li>
<li><a href="/posts/genai-mastery-series/part-12">Competitive Programming</a></li>
</ul>
<hr>
<h2>Pro Tips for Interviews ðŸ’¡</h2>
<ul>
<li>Draw tree structure for each operation</li>
<li>Know time/space complexity for operations</li>
<li>Practice both query and update operations</li>
<li>Use Fenwick trees for prefix sum and frequency problems</li>
</ul>
<hr>
<p><strong>Summary:</strong>
Fenwick trees are essential for prefix sum and frequency problems. Master the basics, understand allowed operations, and practice implementing Fenwick trees in Java to build a strong foundation.</p>
19:T483,{"@context":"https://schema.org","@type":"BlogPosting","headline":"AI 101: A Comprehensive Introduction to Artificial Intelligence Fundamentals","description":"Meet your personal super-smart assistant - AI! It's like a magic recipe book that helps machines make smart choices and solve problems on their own, freeing you to focus on what matters most. Think virtual assistants, self-driving cars, and more - but what else can AI do? Let's find out.","datePublished":"2025-06-29","dateModified":"2025-06-29","author":{"@type":"Person","name":"Abstract Algorithms"},"publisher":{"@type":"Organization","name":"Abstract Algorithms","url":"https://abstractalgorithms.github.io"},"url":"https://abstractalgorithms.github.io/posts/ai-101-a-comprehensive-introduction-to-artificial-intelligence-fundamentals","mainEntityOfPage":{"@type":"WebPage","@id":"https://abstractalgorithms.github.io/posts/ai-101-a-comprehensive-introduction-to-artificial-intelligence-fundamentals"},"image":{"@type":"ImageObject","url":"https://abstractalgorithms.github.io/posts/ai-101-a-comprehensive-introduction-to-artificial-intelligence-fundamentals/assets/overview-600x400.jpg"}}2:["$","article",null,{"className":"min-h-screen bg-gradient-to-br from-slate-50 via-white to-emerald-50 relative","children":[["$","div",null,{"className":"bg-white/90 backdrop-blur-sm border-b border-emerald-100 shadow-sm","children":["$","div",null,{"className":"bg-white","children":["$","div",null,{"className":"max-w-4xl mx-auto px-6 py-8","children":[["$","nav",null,{"className":"flex items-center space-x-2 text-sm text-gray-600 mb-8","children":[["$","$Lc",null,{"href":"/","className":"hover:text-gray-900 transition-colors","children":"Home"}],["$","svg",null,{"xmlns":"http://www.w3.org/2000/svg","width":24,"height":24,"viewBox":"0 0 24 24","fill":"none","stroke":"currentColor","strokeWidth":2,"strokeLinecap":"round","strokeLinejoin":"round","className":"lucide lucide-chevron-right w-4 h-4","children":[["$","path","mthhwq",{"d":"m9 18 6-6-6-6"}],"$undefined"]}],["$","$Lc",null,{"href":"/posts","className":"hover:text-gray-900 transition-colors","children":"Blog"}],["$","svg",null,{"xmlns":"http://www.w3.org/2000/svg","width":24,"height":24,"viewBox":"0 0 24 24","fill":"none","stroke":"currentColor","strokeWidth":2,"strokeLinecap":"round","strokeLinejoin":"round","className":"lucide lucide-chevron-right w-4 h-4","children":[["$","path","mthhwq",{"d":"m9 18 6-6-6-6"}],"$undefined"]}],["$","$Lc",null,{"href":"/posts?category=Python","className":"hover:text-gray-900 transition-colors","children":"Python"}],["$","svg",null,{"xmlns":"http://www.w3.org/2000/svg","width":24,"height":24,"viewBox":"0 0 24 24","fill":"none","stroke":"currentColor","strokeWidth":2,"strokeLinecap":"round","strokeLinejoin":"round","className":"lucide lucide-chevron-right w-4 h-4","children":[["$","path","mthhwq",{"d":"m9 18 6-6-6-6"}],"$undefined"]}],["$","span",null,{"className":"text-gray-900 font-medium","children":"AI 101: A Comprehensive Introduction to Artificial Intelligence Fundamentals"}]]}],["$","h1",null,{"className":"text-4xl md:text-5xl font-bold text-gray-900 mb-6 leading-tight","children":"AI 101: A Comprehensive Introduction to Artificial Intelligence Fundamentals"}],["$","div",null,{"className":"flex items-center space-x-6 text-gray-600 mb-8 flex-wrap","children":[["$","div",null,{"className":"flex items-center space-x-2","children":["$","span",null,{"children":["By ","Abstract Algorithms"]}]}],["$","div",null,{"className":"flex items-center space-x-2","children":["$","span",null,{"children":"Jun 29, 2025"}]}],["$","div",null,{"className":"flex items-center space-x-2","children":["$","span",null,{"children":"5 min read"}]}],["$","$Ld",null,{"id":"cfb84ce8-f623-44ac-a687-0044ed94e9c3","size":"md","showTrending":true}]]}],["$","div",null,{"className":"mb-8","children":["$","div",null,{"className":"relative aspect-[16/9] rounded-xl overflow-hidden","children":["$","$Le",null,{"src":"/posts/ai-101-a-comprehensive-introduction-to-artificial-intelligence-fundamentals/assets/overview-600x400.jpg","alt":"AI 101: A Comprehensive Introduction to Artificial Intelligence Fundamentals","fill":true,"className":"object-cover","priority":true}]}]}]]}]}]}],["$","div",null,{"className":"max-w-5xl mx-auto px-6 py-12","children":[["$","div",null,{"className":"bg-white/90 backdrop-blur-sm rounded-2xl border border-slate-200/50 shadow-xl shadow-slate-100/50 overflow-hidden","children":["$","div",null,{"className":"p-8 lg:p-12","children":["$","$Lf",null,{"slug":"ai-101-a-comprehensive-introduction-to-artificial-intelligence-fundamentals"}]}]}],["$","div",null,{"className":"mt-12","children":["$","$L10",null,{"url":"https://abstractalgorithms.github.io/posts/ai-101-a-comprehensive-introduction-to-artificial-intelligence-fundamentals","title":"AI 101: A Comprehensive Introduction to Artificial Intelligence Fundamentals","description":"Meet your personal super-smart assistant - AI! It's like a magic recipe book that helps machines make smart choices and solve problems on their own, freeing you to focus on what matters most. Think virtual assistants, self-driving cars, and more - but what else can AI do? Let's find out.","image":"https://abstractalgorithms.github.io/posts/ai-101-a-comprehensive-introduction-to-artificial-intelligence-fundamentals/assets/overview-600x400.jpg"}]}],["$","div",null,{"className":"mt-16","children":[["$","h2",null,{"className":"text-3xl font-bold text-slate-900 mb-8 text-center","children":"Related Articles"}],["$","$L11",null,{"posts":[{"slug":"array-basics-java","id":"array-basics-java-20250718","title":"Array Data Structure: Basics, Design, and Java Implementation","date":"2025-07-18","excerpt":"Learn the fundamentals of the array data structure, allowed operations, Java implementation, and see where arrays are used in advanced algorithms.","content":"$12","author":"Abstract Algorithms","tags":["array","data-structures","java","interview-prep"],"categories":[],"readingTime":"2 min read","coverImage":"/posts/array-basics-java/assets/array-overview-600x400.jpg","status":"published","type":"post"},{"slug":"bst-basics-java","id":"bst-basics-java-20250718","title":"Binary Search Tree (BST) Data Structure: Basics, Design, and Java Implementation","date":"2025-07-18","excerpt":"Learn the fundamentals of the binary search tree (BST) data structure, allowed operations, Java implementation, and see where BSTs are used in advanced algorithms.","content":"$13","author":"Abstract Algorithms","tags":["bst","binary-search-tree","data-structures","java","interview-prep"],"categories":[],"readingTime":"3 min read","coverImage":"/posts/bst-basics-java/assets/bst-overview-600x400.jpg","status":"published","type":"post"},{"slug":"circularqueue-basics-java","id":"circularqueue-basics-java-20250718","title":"Circular Queue Data Structure: Basics, Design, and Java Implementation","date":"2025-07-18","excerpt":"Learn the fundamentals of the circular queue data structure, allowed operations, Java implementation, and see where circular queues are used in advanced algorithms.","content":"$14","author":"Abstract Algorithms","tags":["circular-queue","data-structures","java","interview-prep"],"categories":[],"readingTime":"3 min read","coverImage":"/posts/circularqueue-basics-java/assets/circularqueue-overview-600x400.jpg","status":"published","type":"post"},{"slug":"deque-basics-java","id":"deque-basics-java-20250718","title":"Deque Data Structure: Basics, Design, and Java Implementation","date":"2025-07-18","excerpt":"Learn the fundamentals of the deque (double-ended queue) data structure, allowed operations, Java implementation, and see where deques are used in advanced algorithms.","content":"$15","author":"Abstract Algorithms","tags":["deque","data-structures","java","interview-prep"],"categories":[],"readingTime":"3 min read","coverImage":"/posts/deque-basics-java/assets/deque-overview-600x400.jpg","status":"published","type":"post"},{"slug":"doublylinkedlist-basics-java","id":"doublylinkedlist-basics-java-20250718","title":"Doubly Linked List Data Structure: Basics, Design, and Java Implementation","date":"2025-07-18","excerpt":"Learn the fundamentals of the doubly linked list data structure, allowed operations, Java implementation, and see where doubly linked lists are used in advanced algorithms.","content":"$16","author":"Abstract Algorithms","tags":["doubly-linked-list","data-structures","java","interview-prep"],"categories":[],"readingTime":"3 min read","coverImage":"/posts/doublylinkedlist-basics-java/assets/doublylinkedlist-overview-600x400.jpg","status":"published","type":"post"},{"slug":"fenwicktree-basics-java","id":"fenwicktree-basics-java-20250718","title":"Fenwick Tree (Binary Indexed Tree) Data Structure: Basics, Design, and Java Implementation","date":"2025-07-18","excerpt":"Learn the fundamentals of the Fenwick tree (binary indexed tree) data structure, allowed operations, Java implementation, and see where Fenwick trees are used in advanced algorithms.","content":"$17","author":"Abstract Algorithms","tags":["fenwick-tree","binary-indexed-tree","data-structures","java","interview-prep"],"categories":[],"readingTime":"2 min read","coverImage":"/posts/fenwicktree-basics-java/assets/fenwicktree-overview-600x400.jpg","status":"published","type":"post"}]}]]}],["$","div",null,{"className":"mt-16","children":["$","div",null,{"className":"bg-white/80 backdrop-blur-sm rounded-2xl p-8 border border-slate-200/50 shadow-lg shadow-slate-100/30","children":[["$","h3",null,{"className":"text-2xl font-bold text-slate-900 mb-6","children":"Discussion"}],["$","$L18",null,{}]]}]}]]}],["$","script",null,{"type":"application/ld+json","dangerouslySetInnerHTML":{"__html":"$19"}}]]}]
b:[["$","meta","0",{"name":"viewport","content":"width=device-width, initial-scale=1"}],["$","meta","1",{"charSet":"utf-8"}],["$","title","2",{"children":"AI 101: A Comprehensive Introduction to Artificial Intelligence Fundamentals | AbstractAlgorithms"}],["$","meta","3",{"name":"description","content":"Meet your personal super-smart assistant - AI! It's like a magic recipe book that helps machines make smart choices and solve problems on their own, freeing you to focus on what matters most. Think virtual assistants, self-driving cars, and more - but what else can AI do? Let's find out."}],["$","meta","4",{"name":"author","content":"Abstract Algorithms"}],["$","meta","5",{"name":"keywords","content":"algorithms,data structures,system design,software engineering,programming,computer science,performance optimization,big o notation,hash tables,database indexing"}],["$","meta","6",{"name":"creator","content":"Abstract Algorithms"}],["$","meta","7",{"name":"publisher","content":"Abstract Algorithms"}],["$","meta","8",{"name":"robots","content":"index, follow"}],["$","meta","9",{"name":"googlebot","content":"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"}],["$","meta","10",{"property":"og:title","content":"AI 101: A Comprehensive Introduction to Artificial Intelligence Fundamentals"}],["$","meta","11",{"property":"og:description","content":"Meet your personal super-smart assistant - AI! It's like a magic recipe book that helps machines make smart choices and solve problems on their own, freeing you to focus on what matters most. Think virtual assistants, self-driving cars, and more - but what else can AI do? Let's find out."}],["$","meta","12",{"property":"og:type","content":"article"}],["$","meta","13",{"property":"article:published_time","content":"2025-06-29"}],["$","meta","14",{"property":"article:author","content":"Abstract Algorithms"}],["$","meta","15",{"name":"twitter:card","content":"summary_large_image"}],["$","meta","16",{"name":"twitter:title","content":"Abstract Algorithms"}],["$","meta","17",{"name":"twitter:description","content":"A comprehensive blog about algorithms, data structures, system design, and software engineering best practices"}],["$","link","18",{"rel":"shortcut icon","href":"/logo/favicon-32x32.png"}],["$","link","19",{"rel":"icon","href":"/logo/favicon-16x16.png","type":"image/png","sizes":"16x16"}],["$","link","20",{"rel":"icon","href":"/logo/favicon-32x32.png","type":"image/png","sizes":"32x32"}],["$","link","21",{"rel":"icon","href":"/logo/favicon-48x48.png","type":"image/png","sizes":"48x48"}],["$","link","22",{"rel":"icon","href":"/logo/favicon-96x96.png","type":"image/png","sizes":"96x96"}],["$","link","23",{"rel":"icon","href":"/logo/favicon-192x192.png","type":"image/png","sizes":"192x192"}],["$","link","24",{"rel":"icon","href":"/favicon.ico","type":"image/x-icon"}],["$","link","25",{"rel":"apple-touch-icon","href":"/logo/favicon-192x192.png","type":"image/png","sizes":"192x192"}],["$","meta","26",{"name":"next-size-adjust"}]]
1:null
