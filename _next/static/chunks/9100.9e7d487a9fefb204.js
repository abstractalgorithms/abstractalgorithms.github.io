"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[9100],{6855:function(e,r,n){n.d(r,{Z:function(){return l}});var i=n(57437),a=n(2265),t=n(33145);let s={original:{width:1200,height:800},large:{width:800,height:533},medium:{width:600,height:400},small:{width:400,height:267},thumbnail:{width:300,height:200}};function l(e){let{src:r,alt:n,className:l="",priority:d=!1,fill:c=!1,sizes:o="(max-width: 400px) 300px, (max-width: 768px) 600px, (max-width: 1024px) 800px, 1200px",postSlug:h}=e,[x,u]=(0,a.useState)(!1),[g,j]=(0,a.useState)(1);(0,a.useEffect)(()=>{let e=document.createElement("img");e.onload=e.onerror=()=>{u(2===e.height)},e.src="data:image/webp;base64,UklGRjoAAABXRUJQVlA4IC4AAACyAgCdASoCAAIALmk0mk0iIiIiIgBoSygABc6WWgAA/veff/0PP8bA//LwYAAA",j(window.devicePixelRatio||1);let r=()=>j(window.devicePixelRatio||1);return window.addEventListener("resize",r),()=>window.removeEventListener("resize",r)},[]);let m=e=>{if(h)return h;let r=e.match(/\/posts\/([^\/]+)\/assets\//);if(r)return r[1];throw Error("postSlug is required when src is a filename or relative path")},f=e=>(e.split("/").pop()||e).replace(/\.[^.]+$/,""),p=()=>{try{let e=m(r),n=f(r),i=x?"webp":"jpg";return Object.entries(s).map(r=>{let[a,t]=r,s="".concat(n,"-").concat(t.width,"x").concat(t.height,".").concat(i),l="/posts/".concat(e,"/assets/").concat(s);return"".concat(l," ").concat(t.width,"w")}).join(", ")}catch(e){return console.warn("Failed to generate srcSet:",e),""}},y=()=>{try{let e=m(r),n=f(r),{width:i,height:a}=s.medium,t="".concat(n,"-").concat(i,"x").concat(a,".").concat(x?"webp":"jpg");return"/posts/".concat(e,"/assets/").concat(t)}catch(e){return console.warn("Failed to generate src, falling back to original:",e),r}};return c?(0,i.jsx)(t.default,{src:y(),alt:n,fill:!0,className:l,priority:d,sizes:o,style:{objectFit:"cover"}}):(0,i.jsxs)("picture",{className:"block mx-auto ".concat(l),style:{display:"block",marginLeft:"auto",marginRight:"auto",textAlign:"center",maxWidth:"100%"},children:[x&&(0,i.jsx)("source",{srcSet:p(),sizes:o,type:"image/webp"}),(0,i.jsx)("source",{srcSet:p().replace(/\.webp/g,".jpg"),sizes:o,type:"image/jpeg"}),(0,i.jsx)("img",{src:y(),alt:n,loading:d?"eager":"lazy",decoding:"async",style:{width:"100%",height:"auto",display:"block",marginLeft:"auto",marginRight:"auto",maxWidth:"100%"}})]})}},79100:function(e,r,n){n.r(r),n.d(r,{default:function(){return c},frontmatter:function(){return s},metadata:function(){return l}});var i=n(57437),a=n(75595),t=n(6855);let s=void 0,l={id:"9l8m1h4i-5j6k-9g7f-4h8i-9j0k1l2m3n4o",slug:"modified-binary-search-interview-analysis-java",title:"Modified Binary Search: Interview Scenarios, Analysis, and Java Implementation",date:"2025-07-16",excerpt:"Master modified binary search for rotated arrays and advanced search problems. Java code, scenarios, and interview tips.",author:"Abstract Algorithms",tags:["binary-search","algorithms","interview-prep","java"],status:"published",coverImage:"./assets/overview-600x400.jpg"};function d(e){let r={a:"a",blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,a.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(r.blockquote,{children:["\n",(0,i.jsxs)(r.p,{children:[(0,i.jsx)(r.strong,{children:"TLDR:"})," Modified Binary Search is a must-know interview pattern. This guide covers what it is, how to implement it in Java, common pitfalls, complexity analysis, real-world use cases, and pro tips to impress interviewers."]}),"\n"]}),"\n",(0,i.jsx)(r.p,{children:(0,i.jsx)(r.strong,{children:"Navigation:"})}),"\n",(0,i.jsx)(t.Z,{src:"modified-binary-search-diagram.png",alt:"Modified Binary Search Visual Diagram",postSlug:"modified-binary-search-interview-analysis-java"}),"\n",(0,i.jsx)("small",{children:(0,i.jsx)("em",{children:"Visual: Modified Binary Search in a Rotated Array"})}),"\n",(0,i.jsx)(r.p,{children:(0,i.jsx)(r.strong,{children:"Navigation:"})}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:(0,i.jsx)(r.a,{href:"#what-is-modified-binary-search-",children:"What is Modified Binary Search? \uD83D\uDE80"})}),"\n",(0,i.jsx)(r.li,{children:(0,i.jsx)(r.a,{href:"#visualizing-modified-binary-search",children:"Visualizing Modified Binary Search"})}),"\n",(0,i.jsx)(r.li,{children:(0,i.jsx)(r.a,{href:"#what-interviewers-look-for-",children:"What Interviewers Look For \uD83D\uDC40"})}),"\n",(0,i.jsx)(r.li,{children:(0,i.jsx)(r.a,{href:"#classic-implementations-in-java-",children:"Classic Implementations in Java \uD83D\uDCBB"})}),"\n",(0,i.jsx)(r.li,{children:(0,i.jsx)(r.a,{href:"#tabular-comparison-classic-vs-modified-binary-search",children:"Tabular Comparison: Classic vs. Modified Binary Search"})}),"\n",(0,i.jsx)(r.li,{children:(0,i.jsx)(r.a,{href:"#performance--complexity-analysis",children:"Performance & Complexity Analysis"})}),"\n",(0,i.jsx)(r.li,{children:(0,i.jsx)(r.a,{href:"#common-pitfalls--advanced-tips-%EF%B8%8F",children:"Common Pitfalls & Advanced Tips ⚠️"})}),"\n",(0,i.jsx)(r.li,{children:(0,i.jsx)(r.a,{href:"#real-world-analogies--use-cases-",children:"Real-World Analogies & Use Cases \uD83C\uDF0D"})}),"\n",(0,i.jsx)(r.li,{children:(0,i.jsx)(r.a,{href:"#common-interview-variants-",children:"Common Interview Variants \uD83E\uDDE9"})}),"\n",(0,i.jsx)(r.li,{children:(0,i.jsx)(r.a,{href:"#pro-tips-for-interviews-",children:"Pro Tips for Interviews \uD83D\uDCA1"})}),"\n",(0,i.jsx)(r.li,{children:(0,i.jsx)(r.a,{href:"#actionable-conclusion--next-steps-",children:"Actionable Conclusion & Next Steps ✅"})}),"\n"]}),"\n",(0,i.jsx)(r.hr,{}),"\n",(0,i.jsx)(r.h2,{children:"What is Modified Binary Search? \uD83D\uDE80"}),"\n",(0,i.jsx)(r.p,{children:"Modified Binary Search is an advanced search technique that adapts the classic binary search for non-standard scenarios, such as rotated sorted arrays, peak finding, and more. It's a staple for array and search-based interview questions, especially when the data is not perfectly sorted."}),"\n",(0,i.jsx)(r.p,{children:(0,i.jsx)(r.strong,{children:"Key Points:"})}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:"Efficiently solves search problems where the array is rotated, contains duplicates, or has special structure."}),"\n",(0,i.jsx)(r.li,{children:"Recognizing when to adapt binary search is a critical interview skill."}),"\n"]}),"\n",(0,i.jsx)(r.hr,{}),"\n",(0,i.jsx)(r.h2,{children:"Visualizing Modified Binary Search"}),"\n",(0,i.jsx)(t.Z,{src:"rotated-array-example.png",alt:"Rotated Array Search Example",postSlug:"modified-binary-search-interview-analysis-java"}),"\n",(0,i.jsx)("small",{children:(0,i.jsx)("em",{children:"Diagram: Searching for 5 in a rotated array [4,5,6,7,0,1,2]"})}),"\n",(0,i.jsx)(r.hr,{}),"\n",(0,i.jsx)(r.h2,{children:"What Interviewers Look For \uD83D\uDC40"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:"Ability to recognize when a problem requires a binary search variant."}),"\n",(0,i.jsx)(r.li,{children:"Handling of edge cases (duplicates, boundaries, empty arrays)."}),"\n",(0,i.jsx)(r.li,{children:"Clear explanation of pointer logic and interval updates."}),"\n",(0,i.jsx)(r.li,{children:"Accurate time and space complexity analysis."}),"\n",(0,i.jsx)(r.li,{children:"Adaptability to new or unseen problem variations."}),"\n"]}),"\n",(0,i.jsx)(r.hr,{}),"\n",(0,i.jsx)(r.h2,{children:"Classic Implementations in Java \uD83D\uDCBB"}),"\n",(0,i.jsx)(r.h3,{children:"1. Search in Rotated Sorted Array"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-java",children:"// Search for a target in a rotated sorted array\r\n// Handles cases where the array is rotated at an unknown pivot\r\nint searchRotated(int[] arr, int target) {\r\n    int left = 0, right = arr.length - 1;\r\n    while (left <= right) {\r\n        int mid = left + (right - left) / 2; // Prevents integer overflow\r\n        if (arr[mid] == target) return mid; // Found target\r\n        // Check if left half is sorted\r\n        if (arr[left] <= arr[mid]) {\r\n            // Target is in the left half\r\n            if (target >= arr[left] && target < arr[mid]) right = mid - 1;\r\n            else left = mid + 1;\r\n        } else {\r\n            // Right half is sorted\r\n            if (target > arr[mid] && target <= arr[right]) left = mid + 1;\r\n            else right = mid - 1;\r\n        }\r\n    }\r\n    return -1; // Target not found\r\n}\n"})}),"\n",(0,i.jsx)(r.h3,{children:"2. Find Peak Element"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-java",children:"// Find a peak element in an array (element greater than neighbors)\r\n// Useful for mountain/valley problems\r\nint findPeak(int[] arr) {\r\n    int left = 0, right = arr.length - 1;\r\n    while (left < right) {\r\n        int mid = left + (right - left) / 2;\r\n        // If mid is less than next, peak is to the right\r\n        if (arr[mid] < arr[mid + 1]) left = mid + 1;\r\n        else right = mid; // Peak is at mid or to the left\r\n    }\r\n    return left; // Index of a peak\r\n}\n"})}),"\n",(0,i.jsx)(r.h3,{children:"3. Search in 2D Matrix"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-java",children:"// Search for a value in a sorted 2D matrix\r\n// Each row and column is sorted\r\nboolean searchMatrix(int[][] matrix, int target) {\r\n    int m = matrix.length, n = m == 0 ? 0 : matrix[0].length;\r\n    int row = 0, col = n - 1;\r\n    while (row < m && col >= 0) {\r\n        if (matrix[row][col] == target) return true; // Found\r\n        else if (matrix[row][col] > target) col--; // Move left\r\n        else row++; // Move down\r\n    }\r\n    return false; // Not found\r\n}\n"})}),"\n",(0,i.jsx)(r.h3,{children:"4. Find First/Last Occurrence"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-java",children:"// Find first occurrence of target in sorted array\r\n// Useful for counting occurrences or range queries\r\nint findFirst(int[] arr, int target) {\r\n    int left = 0, right = arr.length - 1, res = -1;\r\n    while (left <= right) {\r\n        int mid = left + (right - left) / 2;\r\n        if (arr[mid] == target) {\r\n            res = mid; // Record result\r\n            right = mid - 1; // Search left for earlier occurrence\r\n        } else if (arr[mid] < target) left = mid + 1;\r\n        else right = mid - 1;\r\n    }\r\n    return res;\r\n}\n"})}),"\n",(0,i.jsx)(r.hr,{}),"\n",(0,i.jsx)(r.h2,{children:"Tabular Comparison: Classic vs. Modified Binary Search"}),"\n",(0,i.jsxs)(r.table,{children:[(0,i.jsx)(r.thead,{children:(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.th,{children:"Feature"}),(0,i.jsx)(r.th,{children:"Classic Binary Search"}),(0,i.jsx)(r.th,{children:"Modified Binary Search (Rotated/Advanced)"})]})}),(0,i.jsxs)(r.tbody,{children:[(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:"Input Array"}),(0,i.jsx)(r.td,{children:"Sorted (ascending/descending)"}),(0,i.jsx)(r.td,{children:"Rotated, partially sorted, or special"})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:"Use Case"}),(0,i.jsx)(r.td,{children:"Find element in sorted array"}),(0,i.jsx)(r.td,{children:"Rotated arrays, peaks, 2D, duplicates"})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:"Time Complexity"}),(0,i.jsx)(r.td,{children:"O(log n)"}),(0,i.jsx)(r.td,{children:"O(log n) (may degrade with duplicates)"})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:"Handles Duplicates"}),(0,i.jsx)(r.td,{children:"No (basic)"}),(0,i.jsx)(r.td,{children:"Yes (with extra logic)"})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:"Handles Rotations"}),(0,i.jsx)(r.td,{children:"No"}),(0,i.jsx)(r.td,{children:"Yes"})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:"Pointer Logic"}),(0,i.jsx)(r.td,{children:"Simple"}),(0,i.jsx)(r.td,{children:"Requires careful interval checks"})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:"Common Pitfalls"}),(0,i.jsx)(r.td,{children:"Off-by-one, overflow"}),(0,i.jsx)(r.td,{children:"Duplicates, ambiguous intervals"})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:"Real-World Analogy"}),(0,i.jsx)(r.td,{children:"Phonebook search"}),(0,i.jsx)(r.td,{children:"Rotated bookshelf, mountain peak finding"})]})]})]}),"\n",(0,i.jsx)(r.hr,{}),"\n",(0,i.jsx)(r.h2,{children:"Performance & Complexity Analysis"}),"\n",(0,i.jsx)(r.h3,{children:"Time Complexity"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Search in Rotated Array:"})," O(log n) in most cases. If duplicates are present, worst-case can degrade to O(n)."]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Find Peak Element:"})," O(log n) due to halving the search space each iteration."]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Search in 2D Matrix:"})," O(m + n) for staircase search; O(log(mn)) if flattened."]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Find First/Last Occurrence:"})," O(log n)."]}),"\n"]}),"\n",(0,i.jsx)(r.h3,{children:"Space Complexity"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:"All algorithms above use O(1) extra space (in-place pointer manipulation)."}),"\n"]}),"\n",(0,i.jsx)(r.h3,{children:"Practical Performance Considerations"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Cache Locality:"})," Binary search is cache-friendly due to sequential memory access."]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Edge Cases:"})," Arrays with many duplicates or pathological rotations may degrade performance."]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Overflow:"})," Always use ",(0,i.jsx)(r.code,{children:"mid = left + (right - left) / 2"})," to avoid integer overflow."]}),"\n"]}),"\n",(0,i.jsx)(r.hr,{}),"\n",(0,i.jsx)(r.h2,{children:"Common Pitfalls & Advanced Tips ⚠️"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Handling Duplicates:"})," Some problems require extra logic for duplicates (e.g., rotated array with duplicates)."]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Non-Standard Boundaries:"})," Be careful with left/right updates and off-by-one errors."]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Empty or Single-Element Arrays:"})," Always check for these edge cases."]}),"\n"]}),"\n",(0,i.jsx)(r.h3,{children:"Example: Rotated Array with Duplicates"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-java",children:"// Search in rotated array with duplicates\r\n// Handles ambiguous intervals by shrinking bounds\r\nboolean searchWithDuplicates(int[] arr, int target) {\r\n    int left = 0, right = arr.length - 1;\r\n    while (left <= right) {\r\n        int mid = left + (right - left) / 2;\r\n        if (arr[mid] == target) return true;\r\n        // If duplicates at both ends, shrink bounds\r\n        if (arr[left] == arr[mid] && arr[mid] == arr[right]) {\r\n            left++; right--;\r\n        } else if (arr[left] <= arr[mid]) {\r\n            if (target >= arr[left] && target < arr[mid]) right = mid - 1;\r\n            else left = mid + 1;\r\n        } else {\r\n            if (target > arr[mid] && target <= arr[right]) left = mid + 1;\r\n            else right = mid - 1;\r\n        }\r\n    }\r\n    return false;\r\n}\n"})}),"\n",(0,i.jsx)(r.hr,{}),"\n",(0,i.jsx)(r.h2,{children:"Real-World Analogies & Use Cases \uD83C\uDF0D"}),"\n",(0,i.jsx)(r.h3,{children:"1. Rotated Bookshelf Analogy"}),"\n",(0,i.jsx)(r.p,{children:"Imagine a bookshelf where the books are sorted by title, but the shelf has been rotated at some pivot. To find a book, you can't just start at one end—you need to figure out where the rotation happened and adapt your search. Modified binary search does exactly this!"}),"\n",(0,i.jsx)(r.h3,{children:"2. Mountain Peak Finder"}),"\n",(0,i.jsx)(r.p,{children:"Finding a peak in an array is like hiking a mountain range: you keep moving towards the higher neighbor until you reach the summit. Binary search for peaks is fast and avoids unnecessary climbs."}),"\n",(0,i.jsx)(r.h3,{children:"3. Database Indexing"}),"\n",(0,i.jsx)(r.p,{children:"Databases often use modified binary search to quickly locate records in partitioned or rotated indexes, ensuring fast lookups even when data isn't perfectly sorted."}),"\n",(0,i.jsx)(r.h3,{children:"4. Version Control Systems"}),"\n",(0,i.jsx)(r.p,{children:"Finding the first bad commit is like narrowing down a bug in a timeline—binary search quickly finds the transition point."}),"\n",(0,i.jsx)(r.hr,{}),"\n",(0,i.jsx)(r.h2,{children:"Common Interview Variants \uD83E\uDDE9"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:(0,i.jsx)(r.strong,{children:"Search in Rotated Sorted Array"})}),"\n",(0,i.jsx)(r.li,{children:(0,i.jsx)(r.strong,{children:"Find Minimum in Rotated Array"})}),"\n",(0,i.jsx)(r.li,{children:(0,i.jsx)(r.strong,{children:"Find Peak Element"})}),"\n",(0,i.jsx)(r.li,{children:(0,i.jsx)(r.strong,{children:"Search in 2D Matrix"})}),"\n",(0,i.jsx)(r.li,{children:(0,i.jsx)(r.strong,{children:"Find First/Last Occurrence"})}),"\n"]}),"\n",(0,i.jsx)(r.hr,{}),"\n",(0,i.jsx)(r.h2,{children:"Pro Tips for Interviews \uD83D\uDCA1"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Clarify constraints:"})," Ask about array size, duplicates, and value ranges."]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Draw search intervals:"})," Visualize how left/right pointers move at each step."]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Explain your approach:"})," Walk through a small example out loud."]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Handle edge cases:"})," Always check for empty or single-element arrays."]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Practice coding pointer logic:"})," Interviewers value clarity and pointer safety."]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Link to Related Patterns:"})," See ",(0,i.jsx)(r.a,{href:"../2025-07-16-sliding-window-technique-interview-analysis-java.md",children:"Sliding Window Technique"})," and ",(0,i.jsx)(r.a,{href:"../2025-07-16-two-pointers-technique-interview-analysis-java.md",children:"Two Pointers Technique"})," for more array strategies."]}),"\n"]}),"\n",(0,i.jsx)(r.hr,{}),"\n",(0,i.jsx)(r.h2,{children:"Actionable Conclusion & Next Steps ✅"}),"\n",(0,i.jsx)(r.p,{children:"Modified Binary Search is a must-have tool for technical interviews and real-world systems. To master it:"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Practice"}),": Implement all variants (rotated, duplicates, 2D, peaks) in your favorite language."]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Visualize"}),": Draw pointer movements and array states for tricky cases."]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Review"}),": Study edge cases and common pitfalls."]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Explore"}),": Try related problems on LeetCode, HackerRank, or GeeksforGeeks."]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Connect"}),": Read more about ",(0,i.jsx)(r.a,{href:"../2025-07-16-top-k-elements-interview-analysis-java.md",children:"Top K Elements"})," and ",(0,i.jsx)(r.a,{href:"../2025-07-16-overlapping-intervals-interview-analysis-java.md",children:"Overlapping Intervals"})," for advanced search and interval problems."]}),"\n"]}),"\n",(0,i.jsx)(r.p,{children:(0,i.jsx)(r.strong,{children:"Keep practicing, keep explaining, and you'll ace your next interview!"})}),"\n",(0,i.jsx)(r.hr,{}),"\n",(0,i.jsxs)(r.p,{children:[(0,i.jsx)(r.strong,{children:"Summary:"}),"\r\nModified Binary Search is a staple of technical interviews. Master the classic patterns, understand edge cases, and practice explaining your logic. Clear thinking and pointer safety will set you apart!"]})]})}function c(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:r}={...(0,a.a)(),...e.components};return r?(0,i.jsx)(r,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},75595:function(e,r,n){n.d(r,{a:function(){return t}});var i=n(2265);let a=i.createContext({});function t(e){let r=i.useContext(a);return i.useMemo(function(){return"function"==typeof e?e(r):{...r,...e}},[r,e])}}}]);