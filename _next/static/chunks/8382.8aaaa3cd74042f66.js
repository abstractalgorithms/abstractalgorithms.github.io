"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[8382],{28382:function(e,n,r){r.r(n),r.d(n,{default:function(){return l},frontmatter:function(){return t},metadata:function(){return a}});var i=r(57437),s=r(75595);let t=void 0,a={id:"fenwicktree-basics-java-20250718",slug:"fenwicktree-basics-java",title:"Fenwick Tree (Binary Indexed Tree) Data Structure: Basics, Design, and Java Implementation",date:"2025-07-18",excerpt:"Learn the fundamentals of the Fenwick tree (binary indexed tree) data structure, allowed operations, Java implementation, and see where Fenwick trees are used in advanced algorithms.",author:"Abstract Algorithms",tags:["fenwick-tree","binary-indexed-tree","data-structures","java","interview-prep"],status:"published",coverImage:"./assets/fenwicktree-overview-600x400.jpg"};function c(e){let n={a:"a",blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"TLDR:"})," Fenwick trees (binary indexed trees) efficiently support prefix sum queries and updates, making them ideal for frequency and range problems. This guide covers Fenwick tree basics, allowed operations, Java implementation, and links to advanced posts using Fenwick trees."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Navigation:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#what-is-a-fenwick-tree-",children:"What is a Fenwick Tree? \uD83D\uDE80"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#allowed-operations",children:"Allowed Operations"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#how-to-design-a-fenwick-tree-in-java-",children:"How to Design a Fenwick Tree in Java \uD83D\uDCBB"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#where-fenwick-trees-are-used-",children:"Where Fenwick Trees Are Used \uD83E\uDDE9"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#pro-tips-for-interviews-",children:"Pro Tips for Interviews \uD83D\uDCA1"})}),"\n"]}),"\n",(0,i.jsx)(n.h2,{children:"What is a Fenwick Tree? \uD83D\uDE80"}),"\n",(0,i.jsx)(n.p,{children:"A Fenwick tree (binary indexed tree) is a data structure that efficiently supports prefix sum queries and updates on arrays. It uses bit manipulation to achieve O(log n) time for both operations."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Purpose:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Efficient prefix sum/range queries"}),"\n",(0,i.jsx)(n.li,{children:"Efficient point updates"}),"\n",(0,i.jsx)(n.li,{children:"Used in frequency and range query problems"}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{children:"Allowed Operations"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"build(arr):"})," Build the Fenwick tree from an array"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"query(i):"})," Query the prefix sum up to index i"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"update(i, x):"})," Add x to the value at index i"]}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{children:"How to Design a Fenwick Tree in Java \uD83D\uDCBB"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Approach:"}),"\r\nUse an array to store cumulative frequencies. Use bit manipulation to traverse parent/child relationships."]}),"\n",(0,i.jsx)(n.h3,{children:"Custom Fenwick Tree Implementation"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:"class FenwickTree {\r\n    private int[] tree;\r\n    private int n;\r\n    public FenwickTree(int n) {\r\n        this.n = n;\r\n        tree = new int[n + 1];\r\n    }\r\n    public void update(int i, int delta) {\r\n        for (++i; i <= n; i += i & -i) tree[i] += delta;\r\n    }\r\n    public int query(int i) {\r\n        int sum = 0;\r\n        for (++i; i > 0; i -= i & -i) sum += tree[i];\r\n        return sum;\r\n    }\r\n}\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{children:"Where Fenwick Trees Are Used \uD83E\uDDE9"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/posts/genai-mastery-series/part-9",children:"Prefix Sum and Frequency Problems"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/posts/genai-mastery-series/part-11",children:"Range Query and Update Problems"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/posts/genai-mastery-series/part-12",children:"Competitive Programming"})}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{children:"Pro Tips for Interviews \uD83D\uDCA1"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Draw tree structure for each operation"}),"\n",(0,i.jsx)(n.li,{children:"Know time/space complexity for operations"}),"\n",(0,i.jsx)(n.li,{children:"Practice both query and update operations"}),"\n",(0,i.jsx)(n.li,{children:"Use Fenwick trees for prefix sum and frequency problems"}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Summary:"}),"\r\nFenwick trees are essential for prefix sum and frequency problems. Master the basics, understand allowed operations, and practice implementing Fenwick trees in Java to build a strong foundation."]})]})}function l(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},75595:function(e,n,r){r.d(n,{a:function(){return t}});var i=r(2265);let s=i.createContext({});function t(e){let n=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}}}]);