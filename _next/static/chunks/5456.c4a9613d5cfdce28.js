"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[5456],{25456:function(e,n,r){r.r(n),r.d(n,{default:function(){return c},frontmatter:function(){return i},metadata:function(){return a}});var s=r(57437),t=r(75595);let i=void 0,a={id:"6i5j8e1f-2g3h-6d4c-1e5f-6g7h8i9j0k1l",slug:"monotonic-stack-interview-analysis-java",title:"Monotonic Stack: Interview Scenarios, Analysis, and Java Implementation",date:"2025-07-16",excerpt:"Master monotonic stack for next greater/smaller element problems. Java code, scenarios, and interview tips.",author:"Abstract Algorithms",tags:["monotonic-stack","algorithms","interview-prep","java"],status:"published",coverImage:"./assets/overview-600x400.jpg"};function l(e){let n={a:"a",blockquote:"blockquote",code:"code",em:"em",h2:"h2",h3:"h3",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"TLDR:"})," Monotonic Stack is a must-know interview pattern. This guide covers what it is, how to implement it in Java, common pitfalls, complexity analysis, real-world use cases, and pro tips to impress interviewers."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Navigation:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#what-is-a-monotonic-stack-",children:"What is a Monotonic Stack? \uD83D\uDE80"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#monotonic-stack-vs-normal-stack-",children:"Monotonic Stack vs Normal Stack \uD83C\uDD9A"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#what-interviewers-look-for-",children:"What Interviewers Look For \uD83D\uDC40"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#classic-implementations-in-java-",children:"Classic Implementations in Java \uD83D\uDCBB"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#common-pitfalls--advanced-tips-%EF%B8%8F",children:"Common Pitfalls & Advanced Tips ⚠️"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#complexity-table-",children:"Complexity Table \uD83D\uDCCA"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#common-interview-variants-",children:"Common Interview Variants \uD83E\uDDE9"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#real-world-use-cases--problem-statements-",children:"Real-World Use Cases & Problem Statements \uD83C\uDF0D"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#pro-tips-for-interviews-",children:"Pro Tips for Interviews \uD83D\uDCA1"})}),"\n"]}),"\n",(0,s.jsx)(n.h2,{children:"What is a Monotonic Stack? \uD83D\uDE80"}),"\n",(0,s.jsx)(n.p,{children:"A monotonic stack is a stack that maintains its elements in either increasing or decreasing order. It’s a powerful tool for efficiently solving next greater/smaller element, range, and histogram problems in O(n) time."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Purpose:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Solve range and span problems efficiently"}),"\n",(0,s.jsx)(n.li,{children:"Reduce brute-force O(n^2) solutions to O(n)"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{children:"Monotonic Stack vs Normal Stack \uD83C\uDD9A"}),"\n",(0,s.jsx)(n.p,{children:"A normal stack is a general-purpose LIFO (Last-In-First-Out) data structure used for tasks like parsing, recursion, and undo operations. A monotonic stack, on the other hand, is a specialized stack that maintains its elements in a strictly increasing or decreasing order, enabling efficient solutions to range and span problems."}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Feature"}),(0,s.jsx)(n.th,{children:"Normal Stack"}),(0,s.jsx)(n.th,{children:"Monotonic Stack"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Order Maintained"}),(0,s.jsx)(n.td,{children:"None (arbitrary)"}),(0,s.jsx)(n.td,{children:"Increasing or Decreasing"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Use Cases"}),(0,s.jsx)(n.td,{children:"Recursion, parsing, undo"}),(0,s.jsx)(n.td,{children:"Next greater/smaller, range queries"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Time Complexity"}),(0,s.jsx)(n.td,{children:"O(1) push/pop"}),(0,s.jsx)(n.td,{children:"O(1) push/pop, O(n) for full traversal"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Problem Patterns"}),(0,s.jsx)(n.td,{children:"General"}),(0,s.jsx)(n.td,{children:"Range, span, histogram, temperatures"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Interview Focus"}),(0,s.jsx)(n.td,{children:"Stack basics"}),(0,s.jsx)(n.td,{children:"Advanced array/interval problems"})]})]})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Key Point:"}),"\r\nUse a monotonic stack when you need to maintain order for efficient range queries or next greater/smaller element problems. Use a normal stack for general LIFO operations."]}),"\n",(0,s.jsx)(n.h2,{children:"What Interviewers Look For \uD83D\uDC40"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Can you maintain stack order (increasing/decreasing) for the problem?"}),"\n",(0,s.jsx)(n.li,{children:"Do you handle edge cases (duplicates, circular arrays, empty input)?"}),"\n",(0,s.jsx)(n.li,{children:"Can you analyze time and space complexity?"}),"\n",(0,s.jsx)(n.li,{children:"Can you adapt the pattern to new problems?"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{children:"Classic Implementations in Java \uD83D\uDCBB"}),"\n",(0,s.jsx)(n.h3,{children:"1. Next Greater Element"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Approach:"}),"\r\nUse a stack to keep track of indices whose next greater element hasn't been found yet. As you iterate, pop indices from the stack while the current element is greater, and set their result. Push the current index onto the stack. This ensures each element is processed at most twice (push and pop)."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"// For each element, find the next greater element to its right\r\nint[] nextGreaterElements(int[] arr) {\r\n    int n = arr.length;\r\n    int[] result = new int[n];\r\n    Arrays.fill(result, -1);\r\n    Stack<Integer> stack = new Stack<>();\r\n    for (int i = 0; i < n; i++) {\r\n        while (!stack.isEmpty() && arr[i] > arr[stack.peek()]) {\r\n            result[stack.pop()] = arr[i];\r\n        }\r\n        stack.push(i);\r\n    }\r\n    return result;\r\n}\n"})}),"\n",(0,s.jsx)(n.h3,{children:"2. Largest Rectangle in Histogram"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Approach:"}),"\r\nUse a stack to keep track of indices of increasing bar heights. When a lower bar is found, pop from the stack and calculate the area for each popped bar as the smallest bar in the rectangle. This efficiently finds the largest rectangle for every possible height."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"// Find the area of the largest rectangle in a histogram\r\nint largestRectangleArea(int[] heights) {\r\n    Stack<Integer> stack = new Stack<>();\r\n    int maxArea = 0, n = heights.length;\r\n    for (int i = 0; i <= n; i++) {\r\n        int h = (i == n) ? 0 : heights[i];\r\n        while (!stack.isEmpty() && h < heights[stack.peek()]) {\r\n            int height = heights[stack.pop()];\r\n            int width = stack.isEmpty() ? i : i - stack.peek() - 1;\r\n            maxArea = Math.max(maxArea, height * width);\r\n        }\r\n        stack.push(i);\r\n    }\r\n    return maxArea;\r\n}\n"})}),"\n",(0,s.jsx)(n.h3,{children:"3. Daily Temperatures"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Approach:"}),"\r\nUse a stack to store indices of days with unresolved warmer temperatures. As you iterate, pop indices from the stack when a warmer day is found, and set the result as the difference in indices. Push the current day onto the stack."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"// For each day, find how many days until a warmer temperature\r\nint[] dailyTemperatures(int[] temps) {\r\n    int n = temps.length;\r\n    int[] result = new int[n];\r\n    Stack<Integer> stack = new Stack<>();\r\n    for (int i = 0; i < n; i++) {\r\n        while (!stack.isEmpty() && temps[i] > temps[stack.peek()]) {\r\n            int idx = stack.pop();\r\n            result[idx] = i - idx;\r\n        }\r\n        stack.push(i);\r\n    }\r\n    return result;\r\n}\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{children:"Common Pitfalls & Advanced Tips ⚠️"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Handling Duplicates:"})," Decide if equal values should be popped or kept."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Circular Arrays:"})," For problems like Next Greater Element II, loop twice."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Stack Initialization:"})," Always check for empty stack before peeking/popping."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{children:"Example: Next Greater Element II (Circular Array)"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Approach:"}),"\r\nTo handle circular arrays, iterate through the array twice (simulate wrapping around). Use a stack to track indices as before. Only push indices during the first pass to avoid duplicates."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"// Next greater element in a circular array\r\nint[] nextGreaterElementsII(int[] arr) {\r\n    int n = arr.length;\r\n    int[] result = new int[n];\r\n    Arrays.fill(result, -1);\r\n    Stack<Integer> stack = new Stack<>();\r\n    for (int i = 0; i < 2 * n; i++) {\r\n        int num = arr[i % n];\r\n        while (!stack.isEmpty() && num > arr[stack.peek()]) {\r\n            result[stack.pop()] = num;\r\n        }\r\n        if (i < n) stack.push(i);\r\n    }\r\n    return result;\r\n}\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{children:"Complexity Table \uD83D\uDCCA"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Problem"}),(0,s.jsx)(n.th,{children:"Time Complexity"}),(0,s.jsx)(n.th,{children:"Space Complexity"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Next Greater Element"}),(0,s.jsx)(n.td,{children:"O(n)"}),(0,s.jsx)(n.td,{children:"O(n)"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Largest Rectangle in Histogram"}),(0,s.jsx)(n.td,{children:"O(n)"}),(0,s.jsx)(n.td,{children:"O(n)"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Daily Temperatures"}),(0,s.jsx)(n.td,{children:"O(n)"}),(0,s.jsx)(n.td,{children:"O(n)"})]})]})]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{children:"Common Interview Variants \uD83E\uDDE9"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"Next Greater/Smaller Element"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"Largest Rectangle in Histogram"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"Daily Temperatures"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"Stock Span Problem"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"Trapping Rain Water"})}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{children:"Real-World Use Cases & Problem Statements \uD83C\uDF0D"}),"\n",(0,s.jsx)(n.p,{children:"Monotonic stack is not just for interviews—it's used in real systems! Here are some scenarios and analogies:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Stock Price Analysis:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.em,{children:"Problem Statement:"})," For each day, find the next day with a higher stock price."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.em,{children:"Why Monotonic Stack?"})," Like keeping a stack of receipts, you pop old prices as soon as a higher one appears."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Histogram Area Calculation:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.em,{children:"Problem Statement:"})," Find the largest rectangle in a skyline silhouette."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.em,{children:"Why Monotonic Stack?"})," Like stacking books of different heights, you can quickly find the widest area for each height."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Weather Forecasting:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.em,{children:"Problem Statement:"})," For each day, find how many days until it gets warmer."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.em,{children:"Why Monotonic Stack?"})," Like waiting in line for a sunny day, you pop off colder days as soon as a warmer one comes."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{children:"Pro Tips for Interviews \uD83D\uDCA1"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Clarify constraints:"})," Ask about array size, duplicates, and value ranges."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Draw stack changes:"})," Visualize how the stack evolves for each input."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Explain your approach:"})," Walk through a small example out loud."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Handle edge cases:"})," Always check for empty or single-element arrays."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Practice coding stack logic:"})," Interviewers value clarity and stack safety."]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Summary:"}),"\r\nMonotonic Stack is a staple of technical interviews. Master the classic patterns, understand edge cases, and practice explaining your logic. Clear thinking and stack safety will set you apart!"]})]})}function c(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}={...(0,t.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},75595:function(e,n,r){r.d(n,{a:function(){return i}});var s=r(2265);let t=s.createContext({});function i(e){let n=s.useContext(t);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}}}]);