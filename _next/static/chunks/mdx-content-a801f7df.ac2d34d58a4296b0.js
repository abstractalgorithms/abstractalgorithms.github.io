"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[7341],{2256:function(e,n,r){r.r(n),r.d(n,{default:function(){return d},frontmatter:function(){return a}});var s=r(7437),i=r(4229);let a=void 0;function t(e){let n={code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,i.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h2,{children:"MySQL Indexing Deep Dive"}),"\n",(0,s.jsx)(n.h3,{children:"InnoDB Storage Engine"}),"\n",(0,s.jsx)(n.p,{children:"MySQL's InnoDB engine uses clustered indexes by default:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"-- Primary key automatically becomes clustered index\r\nCREATE TABLE users (\r\n    id INT AUTO_INCREMENT PRIMARY KEY,  -- Clustered index\r\n    email VARCHAR(255) UNIQUE,          -- Secondary index\r\n    name VARCHAR(100),\r\n    age INT,\r\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\r\n    INDEX idx_email (email),            -- Explicit secondary index\r\n    INDEX idx_age_name (age, name)      -- Composite index\r\n);\n"})}),"\n",(0,s.jsx)(n.h3,{children:"MySQL Index Types and Syntax"}),"\n",(0,s.jsx)(n.h4,{children:"Single Column Indexes"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"-- Create index during table creation\r\nCREATE TABLE products (\r\n    id INT PRIMARY KEY,\r\n    name VARCHAR(255),\r\n    price DECIMAL(10,2),\r\n    category_id INT,\r\n    INDEX idx_price (price),\r\n    INDEX idx_category (category_id)\r\n);\r\n\r\n-- Add index to existing table\r\nALTER TABLE products ADD INDEX idx_name (name);\r\nCREATE INDEX idx_name_price ON products(name, price);\n"})}),"\n",(0,s.jsx)(n.h4,{children:"Composite Indexes (Multiple Columns)"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"-- Order matters! This index can efficiently handle:\r\n-- 1. WHERE category_id = ?\r\n-- 2. WHERE category_id = ? AND price > ?\r\n-- 3. WHERE category_id = ? AND price > ? AND name LIKE ?\r\nCREATE INDEX idx_category_price_name ON products(category_id, price, name);\r\n\r\n-- This won't efficiently use the above index:\r\nSELECT * FROM products WHERE price > 100;  -- Missing category_id prefix\n"})}),"\n",(0,s.jsx)(n.h4,{children:"Partial Indexes (Prefix Indexes)"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"-- Index only first 10 characters of name (saves space)\r\nCREATE INDEX idx_name_prefix ON products(name(10));\r\n\r\n-- Good for columns with long text values\r\nCREATE INDEX idx_description_prefix ON articles(description(50));\n"})}),"\n",(0,s.jsx)(n.h3,{children:"MySQL Index Optimization"}),"\n",(0,s.jsx)(n.h4,{children:"Using EXPLAIN to Analyze Queries"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"-- Analyze query execution plan\r\nEXPLAIN SELECT * FROM users WHERE age > 25 AND name LIKE 'John%';\r\n\r\n-- Extended explain with more details\r\nEXPLAIN FORMAT=JSON SELECT * FROM users WHERE email = 'john@example.com';\n"})}),"\n",(0,s.jsx)(n.h4,{children:"Index Hints"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"-- Force MySQL to use a specific index\r\nSELECT * FROM users USE INDEX (idx_age_name) WHERE age > 25;\r\n\r\n-- Suggest an index (MySQL may ignore)\r\nSELECT * FROM users USE INDEX (idx_age) WHERE age > 25 AND name LIKE 'J%';\r\n\r\n-- Force MySQL to ignore an index\r\nSELECT * FROM users IGNORE INDEX (idx_age) WHERE age > 25;\n"})}),"\n",(0,s.jsx)(n.h2,{children:"PostgreSQL Advanced Indexing"}),"\n",(0,s.jsx)(n.h3,{children:"PostgreSQL Index Types"}),"\n",(0,s.jsx)(n.h4,{children:"GiST (Generalized Search Tree)"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"-- Excellent for full-text search and geometric data\r\nCREATE INDEX idx_articles_content ON articles USING gist(to_tsvector('english', content));\r\n\r\n-- Range types and arrays\r\nCREATE INDEX idx_price_ranges ON products USING gist(price_range);\n"})}),"\n",(0,s.jsx)(n.h4,{children:"GIN (Generalized Inverted Index)"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"-- Perfect for JSONB, arrays, and full-text search\r\nCREATE INDEX idx_user_tags ON users USING gin(tags);  -- For array columns\r\nCREATE INDEX idx_user_metadata ON users USING gin(metadata);  -- For JSONB\r\n\r\n-- Full-text search\r\nCREATE INDEX idx_articles_search ON articles USING gin(to_tsvector('english', title || ' ' || content));\n"})}),"\n",(0,s.jsx)(n.h4,{children:"BRIN (Block Range Index)"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"-- Efficient for large tables with naturally ordered data\r\nCREATE INDEX idx_orders_date ON orders USING brin(order_date);\r\n\r\n-- Great for time-series data with minimal storage overhead\r\nCREATE INDEX idx_logs_timestamp ON application_logs USING brin(created_at);\n"})}),"\n",(0,s.jsx)(n.h3,{children:"PostgreSQL Partial Indexes"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"-- Index only active users (saves space and improves performance)\r\nCREATE INDEX idx_active_users_email ON users(email) WHERE status = 'active';\r\n\r\n-- Index only recent orders\r\nCREATE INDEX idx_recent_orders ON orders(customer_id) \r\nWHERE order_date >= '2024-01-01';\r\n\r\n-- Index only non-null values\r\nCREATE INDEX idx_users_phone ON users(phone) WHERE phone IS NOT NULL;\n"})}),"\n",(0,s.jsx)(n.h3,{children:"PostgreSQL Expression Indexes"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"-- Index on computed values\r\nCREATE INDEX idx_users_lower_email ON users(lower(email));\r\nCREATE INDEX idx_products_discounted_price ON products((price * 0.9)) WHERE on_sale = true;\r\n\r\n-- Functional index for complex queries\r\nCREATE INDEX idx_user_full_name ON users((first_name || ' ' || last_name));\n"})}),"\n",(0,s.jsx)(n.h2,{children:"SQL Server Indexing Strategies"}),"\n",(0,s.jsx)(n.h3,{children:"Clustered vs Non-Clustered Indexes"}),"\n",(0,s.jsx)(n.h4,{children:"Clustered Index Management"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"-- Create clustered index (only one per table)\r\nCREATE CLUSTERED INDEX idx_orders_date ON orders(order_date);\r\n\r\n-- Drop and recreate clustered index\r\nDROP INDEX idx_orders_date ON orders;\r\nCREATE CLUSTERED INDEX idx_orders_customer_date ON orders(customer_id, order_date);\n"})}),"\n",(0,s.jsx)(n.h4,{children:"Non-Clustered Indexes with Included Columns"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"-- Include additional columns at leaf level (covering index)\r\nCREATE NONCLUSTERED INDEX idx_users_email_covering \r\nON users(email) \r\nINCLUDE (first_name, last_name, phone);\r\n\r\n-- This query uses index-only scan (no key lookup needed)\r\nSELECT first_name, last_name, phone FROM users WHERE email = 'john@example.com';\n"})}),"\n",(0,s.jsx)(n.h3,{children:"SQL Server Index Features"}),"\n",(0,s.jsx)(n.h4,{children:"Filtered Indexes"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"-- Index only specific subset of data\r\nCREATE NONCLUSTERED INDEX idx_active_users \r\nON users(last_login_date) \r\nWHERE status = 'active' AND last_login_date IS NOT NULL;\n"})}),"\n",(0,s.jsx)(n.h4,{children:"Columnstore Indexes"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"-- For analytical workloads (OLAP)\r\nCREATE NONCLUSTERED COLUMNSTORE INDEX idx_sales_columnstore \r\nON sales(product_id, customer_id, sale_date, amount, quantity);\r\n\r\n-- Clustered columnstore for data warehouse tables\r\nCREATE CLUSTERED COLUMNSTORE INDEX idx_fact_sales ON fact_sales;\n"})}),"\n",(0,s.jsx)(n.h2,{children:"Oracle Database Indexing"}),"\n",(0,s.jsx)(n.h3,{children:"Oracle Index Types"}),"\n",(0,s.jsx)(n.h4,{children:"Function-Based Indexes"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"-- Index on expressions\r\nCREATE INDEX idx_users_upper_email ON users(UPPER(email));\r\nCREATE INDEX idx_orders_year ON orders(EXTRACT(YEAR FROM order_date));\r\n\r\n-- Complex function-based index\r\nCREATE INDEX idx_products_profit_margin ON products((price - cost) / price * 100);\n"})}),"\n",(0,s.jsx)(n.h4,{children:"Reverse Key Indexes"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"-- Distribute sequential inserts across index blocks\r\nCREATE INDEX idx_orders_id_reverse ON orders(order_id) REVERSE;\n"})}),"\n",(0,s.jsx)(n.h4,{children:"Bitmap Join Indexes"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"-- Pre-join dimension tables for star schema queries\r\nCREATE BITMAP INDEX idx_sales_customer_region \r\nON sales(customers.region)\r\nFROM sales, customers\r\nWHERE sales.customer_id = customers.customer_id;\n"})}),"\n",(0,s.jsx)(n.h2,{children:"Cross-Database Index Best Practices"}),"\n",(0,s.jsx)(n.h3,{children:"Index Naming Conventions"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"-- Consistent naming across databases\r\n-- Pattern: idx_[table]_[columns]_[type]\r\nCREATE INDEX idx_users_email_unique ON users(email);          -- Unique\r\nCREATE INDEX idx_orders_customer_date ON orders(customer_id, order_date);  -- Composite\r\nCREATE INDEX idx_products_name_partial ON products(name(20)); -- Partial/Prefix\r\nCREATE INDEX idx_logs_created_filtered ON logs(created_at) WHERE level = 'ERROR';  -- Filtered\n"})}),"\n",(0,s.jsx)(n.h3,{children:"Monitoring Index Usage"}),"\n",(0,s.jsx)(n.h4,{children:"MySQL"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"-- Check index usage statistics\r\nSELECT \r\n    TABLE_SCHEMA,\r\n    TABLE_NAME,\r\n    INDEX_NAME,\r\n    CARDINALITY,\r\n    SUB_PART\r\nFROM INFORMATION_SCHEMA.STATISTICS \r\nWHERE TABLE_SCHEMA = 'your_database';\r\n\r\n-- Performance Schema for index usage\r\nSELECT \r\n    object_schema,\r\n    object_name,\r\n    index_name,\r\n    count_read,\r\n    count_write,\r\n    sum_timer_read,\r\n    sum_timer_write\r\nFROM performance_schema.table_io_waits_summary_by_index_usage;\n"})}),"\n",(0,s.jsx)(n.h4,{children:"PostgreSQL"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"-- Index usage statistics\r\nSELECT \r\n    schemaname,\r\n    tablename,\r\n    indexname,\r\n    idx_scan,\r\n    idx_tup_read,\r\n    idx_tup_fetch\r\nFROM pg_stat_user_indexes;\r\n\r\n-- Unused indexes\r\nSELECT \r\n    schemaname,\r\n    tablename,\r\n    indexname,\r\n    idx_scan\r\nFROM pg_stat_user_indexes \r\nWHERE idx_scan = 0;\n"})}),"\n",(0,s.jsx)(n.h4,{children:"SQL Server"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"-- Index usage statistics\r\nSELECT \r\n    OBJECT_NAME(i.object_id) AS table_name,\r\n    i.name AS index_name,\r\n    dm_ius.user_seeks,\r\n    dm_ius.user_scans,\r\n    dm_ius.user_lookups,\r\n    dm_ius.user_updates\r\nFROM sys.indexes i\r\nLEFT JOIN sys.dm_db_index_usage_stats dm_ius \r\n    ON i.object_id = dm_ius.object_id AND i.index_id = dm_ius.index_id\r\nWHERE i.object_id = OBJECT_ID('your_table');\n"})}),"\n",(0,s.jsx)(n.h2,{children:"Common SQL Indexing Patterns"}),"\n",(0,s.jsx)(n.h3,{children:"Covering Indexes"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"-- Include all needed columns to avoid table lookups\r\n-- MySQL\r\nCREATE INDEX idx_users_email_covering ON users(email, first_name, last_name, phone);\r\n\r\n-- SQL Server with INCLUDE\r\nCREATE INDEX idx_users_email_covering ON users(email) INCLUDE (first_name, last_name, phone);\r\n\r\n-- PostgreSQL (covering through index-only scans)\r\nCREATE INDEX idx_users_email_names ON users(email, first_name, last_name);\n"})}),"\n",(0,s.jsx)(n.h3,{children:"Composite Index Column Order"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"-- Rule: Most selective column first, then by query patterns\r\n-- Good: High selectivity on email, then commonly filtered by status\r\nCREATE INDEX idx_users_email_status ON users(email, status);\r\n\r\n-- Consider query patterns:\r\n-- Query 1: WHERE email = ? AND status = ?     -- Uses index efficiently\r\n-- Query 2: WHERE status = ?                   -- Less efficient\r\n-- Query 3: WHERE email = ?                    -- Uses index efficiently\r\n\r\n-- Solution: Create multiple indexes for different query patterns\r\nCREATE INDEX idx_users_email ON users(email);\r\nCREATE INDEX idx_users_status ON users(status);\r\nCREATE INDEX idx_users_email_status ON users(email, status);  -- For combined queries\n"})}),"\n",(0,s.jsx)(n.h2,{children:"Index Maintenance and Optimization"}),"\n",(0,s.jsx)(n.h3,{children:"Rebuilding Indexes"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"-- MySQL\r\nOPTIMIZE TABLE users;\r\nALTER TABLE users ENGINE=InnoDB;  -- Rebuilds table and indexes\r\n\r\n-- PostgreSQL\r\nREINDEX INDEX idx_users_email;\r\nREINDEX TABLE users;\r\n\r\n-- SQL Server\r\nALTER INDEX idx_users_email ON users REBUILD;\r\nALTER INDEX ALL ON users REBUILD;\r\n\r\n-- Oracle\r\nALTER INDEX idx_users_email REBUILD;\n"})}),"\n",(0,s.jsx)(n.h3,{children:"Index Statistics"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"-- MySQL\r\nANALYZE TABLE users;\r\n\r\n-- PostgreSQL\r\nANALYZE users;\r\nANALYZE users(email);  -- Specific column\r\n\r\n-- SQL Server\r\nUPDATE STATISTICS users;\r\nUPDATE STATISTICS users idx_users_email;\r\n\r\n-- Oracle\r\nEXEC DBMS_STATS.GATHER_TABLE_STATS('schema', 'users');\n"})}),"\n",(0,s.jsx)(n.h2,{children:"Performance Tuning Tips"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Monitor Query Patterns"}),": Create indexes based on actual query patterns, not assumptions"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Avoid Over-Indexing"}),": Each index has maintenance overhead"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Use Composite Indexes Wisely"}),": Column order matters for query efficiency"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Regular Maintenance"}),": Keep statistics updated and rebuild fragmented indexes"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Test in Production-Like Environment"}),": Index performance varies with data size and distribution"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{children:"Next Steps"}),"\n",(0,s.jsx)(n.p,{children:"In Part 3, we'll explore NoSQL database indexing strategies, covering MongoDB, Cassandra, Redis, and other NoSQL systems with their unique indexing approaches."})]})}function d(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(t,{...e})}):t(e)}},2329:function(e,n,r){r.r(n),r.d(n,{default:function(){return d},frontmatter:function(){return a}});var s=r(7437),i=r(4229);let a=void 0;function t(e){let n={code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h2,{children:"MongoDB Indexing Strategies"}),"\n",(0,s.jsx)(n.h3,{children:"MongoDB Index Types"}),"\n",(0,s.jsx)(n.h4,{children:"Single Field Indexes"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'// Create index on a single field\r\ndb.users.createIndex({ "email": 1 })          // Ascending\r\ndb.users.createIndex({ "age": -1 })           // Descending\r\ndb.users.createIndex({ "status": 1 })\r\n\r\n// Query using single field index\r\ndb.users.find({ "email": "john@example.com" })\r\ndb.users.find({ "age": { $gte: 25 } }).sort({ "age": -1 })\n'})}),"\n",(0,s.jsx)(n.h4,{children:"Compound Indexes"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'// Create compound index (order matters!)\r\ndb.orders.createIndex({ "customer_id": 1, "order_date": -1, "status": 1 })\r\n\r\n// Efficient queries using compound index:\r\ndb.orders.find({ "customer_id": 123 })                                    // Uses index\r\ndb.orders.find({ "customer_id": 123, "order_date": { $gte: new Date() } }) // Uses index\r\ndb.orders.find({ "customer_id": 123, "order_date": -1, "status": "active" }) // Uses full index\r\n\r\n// Inefficient queries:\r\ndb.orders.find({ "order_date": { $gte: new Date() } })  // Can\'t use index efficiently\r\ndb.orders.find({ "status": "active" })                  // Can\'t use index efficiently\n'})}),"\n",(0,s.jsx)(n.h4,{children:"Text Indexes for Full-Text Search"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'// Create text index\r\ndb.articles.createIndex({ \r\n    "title": "text", \r\n    "content": "text" \r\n}, { \r\n    weights: { "title": 10, "content": 1 },\r\n    name: "article_text_index"\r\n})\r\n\r\n// Text search queries\r\ndb.articles.find({ $text: { $search: "database optimization" } })\r\ndb.articles.find({ \r\n    $text: { \r\n        $search: "\\"database indexes\\"",  // Exact phrase\r\n        $caseSensitive: false \r\n    } \r\n}).sort({ score: { $meta: "textScore" } })\n'})}),"\n",(0,s.jsx)(n.h4,{children:"Geospatial Indexes"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'// 2dsphere index for GeoJSON data\r\ndb.locations.createIndex({ "coordinates": "2dsphere" })\r\n\r\n// Geospatial queries\r\ndb.locations.find({\r\n    coordinates: {\r\n        $near: {\r\n            $geometry: { type: "Point", coordinates: [-122.4194, 37.7749] },\r\n            $maxDistance: 1000  // meters\r\n        }\r\n    }\r\n})\r\n\r\n// Geospatial aggregation\r\ndb.locations.aggregate([\r\n    {\r\n        $geoNear: {\r\n            near: { type: "Point", coordinates: [-122.4194, 37.7749] },\r\n            distanceField: "distance",\r\n            maxDistance: 5000,\r\n            spherical: true\r\n        }\r\n    }\r\n])\n'})}),"\n",(0,s.jsx)(n.h4,{children:"Partial Indexes"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'// Index only documents matching a condition\r\ndb.users.createIndex(\r\n    { "email": 1 }, \r\n    { partialFilterExpression: { "status": "active" } }\r\n)\r\n\r\n// Index only non-null values\r\ndb.products.createIndex(\r\n    { "discount_price": 1 },\r\n    { partialFilterExpression: { "discount_price": { $exists: true } } }\r\n)\n'})}),"\n",(0,s.jsx)(n.h4,{children:"Sparse Indexes"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'// Index only documents that contain the indexed field\r\ndb.users.createIndex({ "phone": 1 }, { sparse: true })\r\n\r\n// Useful for optional fields to save space\r\ndb.profiles.createIndex({ "linkedin_url": 1 }, { sparse: true })\n'})}),"\n",(0,s.jsx)(n.h3,{children:"MongoDB Index Performance"}),"\n",(0,s.jsx)(n.h4,{children:"Analyzing Query Performance"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'// Explain query execution\r\ndb.users.find({ "email": "john@example.com" }).explain("executionStats")\r\n\r\n// Index usage statistics\r\ndb.users.aggregate([{ $indexStats: {} }])\r\n\r\n// Get index information\r\ndb.users.getIndexes()\n'})}),"\n",(0,s.jsx)(n.h4,{children:"Index Hints"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'// Force use of specific index\r\ndb.users.find({ "age": { $gte: 25 } }).hint({ "age": 1 })\r\n\r\n// Use natural order (no index)\r\ndb.users.find().hint({ $natural: 1 })\n'})}),"\n",(0,s.jsx)(n.h2,{children:"Cassandra Indexing"}),"\n",(0,s.jsx)(n.h3,{children:"Primary Key and Clustering"}),"\n",(0,s.jsx)(n.h4,{children:"Partition Key and Clustering Columns"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"-- Table with compound primary key\r\nCREATE TABLE user_sessions (\r\n    user_id UUID,           -- Partition key\r\n    session_date DATE,      -- Clustering column\r\n    session_id TIMEUUID,    -- Clustering column\r\n    ip_address TEXT,\r\n    user_agent TEXT,\r\n    PRIMARY KEY (user_id, session_date, session_id)\r\n) WITH CLUSTERING ORDER BY (session_date DESC, session_id DESC);\r\n\r\n-- Efficient queries (follow primary key structure):\r\nSELECT * FROM user_sessions WHERE user_id = ?;\r\nSELECT * FROM user_sessions WHERE user_id = ? AND session_date = ?;\r\nSELECT * FROM user_sessions WHERE user_id = ? AND session_date >= ? AND session_date <= ?;\n"})}),"\n",(0,s.jsx)(n.h4,{children:"Secondary Indexes"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"-- Create secondary index\r\nCREATE INDEX idx_user_sessions_ip ON user_sessions(ip_address);\r\n\r\n-- Query using secondary index\r\nSELECT * FROM user_sessions WHERE ip_address = '192.168.1.100';\r\n\r\n-- Note: Secondary indexes in Cassandra have limitations:\r\n-- - Can be expensive for large datasets\r\n-- - Limited to equality comparisons\r\n-- - Should be used with other WHERE clauses when possible\n"})}),"\n",(0,s.jsx)(n.h4,{children:"Materialized Views"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"-- Create materialized view for different query patterns\r\nCREATE MATERIALIZED VIEW user_sessions_by_ip AS\r\n    SELECT user_id, session_date, session_id, ip_address, user_agent\r\n    FROM user_sessions\r\n    WHERE ip_address IS NOT NULL AND user_id IS NOT NULL \r\n          AND session_date IS NOT NULL AND session_id IS NOT NULL\r\n    PRIMARY KEY (ip_address, user_id, session_date, session_id);\r\n\r\n-- Query the materialized view\r\nSELECT * FROM user_sessions_by_ip WHERE ip_address = '192.168.1.100';\n"})}),"\n",(0,s.jsx)(n.h3,{children:"Cassandra Indexing Best Practices"}),"\n",(0,s.jsx)(n.h4,{children:"Avoid Anti-Patterns"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"-- BAD: Querying without partition key\r\nSELECT * FROM user_sessions WHERE session_date = '2024-03-20';  -- Requires ALLOW FILTERING\r\n\r\n-- BAD: Secondary index on high-cardinality column\r\nCREATE INDEX idx_sessions_id ON user_sessions(session_id);  -- Will be slow\r\n\r\n-- GOOD: Include partition key in queries\r\nSELECT * FROM user_sessions \r\nWHERE user_id = ? AND session_date = '2024-03-20';\r\n\r\n-- GOOD: Secondary index on low-cardinality column\r\nCREATE INDEX idx_sessions_status ON user_sessions(status);  -- If status has few values\n"})}),"\n",(0,s.jsx)(n.h2,{children:"Redis Indexing and Search"}),"\n",(0,s.jsx)(n.h3,{children:"Redis Search (RediSearch Module)"}),"\n",(0,s.jsx)(n.h4,{children:"Creating Indexes"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-redis",children:'# Create index for hash documents\r\nFT.CREATE user_idx \r\n    ON hash \r\n    PREFIX 1 "user:" \r\n    SCHEMA \r\n        name TEXT SORTABLE \r\n        email TEXT SORTABLE \r\n        age NUMERIC SORTABLE \r\n        city TAG SORTABLE\r\n        bio TEXT\r\n\r\n# Create index for JSON documents\r\nFT.CREATE product_idx \r\n    ON JSON \r\n    PREFIX 1 "product:" \r\n    SCHEMA \r\n        $.name AS name TEXT SORTABLE \r\n        $.price AS price NUMERIC SORTABLE \r\n        $.category AS category TAG SORTABLE \r\n        $.description AS description TEXT\n'})}),"\n",(0,s.jsx)(n.h4,{children:"Searching with RediSearch"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-redis",children:'# Text search\r\nFT.SEARCH user_idx "john"\r\nFT.SEARCH user_idx "john doe"\r\nFT.SEARCH user_idx "@name:john"\r\n\r\n# Numeric range queries\r\nFT.SEARCH user_idx "@age:[25 35]"\r\n\r\n# Tag queries\r\nFT.SEARCH user_idx "@city:{San Francisco}"\r\n\r\n# Complex queries\r\nFT.SEARCH user_idx "@name:john @age:[25 35] @city:{San Francisco}"\r\n\r\n# Aggregation\r\nFT.AGGREGATE user_idx "*" \r\n    GROUPBY 1 @city \r\n    REDUCE COUNT 0 AS count \r\n    SORTBY 2 @count DESC\n'})}),"\n",(0,s.jsx)(n.h3,{children:"Redis Native Data Structure Indexing"}),"\n",(0,s.jsx)(n.h4,{children:"Sets for Indexing"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-redis",children:'# Index users by city using sets\r\nSADD "city:san_francisco" "user:1" "user:5" "user:10"\r\nSADD "city:new_york" "user:2" "user:7"\r\n\r\n# Find users in a specific city\r\nSMEMBERS "city:san_francisco"\r\n\r\n# Find users in multiple cities (union)\r\nSUNION "city:san_francisco" "city:new_york"\r\n\r\n# Find users in common cities (intersection)\r\nSINTER "city:san_francisco" "active_users"\n'})}),"\n",(0,s.jsx)(n.h4,{children:"Sorted Sets for Range Queries"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-redis",children:'# Index users by age using sorted sets\r\nZADD "users_by_age" 25 "user:1" 30 "user:2" 35 "user:3"\r\n\r\n# Range queries\r\nZRANGEBYSCORE "users_by_age" 25 35        # Users aged 25-35\r\nZREVRANGEBYSCORE "users_by_age" 35 25     # Users aged 25-35 (descending)\r\nZCOUNT "users_by_age" 25 35               # Count users aged 25-35\n'})}),"\n",(0,s.jsx)(n.h2,{children:"DynamoDB Indexing"}),"\n",(0,s.jsx)(n.h3,{children:"Primary Key Structure"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// Hash key only\r\nconst userTable = {\r\n    TableName: 'Users',\r\n    KeySchema: [\r\n        { AttributeName: 'userId', KeyType: 'HASH' }\r\n    ],\r\n    AttributeDefinitions: [\r\n        { AttributeName: 'userId', AttributeType: 'S' }\r\n    ]\r\n};\r\n\r\n// Hash key + Sort key\r\nconst orderTable = {\r\n    TableName: 'Orders',\r\n    KeySchema: [\r\n        { AttributeName: 'customerId', KeyType: 'HASH' },    // Partition key\r\n        { AttributeName: 'orderDate', KeyType: 'RANGE' }     // Sort key\r\n    ],\r\n    AttributeDefinitions: [\r\n        { AttributeName: 'customerId', AttributeType: 'S' },\r\n        { AttributeName: 'orderDate', AttributeType: 'S' }\r\n    ]\r\n};\n"})}),"\n",(0,s.jsx)(n.h3,{children:"Global Secondary Indexes (GSI)"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// Create GSI for different query patterns\r\nconst gsiDefinition = {\r\n    IndexName: 'email-index',\r\n    KeySchema: [\r\n        { AttributeName: 'email', KeyType: 'HASH' }\r\n    ],\r\n    AttributeDefinitions: [\r\n        { AttributeName: 'email', AttributeType: 'S' }\r\n    ],\r\n    Projection: { ProjectionType: 'ALL' },  // Include all attributes\r\n    ProvisionedThroughput: {\r\n        ReadCapacityUnits: 5,\r\n        WriteCapacityUnits: 5\r\n    }\r\n};\r\n\r\n// Query using GSI\r\nconst params = {\r\n    TableName: 'Users',\r\n    IndexName: 'email-index',\r\n    KeyConditionExpression: 'email = :email',\r\n    ExpressionAttributeValues: {\r\n        ':email': 'john@example.com'\r\n    }\r\n};\n"})}),"\n",(0,s.jsx)(n.h3,{children:"Local Secondary Indexes (LSI)"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// LSI uses same partition key but different sort key\r\nconst lsiDefinition = {\r\n    IndexName: 'customer-status-index',\r\n    KeySchema: [\r\n        { AttributeName: 'customerId', KeyType: 'HASH' },    // Same partition key\r\n        { AttributeName: 'status', KeyType: 'RANGE' }        // Different sort key\r\n    ],\r\n    Projection: {\r\n        ProjectionType: 'INCLUDE',\r\n        NonKeyAttributes: ['orderTotal', 'items']\r\n    }\r\n};\n"})}),"\n",(0,s.jsx)(n.h2,{children:"Elasticsearch Indexing"}),"\n",(0,s.jsx)(n.h3,{children:"Index Mapping and Analysis"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'// Create index with custom mapping\r\nPUT /products\r\n{\r\n  "mappings": {\r\n    "properties": {\r\n      "name": {\r\n        "type": "text",\r\n        "analyzer": "standard",\r\n        "fields": {\r\n          "keyword": {\r\n            "type": "keyword"\r\n          }\r\n        }\r\n      },\r\n      "price": {\r\n        "type": "float"\r\n      },\r\n      "category": {\r\n        "type": "keyword"\r\n      },\r\n      "description": {\r\n        "type": "text",\r\n        "analyzer": "english"\r\n      },\r\n      "created_at": {\r\n        "type": "date"\r\n      },\r\n      "location": {\r\n        "type": "geo_point"\r\n      }\r\n    }\r\n  }\r\n}\n'})}),"\n",(0,s.jsx)(n.h3,{children:"Elasticsearch Query Optimization"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'// Multi-field search with boosting\r\nGET /products/_search\r\n{\r\n  "query": {\r\n    "multi_match": {\r\n      "query": "wireless headphones",\r\n      "fields": ["name^3", "description"],\r\n      "type": "best_fields"\r\n    }\r\n  }\r\n}\r\n\r\n// Filtered search with aggregations\r\nGET /products/_search\r\n{\r\n  "query": {\r\n    "bool": {\r\n      "must": [\r\n        { "match": { "description": "wireless" } }\r\n      ],\r\n      "filter": [\r\n        { "range": { "price": { "gte": 50, "lte": 200 } } },\r\n        { "term": { "category": "electronics" } }\r\n      ]\r\n    }\r\n  },\r\n  "aggs": {\r\n    "price_ranges": {\r\n      "range": {\r\n        "field": "price",\r\n        "ranges": [\r\n          { "to": 50 },\r\n          { "from": 50, "to": 100 },\r\n          { "from": 100, "to": 200 },\r\n          { "from": 200 }\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}\n'})}),"\n",(0,s.jsx)(n.h2,{children:"NoSQL Indexing Best Practices"}),"\n",(0,s.jsx)(n.h3,{children:"Design for Query Patterns"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Understand Access Patterns"}),": Design indexes based on how data will be queried"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Denormalization"}),": Accept data duplication to optimize read performance"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Composite Keys"}),": Use compound keys to support multiple query patterns"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{children:"MongoDB Specific"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"ESR Rule"}),": Equality, Sort, Range - order compound index fields by this priority"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Index Intersection"}),": MongoDB can use multiple single-field indexes together"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Index Prefix"}),": Compound indexes can support queries on index prefixes"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{children:"Cassandra Specific"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Partition Key Design"}),": Ensure even data distribution across nodes"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Clustering Columns"}),": Use for sorting and range queries within partitions"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Secondary Index Limitations"}),": Use sparingly and with other WHERE clauses"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{children:"Document Database Patterns"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'// MongoDB: Embedded vs Referenced data\r\n// Embedded for one-to-few relationships\r\n{\r\n    "_id": ObjectId("..."),\r\n    "user_id": 123,\r\n    "order_date": ISODate("..."),\r\n    "items": [\r\n        { "product_id": 456, "quantity": 2, "price": 29.99 },\r\n        { "product_id": 789, "quantity": 1, "price": 19.99 }\r\n    ]\r\n}\r\n\r\n// Referenced for one-to-many relationships\r\n// Orders collection\r\n{ "_id": ObjectId("..."), "user_id": 123, "total": 79.97 }\r\n\r\n// Order_items collection\r\n{ "_id": ObjectId("..."), "order_id": ObjectId("..."), "product_id": 456 }\n'})}),"\n",(0,s.jsx)(n.h2,{children:"Performance Monitoring"}),"\n",(0,s.jsx)(n.h3,{children:"MongoDB Monitoring"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// Index usage statistics\r\ndb.users.aggregate([{ $indexStats: {} }])\r\n\r\n// Slow query profiling\r\ndb.setProfilingLevel(2, { slowms: 100 })\r\ndb.system.profile.find().sort({ ts: -1 }).limit(5)\n"})}),"\n",(0,s.jsx)(n.h3,{children:"Cassandra Monitoring"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"-- Check table statistics\r\nSELECT * FROM system.size_estimates WHERE keyspace_name = 'your_keyspace';\r\n\r\n-- Monitor read/write latencies\r\nnodetool cfstats your_keyspace.your_table\n"})}),"\n",(0,s.jsx)(n.h2,{children:"Next Steps"}),"\n",(0,s.jsx)(n.p,{children:"In Part 4, we'll explore composite indexes and advanced query optimization techniques, including index intersection, covering indexes, and query plan analysis across different database systems."})]})}function d(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(t,{...e})}):t(e)}},6701:function(e,n,r){r.r(n),r.d(n,{default:function(){return d},frontmatter:function(){return a}});var s=r(7437),i=r(4229);let a=void 0;function t(e){let n={code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,i.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h2,{children:"Understanding Composite Indexes"}),"\n",(0,s.jsx)(n.p,{children:"Composite indexes (also called compound or multi-column indexes) include multiple columns in a single index structure. The order of columns in composite indexes is crucial for query performance."}),"\n",(0,s.jsx)(n.h3,{children:"The Index Column Order Principle"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"-- Example table\r\nCREATE TABLE sales (\r\n    id INT PRIMARY KEY,\r\n    customer_id INT,\r\n    product_id INT,\r\n    sale_date DATE,\r\n    amount DECIMAL(10,2),\r\n    region VARCHAR(50),\r\n    salesperson_id INT\r\n);\r\n\r\n-- Composite index with specific column order\r\nCREATE INDEX idx_sales_composite ON sales(customer_id, sale_date, amount);\n"})}),"\n",(0,s.jsx)(n.h3,{children:"How Composite Indexes Work"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Index Structure: (customer_id, sale_date, amount)\r\n┌─────────────┬─────────────┬────────┬──────────┐\r\n│ customer_id │ sale_date   │ amount │ Row Ptr  │\r\n├─────────────┼─────────────┼────────┼──────────┤\r\n│     100     │ 2024-01-15  │  250.0 │   →      │\r\n│     100     │ 2024-01-20  │  175.0 │   →      │\r\n│     100     │ 2024-02-10  │  300.0 │   →      │\r\n│     101     │ 2024-01-12  │  450.0 │   →      │\r\n│     101     │ 2024-01-25  │  200.0 │   →      │\r\n└─────────────┴─────────────┴────────┴──────────┘\n"})}),"\n",(0,s.jsx)(n.h3,{children:"Query Efficiency with Composite Indexes"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"-- HIGHLY EFFICIENT: Uses full index\r\nSELECT * FROM sales \r\nWHERE customer_id = 100 \r\n  AND sale_date BETWEEN '2024-01-01' AND '2024-01-31'\r\n  AND amount > 200;\r\n\r\n-- EFFICIENT: Uses index prefix (customer_id, sale_date)\r\nSELECT * FROM sales \r\nWHERE customer_id = 100 \r\n  AND sale_date BETWEEN '2024-01-01' AND '2024-01-31';\r\n\r\n-- EFFICIENT: Uses index prefix (customer_id)\r\nSELECT * FROM sales WHERE customer_id = 100;\r\n\r\n-- INEFFICIENT: Cannot use index effectively\r\nSELECT * FROM sales WHERE sale_date = '2024-01-15';  -- Missing customer_id prefix\r\n\r\n-- INEFFICIENT: Cannot use index effectively  \r\nSELECT * FROM sales WHERE amount > 200;  -- Missing customer_id and sale_date prefix\n"})}),"\n",(0,s.jsx)(n.h2,{children:"Optimal Column Ordering Strategies"}),"\n",(0,s.jsx)(n.h3,{children:"The ESR Rule (Equality, Sort, Range)"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"-- Query pattern analysis\r\nSELECT * FROM orders \r\nWHERE customer_id = ?          -- Equality\r\n  AND status = ?               -- Equality  \r\nORDER BY order_date DESC       -- Sort\r\n  AND total_amount > ?;        -- Range\r\n\r\n-- Optimal index order: Equality → Sort → Range\r\nCREATE INDEX idx_orders_esr ON orders(customer_id, status, order_date, total_amount);\n"})}),"\n",(0,s.jsx)(n.h3,{children:"Selectivity-Based Ordering"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"-- High selectivity (many unique values) → Low selectivity (few unique values)\r\nCREATE INDEX idx_users_selective ON users(\r\n    email,        -- High selectivity (unique emails)\r\n    age,          -- Medium selectivity  \r\n    status        -- Low selectivity ('active', 'inactive', 'pending')\r\n);\r\n\r\n-- Check column selectivity\r\nSELECT \r\n    COUNT(DISTINCT email) / COUNT(*) as email_selectivity,\r\n    COUNT(DISTINCT age) / COUNT(*) as age_selectivity,\r\n    COUNT(DISTINCT status) / COUNT(*) as status_selectivity\r\nFROM users;\n"})}),"\n",(0,s.jsx)(n.h3,{children:"Frequency-Based Ordering"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"-- Most frequently queried columns first\r\n-- Analysis shows: 80% of queries filter by region, 60% by date, 30% by salesperson\r\n\r\nCREATE INDEX idx_sales_frequency ON sales(\r\n    region,           -- Used in 80% of queries (most frequent)\r\n    sale_date,        -- Used in 60% of queries\r\n    salesperson_id    -- Used in 30% of queries\r\n);\n"})}),"\n",(0,s.jsx)(n.h2,{children:"Advanced Composite Index Techniques"}),"\n",(0,s.jsx)(n.h3,{children:"Index Intersection vs Single Composite Index"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"-- Option 1: Multiple single-column indexes\r\nCREATE INDEX idx_customer ON sales(customer_id);\r\nCREATE INDEX idx_date ON sales(sale_date);\r\nCREATE INDEX idx_amount ON sales(amount);\r\n\r\n-- Option 2: Single composite index\r\nCREATE INDEX idx_composite ON sales(customer_id, sale_date, amount);\r\n\r\n-- Query performance comparison\r\nSELECT * FROM sales \r\nWHERE customer_id = 100 \r\n  AND sale_date >= '2024-01-01' \r\n  AND amount > 200;\r\n\r\n-- Option 1: Database may use index intersection (combining multiple indexes)\r\n-- Option 2: Single index lookup (generally more efficient)\n"})}),"\n",(0,s.jsx)(n.h3,{children:"Covering Indexes (Include Columns)"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"-- SQL Server: INCLUDE additional columns at leaf level\r\nCREATE NONCLUSTERED INDEX idx_sales_covering \r\nON sales(customer_id, sale_date) \r\nINCLUDE (amount, product_id, salesperson_id);\r\n\r\n-- This query can be satisfied entirely from the index\r\nSELECT customer_id, sale_date, amount, product_id \r\nFROM sales \r\nWHERE customer_id = 100 AND sale_date >= '2024-01-01';\r\n\r\n-- PostgreSQL: Add extra columns to create covering index\r\nCREATE INDEX idx_sales_covering ON sales(customer_id, sale_date, amount, product_id, salesperson_id);\r\n\r\n-- MySQL: Include all needed columns in the index\r\nCREATE INDEX idx_sales_covering ON sales(customer_id, sale_date, amount, product_id, salesperson_id);\n"})}),"\n",(0,s.jsx)(n.h3,{children:"Partial Composite Indexes"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"-- PostgreSQL: Index only relevant data\r\nCREATE INDEX idx_active_customer_sales \r\nON sales(customer_id, sale_date) \r\nWHERE status = 'completed' AND amount > 0;\r\n\r\n-- SQL Server: Filtered index\r\nCREATE INDEX idx_active_customer_sales \r\nON sales(customer_id, sale_date) \r\nWHERE status = 'completed' AND amount > 0;\r\n\r\n-- Benefits: Smaller index size, faster maintenance, targeted queries\n"})}),"\n",(0,s.jsx)(n.h2,{children:"Query Optimization Techniques"}),"\n",(0,s.jsx)(n.h3,{children:"Analyzing Query Execution Plans"}),"\n",(0,s.jsx)(n.h4,{children:"MySQL Query Analysis"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"-- Basic explain\r\nEXPLAIN SELECT * FROM sales \r\nWHERE customer_id = 100 AND sale_date >= '2024-01-01';\r\n\r\n-- Extended explain with cost information\r\nEXPLAIN FORMAT=JSON \r\nSELECT * FROM sales \r\nWHERE customer_id = 100 AND sale_date >= '2024-01-01'\r\nORDER BY sale_date DESC;\r\n\r\n-- Analyze actual execution\r\nEXPLAIN ANALYZE \r\nSELECT * FROM sales \r\nWHERE customer_id = 100 AND sale_date >= '2024-01-01';\n"})}),"\n",(0,s.jsx)(n.h4,{children:"PostgreSQL Query Analysis"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"-- Basic execution plan\r\nEXPLAIN SELECT * FROM sales \r\nWHERE customer_id = 100 AND sale_date >= '2024-01-01';\r\n\r\n-- Detailed execution plan with costs\r\nEXPLAIN (ANALYZE, COSTS, BUFFERS) \r\nSELECT * FROM sales \r\nWHERE customer_id = 100 AND sale_date >= '2024-01-01';\r\n\r\n-- JSON format for programmatic analysis\r\nEXPLAIN (ANALYZE, COSTS, BUFFERS, FORMAT JSON) \r\nSELECT * FROM sales \r\nWHERE customer_id = 100 AND sale_date >= '2024-01-01';\n"})}),"\n",(0,s.jsx)(n.h4,{children:"SQL Server Query Analysis"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"-- Show execution plan\r\nSET SHOWPLAN_ALL ON;\r\nSELECT * FROM sales \r\nWHERE customer_id = 100 AND sale_date >= '2024-01-01';\r\n\r\n-- Include actual execution statistics\r\nSET STATISTICS IO ON;\r\nSET STATISTICS TIME ON;\r\nSELECT * FROM sales \r\nWHERE customer_id = 100 AND sale_date >= '2024-01-01';\r\n\r\n-- Use SQL Server Management Studio for graphical plans\n"})}),"\n",(0,s.jsx)(n.h3,{children:"Index Hints and Forcing"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"-- MySQL: Force specific index usage\r\nSELECT * FROM sales USE INDEX (idx_sales_composite)\r\nWHERE customer_id = 100 AND sale_date >= '2024-01-01';\r\n\r\n-- PostgreSQL: No direct index hints, but can disable other access methods\r\nSET enable_seqscan = off;\r\nSELECT * FROM sales WHERE customer_id = 100;\r\nSET enable_seqscan = on;\r\n\r\n-- SQL Server: Index hints\r\nSELECT * FROM sales WITH (INDEX(idx_sales_composite))\r\nWHERE customer_id = 100 AND sale_date >= '2024-01-01';\r\n\r\n-- Oracle: Index hints\r\nSELECT /*+ INDEX(sales idx_sales_composite) */ * \r\nFROM sales \r\nWHERE customer_id = 100 AND sale_date >= '2024-01-01';\n"})}),"\n",(0,s.jsx)(n.h2,{children:"Complex Query Optimization Patterns"}),"\n",(0,s.jsx)(n.h3,{children:"Join Optimization with Composite Indexes"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"-- Tables\r\nCREATE TABLE customers (\r\n    id INT PRIMARY KEY,\r\n    email VARCHAR(255),\r\n    region VARCHAR(50),\r\n    status VARCHAR(20)\r\n);\r\n\r\nCREATE TABLE orders (\r\n    id INT PRIMARY KEY,\r\n    customer_id INT,\r\n    order_date DATE,\r\n    total_amount DECIMAL(10,2),\r\n    status VARCHAR(20)\r\n);\r\n\r\n-- Indexes for join optimization\r\nCREATE INDEX idx_customers_region_status ON customers(region, status);\r\nCREATE INDEX idx_orders_customer_date ON orders(customer_id, order_date);\r\nCREATE INDEX idx_orders_date_amount ON orders(order_date, total_amount);\r\n\r\n-- Optimized join query\r\nSELECT c.email, o.order_date, o.total_amount\r\nFROM customers c\r\nJOIN orders o ON c.id = o.customer_id\r\nWHERE c.region = 'West Coast' \r\n  AND c.status = 'active'\r\n  AND o.order_date >= '2024-01-01'\r\n  AND o.total_amount > 100;\n"})}),"\n",(0,s.jsx)(n.h3,{children:"Subquery Optimization"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"-- Original inefficient query\r\nSELECT * FROM customers c\r\nWHERE EXISTS (\r\n    SELECT 1 FROM orders o \r\n    WHERE o.customer_id = c.id \r\n      AND o.order_date >= '2024-01-01'\r\n);\r\n\r\n-- Create index to optimize the subquery\r\nCREATE INDEX idx_orders_customer_date_exists ON orders(customer_id, order_date);\r\n\r\n-- Alternative: Convert to JOIN for better performance\r\nSELECT DISTINCT c.*\r\nFROM customers c\r\nJOIN orders o ON c.id = o.customer_id\r\nWHERE o.order_date >= '2024-01-01';\n"})}),"\n",(0,s.jsx)(n.h3,{children:"Window Function Optimization"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"-- Window function query\r\nSELECT \r\n    customer_id,\r\n    order_date,\r\n    total_amount,\r\n    ROW_NUMBER() OVER (PARTITION BY customer_id ORDER BY order_date DESC) as rn\r\nFROM orders\r\nWHERE order_date >= '2024-01-01';\r\n\r\n-- Optimal index for window function\r\nCREATE INDEX idx_orders_window ON orders(customer_id, order_date DESC);\r\n-- The index supports both the WHERE clause and the window function's PARTITION BY and ORDER BY\n"})}),"\n",(0,s.jsx)(n.h2,{children:"Index Maintenance for Composite Indexes"}),"\n",(0,s.jsx)(n.h3,{children:"Monitoring Index Usage"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"-- PostgreSQL: Check index usage statistics\r\nSELECT \r\n    schemaname,\r\n    tablename,\r\n    indexname,\r\n    idx_scan as index_scans,\r\n    idx_tup_read as tuples_read,\r\n    idx_tup_fetch as tuples_fetched\r\nFROM pg_stat_user_indexes \r\nWHERE tablename = 'sales'\r\nORDER BY idx_scan DESC;\r\n\r\n-- MySQL: Check index usage with Performance Schema\r\nSELECT \r\n    object_schema,\r\n    object_name,\r\n    index_name,\r\n    count_read,\r\n    count_write,\r\n    sum_timer_read,\r\n    sum_timer_write\r\nFROM performance_schema.table_io_waits_summary_by_index_usage\r\nWHERE object_schema = 'your_database' \r\n  AND object_name = 'sales';\r\n\r\n-- SQL Server: Index usage statistics\r\nSELECT \r\n    OBJECT_NAME(s.object_id) AS table_name,\r\n    i.name AS index_name,\r\n    s.user_seeks,\r\n    s.user_scans,\r\n    s.user_lookups,\r\n    s.user_updates\r\nFROM sys.dm_db_index_usage_stats s\r\nJOIN sys.indexes i ON s.object_id = i.object_id AND s.index_id = i.index_id\r\nWHERE OBJECT_NAME(s.object_id) = 'sales';\n"})}),"\n",(0,s.jsx)(n.h3,{children:"Identifying Redundant Indexes"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"-- Find potentially redundant indexes\r\n-- Index A: (customer_id, sale_date)\r\n-- Index B: (customer_id, sale_date, amount) \r\n-- Index B can handle all queries that Index A can handle\r\n\r\n-- PostgreSQL query to find redundant indexes\r\nSELECT \r\n    t.schemaname,\r\n    t.tablename,\r\n    c.reltuples::bigint AS rows,\r\n    pg_size_pretty(pg_total_relation_size(c.oid)) AS size,\r\n    ARRAY_AGG(DISTINCT indexname ORDER BY indexname) AS indexes\r\nFROM pg_stat_user_tables t\r\nJOIN pg_class c ON c.relname = t.tablename\r\nJOIN pg_stat_user_indexes i ON i.relid = c.oid\r\nGROUP BY t.schemaname, t.tablename, c.reltuples, c.oid\r\nHAVING COUNT(*) > 1;\n"})}),"\n",(0,s.jsx)(n.h3,{children:"Index Fragmentation and Rebuilding"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"-- SQL Server: Check index fragmentation\r\nSELECT \r\n    OBJECT_NAME(i.object_id) AS table_name,\r\n    i.name AS index_name,\r\n    s.avg_fragmentation_in_percent,\r\n    s.page_count\r\nFROM sys.dm_db_index_physical_stats(DB_ID(), NULL, NULL, NULL, 'DETAILED') s\r\nJOIN sys.indexes i ON s.object_id = i.object_id AND s.index_id = i.index_id\r\nWHERE s.avg_fragmentation_in_percent > 10\r\n  AND s.page_count > 1000;\r\n\r\n-- Rebuild highly fragmented indexes\r\nALTER INDEX idx_sales_composite ON sales REBUILD;\r\n\r\n-- PostgreSQL: Reindex when needed\r\nREINDEX INDEX idx_sales_composite;\r\n\r\n-- MySQL: Optimize table to rebuild indexes\r\nOPTIMIZE TABLE sales;\n"})}),"\n",(0,s.jsx)(n.h2,{children:"Performance Testing and Benchmarking"}),"\n",(0,s.jsx)(n.h3,{children:"Creating Test Data for Index Testing"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"-- Generate test data\r\nINSERT INTO sales (customer_id, product_id, sale_date, amount, region, salesperson_id)\r\nSELECT \r\n    (RANDOM() * 10000)::INT + 1,  -- customer_id (1-10000)\r\n    (RANDOM() * 1000)::INT + 1,   -- product_id (1-1000)\r\n    DATE '2023-01-01' + (RANDOM() * 365)::INT,  -- sale_date (2023)\r\n    (RANDOM() * 1000 + 10)::DECIMAL(10,2),      -- amount (10-1010)\r\n    CASE (RANDOM() * 4)::INT \r\n        WHEN 0 THEN 'North'\r\n        WHEN 1 THEN 'South' \r\n        WHEN 2 THEN 'East'\r\n        ELSE 'West'\r\n    END,                          -- region\r\n    (RANDOM() * 100)::INT + 1     -- salesperson_id (1-100)\r\nFROM generate_series(1, 1000000); -- 1M rows\n"})}),"\n",(0,s.jsx)(n.h3,{children:"A/B Testing Index Performance"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"-- Test 1: Without composite index\r\nDROP INDEX IF EXISTS idx_sales_composite;\r\n\\timing on\r\nSELECT * FROM sales \r\nWHERE customer_id = 100 \r\n  AND sale_date >= '2024-01-01' \r\n  AND amount > 200;\r\n\\timing off\r\n\r\n-- Test 2: With composite index\r\nCREATE INDEX idx_sales_composite ON sales(customer_id, sale_date, amount);\r\n\\timing on\r\nSELECT * FROM sales \r\nWHERE customer_id = 100 \r\n  AND sale_date >= '2024-01-01' \r\n  AND amount > 200;\r\n\\timing off\n"})}),"\n",(0,s.jsx)(n.h3,{children:"Load Testing with Composite Indexes"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'# Python script for concurrent query testing\r\nimport psycopg2\r\nimport threading\r\nimport time\r\nimport random\r\n\r\ndef run_queries(connection_string, num_queries):\r\n    conn = psycopg2.connect(connection_string)\r\n    cursor = conn.cursor()\r\n    \r\n    start_time = time.time()\r\n    for i in range(num_queries):\r\n        customer_id = random.randint(1, 10000)\r\n        cursor.execute("""\r\n            SELECT * FROM sales \r\n            WHERE customer_id = %s \r\n              AND sale_date >= \'2024-01-01\' \r\n              AND amount > 200\r\n        """, (customer_id,))\r\n        results = cursor.fetchall()\r\n    \r\n    end_time = time.time()\r\n    print(f"Thread completed {num_queries} queries in {end_time - start_time:.2f} seconds")\r\n    \r\n    cursor.close()\r\n    conn.close()\r\n\r\n# Run concurrent load test\r\nthreads = []\r\nfor i in range(10):  # 10 concurrent threads\r\n    thread = threading.Thread(target=run_queries, args=(connection_string, 100))\r\n    threads.append(thread)\r\n    thread.start()\r\n\r\nfor thread in threads:\r\n    thread.join()\n'})}),"\n",(0,s.jsx)(n.h2,{children:"Best Practices Summary"}),"\n",(0,s.jsx)(n.h3,{children:"Design Principles"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Understand Query Patterns"}),": Analyze actual application queries before creating indexes"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Column Order Matters"}),": Follow ESR rule and consider selectivity"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Covering Indexes"}),": Include frequently accessed columns to avoid table lookups"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Partial Indexes"}),": Filter out irrelevant data to reduce index size"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{children:"Maintenance Guidelines"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Monitor Usage"}),": Regularly check index usage statistics"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Remove Unused Indexes"}),": Drop indexes that aren't being used"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Rebuild When Needed"}),": Address fragmentation in high-write environments"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Update Statistics"}),": Keep optimizer statistics current"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{children:"Performance Testing"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Test with Real Data"}),": Use production-like data volumes and distributions"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Measure Before and After"}),": Always benchmark performance improvements"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Load Testing"}),": Test under concurrent workloads"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Monitor Resources"}),": Watch CPU, memory, and I/O impact"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{children:"Next Steps"}),"\n",(0,s.jsx)(n.p,{children:"In Part 5, we'll dive into index performance monitoring and maintenance strategies, including automated index tuning, fragmentation management, and advanced monitoring techniques across different database platforms."})]})}function d(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(t,{...e})}):t(e)}}}]);