"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[5448],{55730:function(e,n,t){t.r(n),t.d(n,{default:function(){return l},frontmatter:function(){return a},metadata:function(){return i}});var s=t(57437),r=t(52671);let a=void 0,i={postId:"5b8ef543-5e6a-440d-8026-5a876c05fb02",title:"LLM Engineering Mastery - Complete Series",date:"2024-01-27",excerpt:"Complete LLM Engineering Mastery series with 3 parts covering Part 1 of the LLM Engineering Mastery series: Master foundation models from an engineering perspective - understanding capabilities, limitations, and practical integration strategies.",author:"Abstract Algorithms",tags:["llm","genai","engineering","foundation-models","practical-ai"],coverImage:"./assets/series-overview.png",series:{name:"LLM Engineering Mastery",total:3,isOverview:!0,parts:[{order:1,title:"LLM Engineering Mastery: Part 1 - Understanding and Leveraging Foundation Models",url:"/posts/llm-engineering-mastery-part-1/",excerpt:"Part 1 of the LLM Engineering Mastery series: Master foundation models from an engineering perspective - understanding capabilities, limitations, and practical integration strategies."},{order:1,title:"LLM Engineering Mastery: Part 1 - Understanding and Leveraging Foundation Models",url:"/posts/llm-engineering-mastery-part-1/",excerpt:"Part 1 of the LLM Engineering Mastery series: Master foundation models from an engineering perspective - understanding capabilities, limitations, and practical integration strategies."},{order:2,title:"LLM Engineering Mastery: Part 2 - Advanced Prompt Engineering and RAG Systems",url:"/posts/llm-engineering-mastery-part-2/",excerpt:"Part 2 of the LLM Engineering Mastery series: Master advanced prompt engineering techniques and build production-ready RAG systems for enhanced LLM applications."},{order:2,title:"LLM Engineering Mastery: Part 2 - Advanced Prompt Engineering and RAG Systems",url:"/posts/llm-engineering-mastery-part-2/",excerpt:"Part 2 of the LLM Engineering Mastery series: Master advanced prompt engineering techniques and build production-ready RAG systems for enhanced LLM applications."},{order:3,title:"LLM Engineering Mastery: Part 3 - Production Deployment and Scaling",url:"/posts/llm-engineering-mastery-part-3/",excerpt:"Part 3 of the LLM Engineering Mastery series: Master production deployment, scaling strategies, monitoring, and security for enterprise-grade LLM applications."},{order:3,title:"LLM Engineering Mastery: Part 3 - Production Deployment and Scaling",url:"/posts/llm-engineering-mastery-part-3/",excerpt:"Part 3 of the LLM Engineering Mastery series: Master production deployment, scaling strategies, monitoring, and security for enterprise-grade LLM applications."}]}};function o(e){let n={a:"a",em:"em",h1:"h1",h2:"h2",h3:"h3",hr:"hr",p:"p",...(0,r.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{children:"LLM Engineering Mastery"}),"\n",(0,s.jsx)(n.p,{children:"Part 1 of the LLM Engineering Mastery series: Master foundation models from an engineering perspective - understanding capabilities, limitations, and practical integration strategies."}),"\n",(0,s.jsx)(n.h2,{children:"Series Overview"}),"\n",(0,s.jsx)(n.p,{children:"This comprehensive 3-part series covers:"}),"\n",(0,s.jsx)(n.h3,{children:"1. LLM Engineering Mastery: Part 1 - Understanding and Leveraging Foundation Models"}),"\n",(0,s.jsx)(n.p,{children:"Part 1 of the LLM Engineering Mastery series: Master foundation models from an engineering perspective - understanding capabilities, limitations, and practical integration strategies."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"/posts/llm-engineering-mastery-part-1/",children:"Read Part 1 →"})}),"\n",(0,s.jsx)(n.h3,{children:"1. LLM Engineering Mastery: Part 1 - Understanding and Leveraging Foundation Models"}),"\n",(0,s.jsx)(n.p,{children:"Part 1 of the LLM Engineering Mastery series: Master foundation models from an engineering perspective - understanding capabilities, limitations, and practical integration strategies."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"/posts/llm-engineering-mastery-part-1/",children:"Read Part 1 →"})}),"\n",(0,s.jsx)(n.h3,{children:"2. LLM Engineering Mastery: Part 2 - Advanced Prompt Engineering and RAG Systems"}),"\n",(0,s.jsx)(n.p,{children:"Part 2 of the LLM Engineering Mastery series: Master advanced prompt engineering techniques and build production-ready RAG systems for enhanced LLM applications."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"/posts/llm-engineering-mastery-part-2/",children:"Read Part 2 →"})}),"\n",(0,s.jsx)(n.h3,{children:"2. LLM Engineering Mastery: Part 2 - Advanced Prompt Engineering and RAG Systems"}),"\n",(0,s.jsx)(n.p,{children:"Part 2 of the LLM Engineering Mastery series: Master advanced prompt engineering techniques and build production-ready RAG systems for enhanced LLM applications."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"/posts/llm-engineering-mastery-part-2/",children:"Read Part 2 →"})}),"\n",(0,s.jsx)(n.h3,{children:"3. LLM Engineering Mastery: Part 3 - Production Deployment and Scaling"}),"\n",(0,s.jsx)(n.p,{children:"Part 3 of the LLM Engineering Mastery series: Master production deployment, scaling strategies, monitoring, and security for enterprise-grade LLM applications."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"/posts/llm-engineering-mastery-part-3/",children:"Read Part 3 →"})}),"\n",(0,s.jsx)(n.h3,{children:"3. LLM Engineering Mastery: Part 3 - Production Deployment and Scaling"}),"\n",(0,s.jsx)(n.p,{children:"Part 3 of the LLM Engineering Mastery series: Master production deployment, scaling strategies, monitoring, and security for enterprise-grade LLM applications."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"/posts/llm-engineering-mastery-part-3/",children:"Read Part 3 →"})}),"\n",(0,s.jsx)(n.h2,{children:"Getting Started"}),"\n",(0,s.jsx)(n.p,{children:"Ready to dive in? Start with Part 1 and work your way through the series:"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"/posts/llm-engineering-mastery-part-1/",children:"Begin with Part 1 →"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:"This series is designed to be read sequentially for the best learning experience."})})]})}function l(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(o,{...e})}):o(e)}},82858:function(e,n,t){t.r(n),t.d(n,{default:function(){return l},frontmatter:function(){return a},metadata:function(){return i}});var s=t(57437),r=t(52671);let a=void 0,i={postId:"f47ac10b-58cc-4372-a567-0e02b2c3d479",title:"LLM Engineering Mastery: Part 1 - Understanding and Leveraging Foundation Models",date:"2024-01-27",excerpt:"Part 1 of the LLM Engineering Mastery series: Master foundation models from an engineering perspective - understanding capabilities, limitations, and practical integration strategies.",author:"Abstract Algorithms",tags:["llm","genai","engineering","foundation-models","practical-ai"],coverImage:"/posts/llm-engineering-part-1/assets/overview.png",series:{name:"LLM Engineering Mastery",order:1,total:3,next:"/posts/llm-engineering-mastery-part-2-advanced-prompt-engineering-and-rag-systems",coverImage:"/posts/llm-engineering-part-1/assets/assets/llm-engineering-series.png",overview:"/posts/llm-engineering-mastery-series/"}};function o(e){let n={blockquote:"blockquote",br:"br",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{children:"LLM Engineering Mastery: Part 1 - Understanding and Leveraging Foundation Models"}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Part 1 of the LLM Engineering Mastery Series"}),(0,s.jsx)(n.br,{}),"\n","This focused 3-part series is designed for engineers who want to master Large Language Models from a practical, implementation-oriented perspective. Start here to understand foundation models and selection frameworks."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Welcome to the ",(0,s.jsx)(n.strong,{children:"LLM Engineering Mastery"})," series! This focused 3-part series is designed for engineers who want to master Large Language Models from a practical, implementation-oriented perspective."]}),"\n",(0,s.jsx)(n.h2,{children:"Series Overview"}),"\n",(0,s.jsxs)(n.p,{children:["This series focuses on the ",(0,s.jsx)(n.strong,{children:"engineering perspective"})," of working with LLMs, emphasizing practical usage, integration, and optimization rather than theoretical underpinnings."]}),"\n",(0,s.jsx)(n.h3,{children:"What We'll Cover in This 3-Part Series"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Part 1: Understanding and Leveraging Foundation Models"})," (This part)"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Foundation model ecosystem and selection"}),"\n",(0,s.jsx)(n.li,{children:"API integration patterns and best practices"}),"\n",(0,s.jsx)(n.li,{children:"Performance optimization and cost management"}),"\n",(0,s.jsx)(n.li,{children:"Understanding model capabilities and limitations"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Part 2: Advanced Prompt Engineering and RAG Systems"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Advanced prompting techniques and optimization"}),"\n",(0,s.jsx)(n.li,{children:"Building production-ready RAG systems"}),"\n",(0,s.jsx)(n.li,{children:"Context management and information retrieval"}),"\n",(0,s.jsx)(n.li,{children:"Evaluation and quality assurance"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Part 3: Production Deployment and Scaling"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Infrastructure patterns for LLM applications"}),"\n",(0,s.jsx)(n.li,{children:"Monitoring, observability, and debugging"}),"\n",(0,s.jsx)(n.li,{children:"Security, safety, and compliance"}),"\n",(0,s.jsx)(n.li,{children:"Scaling strategies and performance optimization"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{children:"Part 1: Understanding and Leveraging Foundation Models"}),"\n",(0,s.jsx)(n.p,{children:"As an LLM engineer, your first challenge is understanding the landscape of available models and how to effectively integrate them into your applications."}),"\n",(0,s.jsx)(n.h3,{children:"The Foundation Model Ecosystem"}),"\n",(0,s.jsx)(n.h4,{children:"Major Model Families and Their Sweet Spots"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"OpenAI GPT Family"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"GPT-4 Turbo"}),": Best for complex reasoning, coding, analysis"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"GPT-3.5 Turbo"}),": Cost-effective for most conversational tasks"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Use Cases"}),": Customer support, content generation, code assistance"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Anthropic Claude Family"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Claude-3 Opus"}),": Superior for safety-critical applications"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Claude-3 Sonnet"}),": Balanced performance and cost"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Use Cases"}),": Content moderation, research assistance, ethical AI applications"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Google PaLM/Gemini Family"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Gemini Pro"}),": Strong multimodal capabilities"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"PaLM 2"}),": Excellent for multilingual applications"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Use Cases"}),": Translation, multimodal applications, search enhancement"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Open Source Models"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Llama 2/Code Llama"}),": Self-hosted deployment"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Mistral"}),": European alternative with strong performance"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Use Cases"}),": On-premises deployment, customization, cost control"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{children:"Model Selection Framework"}),"\n",(0,s.jsx)(n.h4,{children:"Performance vs. Cost Analysis"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'class ModelSelectionFramework:\n    def __init__(self):\n        self.models = {\n            "gpt-4-turbo": {\n                "cost_per_1k_tokens": {"input": 0.01, "output": 0.03},\n                "context_window": 128000,\n                "strengths": ["reasoning", "coding", "analysis"],\n                "latency_ms": 2000\n            },\n            "gpt-3.5-turbo": {\n                "cost_per_1k_tokens": {"input": 0.0015, "output": 0.002},\n                "context_window": 16000,\n                "strengths": ["speed", "cost", "general"],\n                "latency_ms": 800\n            },\n            "claude-3-sonnet": {\n                "cost_per_1k_tokens": {"input": 0.003, "output": 0.015},\n                "context_window": 200000,\n                "strengths": ["safety", "long_context", "reasoning"],\n                "latency_ms": 1500\n            }\n        }\n    \n    def calculate_cost(self, model_name, input_tokens, output_tokens):\n        model = self.models[model_name]\n        input_cost = (input_tokens / 1000) * model["cost_per_1k_tokens"]["input"]\n        output_cost = (output_tokens / 1000) * model["cost_per_1k_tokens"]["output"]\n        return input_cost + output_cost\n    \n    def recommend_model(self, requirements):\n        """\n        Recommend model based on requirements:\n        - latency_sensitive: bool\n        - cost_sensitive: bool\n        - context_length: int\n        - task_type: str\n        """\n        scores = {}\n        for model_name, specs in self.models.items():\n            score = 0\n            \n            # Latency scoring\n            if requirements.get("latency_sensitive", False):\n                score += 10 if specs["latency_ms"] < 1000 else 5\n            \n            # Cost scoring\n            if requirements.get("cost_sensitive", False):\n                avg_cost = (specs["cost_per_1k_tokens"]["input"] + \n                           specs["cost_per_1k_tokens"]["output"]) / 2\n                score += 10 if avg_cost < 0.005 else 5\n            \n            # Context length scoring\n            if requirements.get("context_length", 0) > specs["context_window"]:\n                score = 0  # Disqualify if context too long\n            \n            # Task type scoring\n            task_type = requirements.get("task_type", "")\n            if task_type in specs["strengths"]:\n                score += 15\n            \n            scores[model_name] = score\n        \n        return max(scores, key=scores.get) if scores else None\n\n# Usage example\nframework = ModelSelectionFramework()\nrecommendation = framework.recommend_model({\n    "latency_sensitive": True,\n    "cost_sensitive": True,\n    "context_length": 8000,\n    "task_type": "general"\n})\nprint("Recommended model:", recommendation)\n'})}),"\n",(0,s.jsx)(n.h3,{children:"API Integration Patterns"}),"\n",(0,s.jsx)(n.h4,{children:"1. Robust Client Implementation"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'import asyncio\nimport aiohttp\nimport backoff\nfrom typing import Optional, Dict, Any\nimport logging\n\nclass LLMClient:\n    def __init__(self, api_key: str, base_url: str, model: str):\n        self.api_key = api_key\n        self.base_url = base_url\n        self.model = model\n        self.session = None\n        self.logger = logging.getLogger(__name__)\n    \n    async def __aenter__(self):\n        self.session = aiohttp.ClientSession(\n            headers={"Authorization": "Bearer {self.api_key}".format(self.api_key)},\n            timeout=aiohttp.ClientTimeout(total=60)\n        )\n        return self\n    \n    async def __aexit__(self, exc_type, exc_val, exc_tb):\n        if self.session:\n            await self.session.close()\n    \n    @backoff.on_exception(\n        backoff.expo,\n        (aiohttp.ClientError, asyncio.TimeoutError),\n        max_tries=3,\n        max_time=300\n    )\n    async def complete(\n        self, \n        messages: list,\n        temperature: float = 0.7,\n        max_tokens: int = 1000,\n        **kwargs\n    ) -> Dict[str, Any]:\n        """\n        Complete a chat conversation with robust error handling\n        """\n        payload = {\n            "model": self.model,\n            "messages": messages,\n            "temperature": temperature,\n            "max_tokens": max_tokens,\n            **kwargs\n        }\n        \n        try:\n            async with self.session.post(\n                "{self.base_url}/chat/completions".format(self.base_url),\n                json=payload\n            ) as response:\n                response.raise_for_status()\n                result = await response.json()\n                \n                # Log usage for monitoring\n                usage = result.get("usage", {})\n                self.logger.info(\n                    "API call completed",\n                    extra={\n                        "model": self.model,\n                        "input_tokens": usage.get("prompt_tokens", 0),\n                        "output_tokens": usage.get("completion_tokens", 0),\n                        "total_tokens": usage.get("total_tokens", 0)\n                    }\n                )\n                \n                return result\n                \n        except aiohttp.ClientResponseError as e:\n            if e.status == 429:  # Rate limit\n                self.logger.warning("Rate limited, backing off")\n                raise\n            elif e.status == 400:  # Bad request\n                self.logger.error("Bad request", extra={"payload": payload})\n                raise ValueError("Invalid request parameters")\n            else:\n                self.logger.error("API error", extra={"status": e.status})\n                raise\n    \n    async def stream_complete(\n        self,\n        messages: list,\n        **kwargs\n    ):\n        """\n        Stream completion for real-time applications\n        """\n        payload = {\n            "model": self.model,\n            "messages": messages,\n            "stream": True,\n            **kwargs\n        }\n        \n        async with self.session.post(\n            "{self.base_url}/chat/completions".format(self.base_url),\n            json=payload\n        ) as response:\n            response.raise_for_status()\n            \n            async for line in response.content:\n                line = line.decode(\'utf-8\').strip()\n                if line.startswith(\'data: \'):\n                    data = line[6:]\n                    if data == \'[DONE]\':\n                        break\n                    try:\n                        yield json.loads(data)\n                    except json.JSONDecodeError:\n                        continue\n\n# Usage example\nasync def main():\n    async with LLMClient(\n        api_key="your-api-key",\n        base_url="https://api.openai.com/v1",\n        model="gpt-3.5-turbo"\n    ) as client:\n        \n        response = await client.complete(\n            messages=[\n                {"role": "user", "content": "Explain quantum computing"}\n            ],\n            temperature=0.3\n        )\n        \n        print(response["choices"][0]["message"]["content"])\n'})}),"\n",(0,s.jsx)(n.h4,{children:"2. Multi-Provider Abstraction Layer"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'from abc import ABC, abstractmethod\nfrom enum import Enum\n\nclass Provider(Enum):\n    OPENAI = "openai"\n    ANTHROPIC = "anthropic"\n    GOOGLE = "google"\n\nclass LLMProvider(ABC):\n    @abstractmethod\n    async def complete(self, messages: list, **kwargs) -> Dict[str, Any]:\n        pass\n    \n    @abstractmethod\n    def estimate_tokens(self, text: str) -> int:\n        pass\n\nclass OpenAIProvider(LLMProvider):\n    def __init__(self, api_key: str, model: str = "gpt-3.5-turbo"):\n        self.client = LLMClient(api_key, "https://api.openai.com/v1", model)\n    \n    async def complete(self, messages: list, **kwargs) -> Dict[str, Any]:\n        async with self.client as client:\n            return await client.complete(messages, **kwargs)\n    \n    def estimate_tokens(self, text: str) -> int:\n        # Rough estimation: 1 token ≈ 4 characters\n        return len(text) // 4\n\nclass AnthropicProvider(LLMProvider):\n    def __init__(self, api_key: str, model: str = "claude-3-sonnet-20240229"):\n        self.api_key = api_key\n        self.model = model\n    \n    async def complete(self, messages: list, **kwargs) -> Dict[str, Any]:\n        # Implement Anthropic-specific API calls\n        # Convert messages format, handle different response structure\n        pass\n    \n    def estimate_tokens(self, text: str) -> int:\n        # Anthropic-specific token estimation\n        return len(text) // 4\n\nclass LLMManager:\n    def __init__(self):\n        self.providers = {}\n    \n    def register_provider(self, name: str, provider: LLMProvider):\n        self.providers[name] = provider\n    \n    async def complete(\n        self, \n        provider_name: str, \n        messages: list, \n        fallback_providers: list = None,\n        **kwargs\n    ) -> Dict[str, Any]:\n        """\n        Complete with primary provider, fallback to alternatives on failure\n        """\n        providers_to_try = [provider_name] + (fallback_providers or [])\n        \n        for provider in providers_to_try:\n            if provider not in self.providers:\n                continue\n                \n            try:\n                return await self.providers[provider].complete(messages, **kwargs)\n            except Exception as e:\n                logging.warning("Provider {provider} failed: {e}".format(e))\n                if provider == providers_to_try[-1]:  # Last provider\n                    raise\n                continue\n\n# Usage\nmanager = LLMManager()\nmanager.register_provider("openai", OpenAIProvider("openai-key"))\nmanager.register_provider("anthropic", AnthropicProvider("anthropic-key"))\n\nresponse = await manager.complete(\n    "openai",\n    messages=[{"role": "user", "content": "Hello"}],\n    fallback_providers=["anthropic"]\n)\n'})}),"\n",(0,s.jsx)(n.h3,{children:"Performance Optimization and Cost Management"}),"\n",(0,s.jsx)(n.h4,{children:"Token Usage Optimization"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'class TokenOptimizer:\n    def __init__(self, provider: LLMProvider):\n        self.provider = provider\n    \n    def compress_conversation_history(\n        self, \n        messages: list, \n        max_tokens: int = 4000\n    ) -> list:\n        """\n        Intelligently compress conversation history to fit token limits\n        """\n        # Always keep system message and last user message\n        if len(messages) <= 2:\n            return messages\n        \n        system_msg = messages[0] if messages[0]["role"] == "system" else None\n        recent_messages = messages[-2:]  # Last user + assistant\n        middle_messages = messages[1:-2] if len(messages) > 2 else []\n        \n        # Estimate current token usage\n        current_tokens = sum(\n            self.provider.estimate_tokens(msg["content"]) \n            for msg in messages\n        )\n        \n        if current_tokens <= max_tokens:\n            return messages\n        \n        # Compress middle messages by summarizing them\n        if middle_messages:\n            summary_prompt = self._create_summary_prompt(middle_messages)\n            # Use cheaper model for summarization\n            summary_response = await self.provider.complete(\n                [{"role": "user", "content": summary_prompt}],\n                model="gpt-3.5-turbo",  # Cheaper model\n                max_tokens=200,\n                temperature=0.1\n            )\n            \n            summary_message = {\n                "role": "assistant",\n                "content": "[Previous conversation summary: " + summary_response[\'choices\'][0][\'message\'][\'content\'] + "]"\n            }\n            \n            compressed = [system_msg, summary_message] + recent_messages\n            return [msg for msg in compressed if msg is not None]\n        \n        return ([system_msg] if system_msg else []) + recent_messages\n    \n    def _create_summary_prompt(self, messages: list) -> str:\n        conversation = "\\n".join([\n            msg[\'role\'] + ": " + msg[\'content\'] for msg in messages\n        ])\n        return """Summarize this conversation concisely, preserving key context and decisions made:\n\n""" + conversation + """\n\nSummary (max 150 words):"""\n\n    async def optimize_prompt(self, prompt: str, task_type: str = "general") -> str:\n        """\n        Optimize prompt for clarity and token efficiency\n        """\n        optimization_prompts = {\n            "general": "Rewrite this prompt to be more concise while preserving meaning",\n            "coding": "Rewrite this coding prompt to be clear and specific",\n            "analysis": "Rewrite this analysis prompt to be focused and actionable"\n        }\n        \n        opt_prompt = optimization_prompts.get(task_type, optimization_prompts["general"])\n        \n        response = await self.provider.complete([\n            {\n                "role": "user", \n                "content": opt_prompt + ":\\n\\n" + prompt + "\\n\\nOptimized prompt:"\n            }\n        ], max_tokens=300, temperature=0.1)\n        \n        return response["choices"][0]["message"]["content"].strip()\n'})}),"\n",(0,s.jsx)(n.h4,{children:"Cost Monitoring and Budgeting"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'import asyncio\nfrom datetime import datetime, timedelta\nfrom dataclasses import dataclass\nfrom typing import Dict, List\n\n@dataclass\nclass UsageRecord:\n    timestamp: datetime\n    model: str\n    input_tokens: int\n    output_tokens: int\n    cost: float\n    operation: str\n\nclass CostMonitor:\n    def __init__(self, daily_budget: float = 100.0):\n        self.daily_budget = daily_budget\n        self.usage_records: List[UsageRecord] = []\n        self.model_costs = {\n            "gpt-4-turbo": {"input": 0.01, "output": 0.03},\n            "gpt-3.5-turbo": {"input": 0.0015, "output": 0.002},\n            "claude-3-sonnet": {"input": 0.003, "output": 0.015}\n        }\n    \n    def log_usage(\n        self, \n        model: str, \n        input_tokens: int, \n        output_tokens: int,\n        operation: str = "completion"\n    ):\n        """Log API usage for cost tracking"""\n        cost = self.calculate_cost(model, input_tokens, output_tokens)\n        \n        record = UsageRecord(\n            timestamp=datetime.now(),\n            model=model,\n            input_tokens=input_tokens,\n            output_tokens=output_tokens,\n            cost=cost,\n            operation=operation\n        )\n        \n        self.usage_records.append(record)\n        \n        # Check if approaching budget\n        daily_spend = self.get_daily_spend()\n        if daily_spend > self.daily_budget * 0.8:\n            logging.warning(\n                "Approaching daily budget: $" + str(round(daily_spend, 2)) + " / $" + str(self.daily_budget)\n            )\n    \n    def calculate_cost(self, model: str, input_tokens: int, output_tokens: int) -> float:\n        """Calculate cost for API call"""\n        if model not in self.model_costs:\n            return 0.0\n        \n        costs = self.model_costs[model]\n        input_cost = (input_tokens / 1000) * costs["input"]\n        output_cost = (output_tokens / 1000) * costs["output"]\n        \n        return input_cost + output_cost\n    \n    def get_daily_spend(self, date: datetime = None) -> float:\n        """Get total spending for a specific day"""\n        if date is None:\n            date = datetime.now()\n        \n        start_of_day = date.replace(hour=0, minute=0, second=0, microsecond=0)\n        end_of_day = start_of_day + timedelta(days=1)\n        \n        daily_records = [\n            record for record in self.usage_records\n            if start_of_day <= record.timestamp < end_of_day\n        ]\n        \n        return sum(record.cost for record in daily_records)\n    \n    def get_model_breakdown(self, days: int = 7) -> Dict[str, float]:\n        """Get cost breakdown by model for the last N days"""\n        cutoff_date = datetime.now() - timedelta(days=days)\n        recent_records = [\n            record for record in self.usage_records\n            if record.timestamp >= cutoff_date\n        ]\n        \n        breakdown = {}\n        for record in recent_records:\n            breakdown[record.model] = breakdown.get(record.model, 0) + record.cost\n        \n        return breakdown\n    \n    def should_throttle(self) -> bool:\n        """Check if we should throttle requests due to budget"""\n        return self.get_daily_spend() >= self.daily_budget\n\n# Integration with LLM client\nclass MonitoredLLMClient(LLMClient):\n    def __init__(self, *args, cost_monitor: CostMonitor = None, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.cost_monitor = cost_monitor or CostMonitor()\n    \n    async def complete(self, messages: list, **kwargs) -> Dict[str, Any]:\n        # Check budget before making request\n        if self.cost_monitor.should_throttle():\n            raise Exception("Daily budget exceeded")\n        \n        response = await super().complete(messages, **kwargs)\n        \n        # Log usage after successful request\n        usage = response.get("usage", {})\n        self.cost_monitor.log_usage(\n            model=self.model,\n            input_tokens=usage.get("prompt_tokens", 0),\n            output_tokens=usage.get("completion_tokens", 0),\n            operation="chat_completion"\n        )\n        \n        return response\n'})}),"\n",(0,s.jsx)(n.h3,{children:"Understanding Model Capabilities and Limitations"}),"\n",(0,s.jsx)(n.h4,{children:"Capability Assessment Framework"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'import time\n\nclass CapabilityTester:\n    def __init__(self, llm_client: LLMClient):\n        self.client = llm_client\n        self.test_suite = {\n            "reasoning": [\n                "If it takes 5 machines 5 minutes to make 5 widgets, how long would it take 100 machines to make 100 widgets?",\n                "A bat and a ball cost $1.10 in total. The bat costs $1.00 more than the ball. How much does the ball cost?"\n            ],\n            "coding": [\n                "Write a Python function to find the longest palindromic substring",\n                "Implement a basic LRU cache in Python"\n            ],\n            "math": [\n                "Calculate the derivative of x^3 + 2x^2 - 5x + 3",\n                "Solve the system: 2x + 3y = 7, x - y = 1"\n            ],\n            "creativity": [\n                "Write a haiku about debugging code",\n                "Create a metaphor explaining machine learning to a 5-year-old"\n            ],\n            "analysis": [\n                "Analyze the pros and cons of microservices vs monolithic architecture",\n                "Compare the trade-offs between SQL and NoSQL databases"\n            ]\n        }\n    \n    async def run_capability_assessment(self) -> Dict[str, Dict[str, Any]]:\n        """Run comprehensive capability assessment"""\n        results = {}\n        \n        for category, prompts in self.test_suite.items():\n            category_results = {\n                "scores": [],\n                "responses": [],\n                "avg_latency": 0,\n                "consistency": 0\n            }\n            \n            latencies = []\n            responses = []\n            \n            for prompt in prompts:\n                start_time = time.time()\n                \n                # Test multiple times for consistency\n                test_responses = []\n                for _ in range(3):\n                    response = await self.client.complete([\n                        {"role": "user", "content": prompt}\n                    ], temperature=0.1)\n                    \n                    content = response["choices"][0]["message"]["content"]\n                    test_responses.append(content)\n                \n                end_time = time.time()\n                latencies.append(end_time - start_time)\n                responses.append(test_responses)\n                \n                # Score quality (simplified - in practice, use more sophisticated scoring)\n                quality_score = self._score_response(prompt, test_responses[0], category)\n                category_results["scores"].append(quality_score)\n                category_results["responses"].append(test_responses[0])\n            \n            category_results["avg_latency"] = sum(latencies) / len(latencies)\n            category_results["consistency"] = self._calculate_consistency(responses)\n            \n            results[category] = category_results\n        \n        return results\n    \n    def _score_response(self, prompt: str, response: str, category: str) -> float:\n        """Score response quality (simplified scoring)"""\n        # In practice, implement category-specific scoring logic\n        # This is a placeholder\n        if category == "reasoning":\n            # Check for logical structure, correct answer if verifiable\n            return 8.5 if len(response) > 50 and "because" in response.lower() else 6.0\n        elif category == "coding":\n            # Check for code blocks, proper syntax\n            return 9.0 if "def " in response or "function" in response else 5.0\n        elif category == "math":\n            # Check for mathematical notation, step-by-step solution\n            return 8.0 if any(char in response for char in "=+-*/") else 4.0\n        else:\n            # General quality based on length and coherence\n            return 7.0 if len(response) > 30 else 4.0\n    \n    def _calculate_consistency(self, responses: List[List[str]]) -> float:\n        """Calculate consistency across multiple runs"""\n        # Simplified consistency calculation\n        # In practice, use semantic similarity metrics\n        total_similarity = 0\n        count = 0\n        \n        for response_group in responses:\n            for i in range(len(response_group)):\n                for j in range(i + 1, len(response_group)):\n                    # Simple similarity based on length and word overlap\n                    r1, r2 = response_group[i], response_group[j]\n                    similarity = len(set(r1.split()) & set(r2.split())) / max(len(r1.split()), len(r2.split()))\n                    total_similarity += similarity\n                    count += 1\n        \n        return total_similarity / count if count > 0 else 0\n'})}),"\n",(0,s.jsx)(n.h2,{children:"Key Takeaways for Part 1"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Model Selection is Critical"}),": Choose based on specific requirements (cost, latency, capabilities)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Robust Integration"}),": Implement proper error handling, retries, and monitoring"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Cost Management"}),": Track usage actively and implement budget controls"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Understand Limitations"}),": Test capabilities systematically and plan accordingly"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Abstraction Layers"}),": Build provider-agnostic systems for flexibility"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{children:"What's Next?"}),"\n",(0,s.jsxs)(n.p,{children:["In ",(0,s.jsx)(n.strong,{children:"Part 2"}),", we'll dive deep into advanced prompt engineering techniques and building production-ready RAG (Retrieval-Augmented Generation) systems that can enhance your LLM applications with external knowledge."]}),"\n",(0,s.jsx)(n.p,{children:"We'll cover:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Advanced prompting strategies (few-shot, chain-of-thought, tree-of-thought)"}),"\n",(0,s.jsx)(n.li,{children:"Building robust RAG architectures"}),"\n",(0,s.jsx)(n.li,{children:"Vector databases and embedding strategies"}),"\n",(0,s.jsx)(n.li,{children:"Context optimization and retrieval quality"}),"\n",(0,s.jsx)(n.li,{children:"Evaluation frameworks for prompt and RAG performance"}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:"This series is designed for practicing engineers who want to master LLM integration and deployment. Each part builds upon the previous while remaining practical and implementation-focused."})})]})}function l(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(o,{...e})}):o(e)}},85496:function(e,n,t){t.r(n),t.d(n,{default:function(){return l},frontmatter:function(){return a},metadata:function(){return i}});var s=t(57437),r=t(52671);let a=void 0,i={postId:"8e7d5b2c-9f3a-4e1b-8c6d-1a2b3c4d5e6f",title:"LLM Engineering Mastery: Part 2 - Advanced Prompt Engineering and RAG Systems",date:"2024-02-03",excerpt:"Part 2 of the LLM Engineering Mastery series: Master advanced prompt engineering techniques and build production-ready RAG systems for enhanced LLM applications.",author:"Abstract Algorithms",tags:["llm","prompt-engineering","rag","vector-databases","retrieval"],coverImage:"/posts/llm-engineering-part-2/assets/overview.png",series:{name:"LLM Engineering Mastery",order:2,total:3,prev:"/posts/llm-engineering-mastery-part-1-understanding-and-leveraging-foundation-models",next:"/posts/llm-engineering-mastery-part-3-production-deployment-and-scaling",coverImage:"/posts/llm-engineering-part-2/assets/assets/llm-engineering-series.png",overview:"/posts/llm-engineering-mastery-series/"}};function o(e){let n={blockquote:"blockquote",br:"br",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{children:"LLM Engineering Mastery: Part 2 - Advanced Prompt Engineering and RAG Systems"}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Part 2 of the LLM Engineering Mastery Series"}),(0,s.jsx)(n.br,{}),"\n","Building on foundation model integration, this part explores advanced prompt engineering and production-ready RAG systems. Master the techniques that make LLM applications truly powerful and reliable."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Building on the foundation model integration from Part 1, we now dive deep into advanced prompt engineering techniques and Retrieval-Augmented Generation (RAG) systems that can dramatically enhance your LLM applications' capabilities and reliability."}),"\n",(0,s.jsx)(n.h2,{children:"Advanced Prompt Engineering Techniques"}),"\n",(0,s.jsx)(n.h3,{children:"1. Few-Shot Learning Patterns"}),"\n",(0,s.jsx)(n.p,{children:"Few-shot prompting provides examples to guide the model's behavior and output format."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'class FewShotPromptBuilder:\n    def __init__(self):\n        self.examples = {}\n    \n    def add_example(self, category: str, input_text: str, output_text: str):\n        """Add an example for few-shot learning"""\n        if category not in self.examples:\n            self.examples[category] = []\n        \n        self.examples[category].append({\n            "input": input_text,\n            "output": output_text\n        })\n    \n    def build_prompt(self, category: str, query: str, max_examples: int = 3) -> str:\n        """Build a few-shot prompt with examples"""\n        if category not in self.examples:\n            return query\n        \n        examples = self.examples[category][:max_examples]\n        \n        prompt_parts = [\n            "Here are some examples of the expected format:",\n            ""\n        ]\n        \n        for i, example in enumerate(examples, 1):\n            prompt_parts.extend([\n                "Example " + str(i) + ":",\n                "Input: " + example["input"],\n                "Output: " + example["output"],\n                ""\n            ])\n        \n        prompt_parts.extend([\n            "Now, please process this input:",\n            "Input: " + query,\n            "Output:"\n        ])\n        \n        return "\\n".join(prompt_parts)\n\n# Usage for code generation\nprompt_builder = FewShotPromptBuilder()\n\n# Add examples for Python function generation\nprompt_builder.add_example(\n    "python_function",\n    "Create a function to calculate factorial",\n    """def factorial(n):\n    if n <= 1:\n        return 1\n    return n * factorial(n - 1)"""\n)\n\nprompt_builder.add_example(\n    "python_function", \n    "Create a function to check if a string is palindrome",\n    """def is_palindrome(s):\n    s = s.lower().replace(\' \', \'\')\n    return s == s[::-1]"""\n)\n\n# Generate prompt for new task\nprompt = prompt_builder.build_prompt(\n    "python_function",\n    "Create a function to find the maximum element in a list"\n)\n'})}),"\n",(0,s.jsx)(n.h3,{children:"2. Chain-of-Thought (CoT) Reasoning"}),"\n",(0,s.jsx)(n.p,{children:"Chain-of-thought prompting encourages step-by-step reasoning for complex problems."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'class ChainOfThoughtPrompt:\n    def __init__(self):\n        self.reasoning_templates = {\n            "problem_solving": """Let\'s solve this step by step:\n\n1. First, I need to understand what the problem is asking\n2. Then, I\'ll identify the key information given\n3. Next, I\'ll determine what approach to use\n4. Finally, I\'ll work through the solution step by step\n\nProblem: {problem}\n\nStep-by-step solution:""",\n            \n            "code_debugging": """Let me debug this code systematically:\n\n1. First, I\'ll read through the code to understand its purpose\n2. Then, I\'ll identify potential issues or errors\n3. Next, I\'ll analyze the logic flow\n4. Finally, I\'ll provide the corrected version with explanations\n\nCode to debug: {code}\n\nDebugging analysis:""",\n            \n            "data_analysis": """Let me analyze this data step by step:\n\n1. First, I\'ll examine the data structure and format\n2. Then, I\'ll identify patterns and key metrics\n3. Next, I\'ll consider what insights can be drawn\n4. Finally, I\'ll provide conclusions and recommendations\n\nData: {data}\n\nAnalysis:"""\n        }\n    \n    def generate_cot_prompt(self, template_type: str, **kwargs) -> str:\n        """Generate a chain-of-thought prompt"""\n        if template_type not in self.reasoning_templates:\n            raise ValueError("Unknown template type: " + template_type)\n        \n        return self.reasoning_templates[template_type].format(**kwargs)\n    \n    def create_custom_cot(self, problem_description: str, steps: list) -> str:\n        """Create a custom chain-of-thought prompt"""\n        prompt_parts = [\n            "Let\'s approach this systematically:",\n            ""\n        ]\n        \n        for i, step in enumerate(steps, 1):\n            prompt_parts.append(str(i) + ". " + step)\n        \n        prompt_parts.extend([\n            "",\n            "Problem: " + problem_description,\n            "",\n            "Step-by-step solution:"\n        ])\n        \n        return "\\n".join(prompt_parts)\n\n# Usage example\ncot = ChainOfThoughtPrompt()\n\n# For complex problem solving\nmath_prompt = cot.generate_cot_prompt(\n    "problem_solving",\n    problem="A company\'s revenue increased by 25% in Q1, decreased by 15% in Q2, and increased by 30% in Q3. If the Q3 revenue was $169,000, what was the initial revenue?"\n)\n\n# For code debugging\ndebug_prompt = cot.generate_cot_prompt(\n    "code_debugging",\n    code="""def find_average(numbers):\n    total = 0\n    for num in numbers:\n        total += num\n    return total / len(numbers)\n\nresult = find_average([])"""\n)\n'})}),"\n",(0,s.jsx)(n.h3,{children:"3. Tree-of-Thought for Complex Decision Making"}),"\n",(0,s.jsx)(n.p,{children:"Tree-of-thought explores multiple reasoning paths and evaluates them."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'class TreeOfThoughtPrompt:\n    def __init__(self, llm_client):\n        self.client = llm_client\n    \n    async def generate_thoughts(self, problem: str, num_thoughts: int = 3) -> list:\n        """Generate multiple initial thought paths"""\n        prompt = """Problem: {problem}\n\nGenerate {num_thoughts} different approaches or initial thoughts for solving this problem. \nFormat each as:\nThought X: [brief approach description]\n\nThoughts:""".format(problem=problem, num_thoughts=num_thoughts)\n        \n        response = await self.client.complete([\n            {"role": "user", "content": prompt}\n        ], temperature=0.8)\n        \n        # Parse thoughts from response\n        content = response["choices"][0]["message"]["content"]\n        thoughts = []\n        \n        for line in content.split(\'\\n\'):\n            if line.strip().startswith(\'Thought\'):\n                thought = line.split(\':\', 1)[1].strip() if \':\' in line else line.strip()\n                thoughts.append(thought)\n        \n        return thoughts[:num_thoughts]\n    \n    async def evaluate_thought(self, problem: str, thought: str) -> float:\n        """Evaluate the quality/feasibility of a thought"""\n        eval_prompt = """Problem: {problem}\n\nProposed approach: {thought}\n\nEvaluate this approach on a scale of 1-10 considering:\n- Feasibility (can it actually work?)\n- Efficiency (is it a good use of resources?)\n- Completeness (does it address the full problem?)\n\nProvide only a numeric score (1-10):""".format(problem=problem, thought=thought)\n        \n        response = await self.client.complete([\n            {"role": "user", "content": eval_prompt}\n        ], temperature=0.1, max_tokens=10)\n        \n        try:\n            score = float(response["choices"][0]["message"]["content"].strip())\n            return min(max(score, 1), 10)  # Clamp between 1-10\n        except ValueError:\n            return 5.0  # Default score if parsing fails\n    \n    async def expand_thought(self, problem: str, thought: str) -> str:\n        """Expand a thought into detailed steps"""\n        expand_prompt = """Problem: {problem}\n\nApproach: {thought}\n\nExpand this approach into detailed, actionable steps. Be specific and practical:\n\nDetailed steps:""".format(problem=problem, thought=thought)\n        \n        response = await self.client.complete([\n            {"role": "user", "content": expand_prompt}\n        ], temperature=0.3)\n        \n        return response["choices"][0]["message"]["content"]\n    \n    async def solve_with_tot(self, problem: str) -> dict:\n        """Solve a problem using tree-of-thought approach"""\n        # Generate initial thoughts\n        thoughts = await self.generate_thoughts(problem)\n        \n        # Evaluate each thought\n        evaluations = []\n        for thought in thoughts:\n            score = await self.evaluate_thought(problem, thought)\n            evaluations.append((thought, score))\n        \n        # Sort by score and select best thoughts\n        evaluations.sort(key=lambda x: x[1], reverse=True)\n        best_thoughts = evaluations[:2]  # Top 2 thoughts\n        \n        # Expand the best thoughts\n        expanded_solutions = []\n        for thought, score in best_thoughts:\n            expanded = await self.expand_thought(problem, thought)\n            expanded_solutions.append({\n                "approach": thought,\n                "score": score,\n                "detailed_solution": expanded\n            })\n        \n        return {\n            "problem": problem,\n            "all_thoughts": evaluations,\n            "best_solutions": expanded_solutions\n        }\n\n# Usage example\nasync def main():\n    # Assuming you have an LLM client\n    tot = TreeOfThoughtPrompt(llm_client)\n    \n    result = await tot.solve_with_tot(\n        "Design a system to handle 1 million concurrent users for a social media platform"\n    )\n    \n    print("Best Solutions:")\n    for i, solution in enumerate(result["best_solutions"], 1):\n        print("Solution " + str(i) + " (Score: " + str(solution["score"]) + "):")\n        print(solution["approach"])\n        print(solution["detailed_solution"])\n        print("-" * 50)\n'})}),"\n",(0,s.jsx)(n.h2,{children:"Building Production-Ready RAG Systems"}),"\n",(0,s.jsx)(n.h3,{children:"1. RAG Architecture and Components"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'import numpy as np\nfrom typing import List, Dict, Any, Optional\nimport chromadb\nfrom sentence_transformers import SentenceTransformer\nimport asyncio\n\nclass DocumentChunker:\n    def __init__(self, chunk_size: int = 1000, overlap: int = 200):\n        self.chunk_size = chunk_size\n        self.overlap = overlap\n    \n    def chunk_text(self, text: str, metadata: dict = None) -> List[dict]:\n        """Split text into overlapping chunks"""\n        words = text.split()\n        chunks = []\n        \n        for i in range(0, len(words), self.chunk_size - self.overlap):\n            chunk_words = words[i:i + self.chunk_size]\n            chunk_text = \' \'.join(chunk_words)\n            \n            chunk_metadata = {\n                "chunk_index": len(chunks),\n                "start_word": i,\n                "end_word": i + len(chunk_words),\n                **(metadata or {})\n            }\n            \n            chunks.append({\n                "content": chunk_text,\n                "metadata": chunk_metadata\n            })\n        \n        return chunks\n    \n    def semantic_chunking(self, text: str, encoder, similarity_threshold: float = 0.8) -> List[dict]:\n        """Chunk text based on semantic similarity"""\n        sentences = text.split(\'. \')\n        if len(sentences) < 2:\n            return [{"content": text, "metadata": {"chunk_index": 0}}]\n        \n        # Encode sentences\n        embeddings = encoder.encode(sentences)\n        \n        chunks = []\n        current_chunk = [sentences[0]]\n        \n        for i in range(1, len(sentences)):\n            # Calculate similarity with current chunk\n            current_embedding = np.mean([embeddings[j] for j in range(len(current_chunk))], axis=0)\n            similarity = np.dot(current_embedding, embeddings[i]) / (\n                np.linalg.norm(current_embedding) * np.linalg.norm(embeddings[i])\n            )\n            \n            if similarity > similarity_threshold and len(\' \'.join(current_chunk)) < self.chunk_size:\n                current_chunk.append(sentences[i])\n            else:\n                # Finalize current chunk and start new one\n                chunks.append({\n                    "content": \'. \'.join(current_chunk),\n                    "metadata": {"chunk_index": len(chunks)}\n                })\n                current_chunk = [sentences[i]]\n        \n        # Add final chunk\n        if current_chunk:\n            chunks.append({\n                "content": \'. \'.join(current_chunk),\n                "metadata": {"chunk_index": len(chunks)}\n            })\n        \n        return chunks\n\nclass VectorStore:\n    def __init__(self, collection_name: str = "documents"):\n        self.client = chromadb.Client()\n        self.collection = self.client.create_collection(collection_name)\n        self.encoder = SentenceTransformer(\'all-MiniLM-L6-v2\')\n    \n    def add_documents(self, documents: List[dict]):\n        """Add documents to the vector store"""\n        contents = [doc["content"] for doc in documents]\n        metadatas = [doc["metadata"] for doc in documents]\n        ids = [str(i) for i in range(len(documents))]\n        \n        # Generate embeddings\n        embeddings = self.encoder.encode(contents).tolist()\n        \n        self.collection.add(\n            embeddings=embeddings,\n            documents=contents,\n            metadatas=metadatas,\n            ids=ids\n        )\n    \n    def search(self, query: str, top_k: int = 5) -> List[dict]:\n        """Search for relevant documents"""\n        query_embedding = self.encoder.encode([query]).tolist()\n        \n        results = self.collection.query(\n            query_embeddings=query_embedding,\n            n_results=top_k\n        )\n        \n        documents = []\n        for i in range(len(results["documents"][0])):\n            documents.append({\n                "content": results["documents"][0][i],\n                "metadata": results["metadatas"][0][i],\n                "distance": results["distances"][0][i]\n            })\n        \n        return documents\n\nclass RAGSystem:\n    def __init__(self, llm_client, vector_store: VectorStore):\n        self.llm_client = llm_client\n        self.vector_store = vector_store\n        self.chunker = DocumentChunker()\n    \n    def ingest_document(self, content: str, metadata: dict = None):\n        """Ingest a document into the RAG system"""\n        chunks = self.chunker.chunk_text(content, metadata)\n        self.vector_store.add_documents(chunks)\n    \n    async def retrieve_and_generate(\n        self, \n        query: str, \n        top_k: int = 5,\n        system_prompt: str = None\n    ) -> dict:\n        """Retrieve relevant documents and generate response"""\n        \n        # Retrieve relevant documents\n        relevant_docs = self.vector_store.search(query, top_k=top_k)\n        \n        # Build context from retrieved documents\n        context_parts = []\n        for i, doc in enumerate(relevant_docs, 1):\n            context_parts.append("Document " + str(i) + ":")\n            context_parts.append(doc["content"])\n            context_parts.append("")\n        \n        context = "\\n".join(context_parts)\n        \n        # Build RAG prompt\n        default_system = """You are a helpful assistant that answers questions based on the provided context. \nUse only the information from the context to answer questions. If the answer cannot be found in the context, say so clearly."""\n        \n        system_message = system_prompt or default_system\n        \n        user_prompt = """Context:\n{context}\n\nQuestion: {query}\n\nPlease provide a detailed answer based on the context above:""".format(\n            context=context,\n            query=query\n        )\n        \n        # Generate response\n        response = await self.llm_client.complete([\n            {"role": "system", "content": system_message},\n            {"role": "user", "content": user_prompt}\n        ])\n        \n        return {\n            "query": query,\n            "answer": response["choices"][0]["message"]["content"],\n            "sources": relevant_docs,\n            "context_used": context\n        }\n    \n    async def conversational_rag(\n        self, \n        query: str, \n        conversation_history: List[dict],\n        top_k: int = 5\n    ) -> dict:\n        """RAG with conversation history"""\n        \n        # Create a comprehensive query including conversation context\n        history_context = ""\n        if conversation_history:\n            recent_history = conversation_history[-3:]  # Last 3 exchanges\n            history_parts = []\n            for exchange in recent_history:\n                if exchange["role"] == "user":\n                    history_parts.append("User: " + exchange["content"])\n                elif exchange["role"] == "assistant":\n                    history_parts.append("Assistant: " + exchange["content"])\n            \n            history_context = "\\n".join(history_parts)\n        \n        # Enhanced query for better retrieval\n        enhanced_query = query\n        if history_context:\n            enhanced_query = "Previous conversation:\\n" + history_context + "\\n\\nCurrent question: " + query\n        \n        # Use the enhanced query for retrieval\n        relevant_docs = self.vector_store.search(enhanced_query, top_k=top_k)\n        \n        # Build context\n        context_parts = []\n        for i, doc in enumerate(relevant_docs, 1):\n            context_parts.append("Document " + str(i) + ":")\n            context_parts.append(doc["content"])\n            context_parts.append("")\n        \n        context = "\\n".join(context_parts)\n        \n        # Build conversational RAG prompt\n        messages = [\n            {\n                "role": "system", \n                "content": """You are a helpful assistant that answers questions based on provided context and conversation history. \nUse the context and previous conversation to provide coherent, contextual responses."""\n            }\n        ]\n        \n        # Add conversation history\n        messages.extend(conversation_history[-5:])  # Last 5 messages\n        \n        # Add current query with context\n        current_prompt = """Context:\n{context}\n\nQuestion: {query}\n\nAnswer:""".format(context=context, query=query)\n        \n        messages.append({"role": "user", "content": current_prompt})\n        \n        response = await self.llm_client.complete(messages)\n        \n        return {\n            "query": query,\n            "answer": response["choices"][0]["message"]["content"],\n            "sources": relevant_docs,\n            "enhanced_query": enhanced_query\n        }\n'})}),"\n",(0,s.jsx)(n.h3,{children:"2. Advanced RAG Techniques"}),"\n",(0,s.jsx)(n.h4,{children:"Hybrid Search (Keyword + Semantic)"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'from elasticsearch import Elasticsearch\nimport numpy as np\n\nclass HybridSearchRAG:\n    def __init__(self, llm_client, es_host: str = "localhost:9200"):\n        self.llm_client = llm_client\n        self.es_client = Elasticsearch([es_host])\n        self.encoder = SentenceTransformer(\'all-MiniLM-L6-v2\')\n        self.index_name = "hybrid_docs"\n    \n    def create_index(self):\n        """Create Elasticsearch index with dense vector support"""\n        mapping = {\n            "mappings": {\n                "properties": {\n                    "content": {"type": "text"},\n                    "embedding": {\n                        "type": "dense_vector",\n                        "dims": 384  # all-MiniLM-L6-v2 dimension\n                    },\n                    "metadata": {"type": "object"}\n                }\n            }\n        }\n        \n        if self.es_client.indices.exists(index=self.index_name):\n            self.es_client.indices.delete(index=self.index_name)\n        \n        self.es_client.indices.create(index=self.index_name, body=mapping)\n    \n    def add_document(self, content: str, metadata: dict = None):\n        """Add document with both text and vector representation"""\n        embedding = self.encoder.encode(content).tolist()\n        \n        doc = {\n            "content": content,\n            "embedding": embedding,\n            "metadata": metadata or {}\n        }\n        \n        self.es_client.index(index=self.index_name, body=doc)\n    \n    def hybrid_search(self, query: str, top_k: int = 5, alpha: float = 0.5) -> List[dict]:\n        """\n        Perform hybrid search combining keyword and semantic search\n        alpha: weight for semantic search (1-alpha for keyword search)\n        """\n        \n        # Keyword search\n        keyword_query = {\n            "query": {\n                "match": {\n                    "content": query\n                }\n            },\n            "size": top_k * 2  # Get more results for reranking\n        }\n        \n        keyword_results = self.es_client.search(index=self.index_name, body=keyword_query)\n        \n        # Semantic search\n        query_embedding = self.encoder.encode(query).tolist()\n        semantic_query = {\n            "query": {\n                "script_score": {\n                    "query": {"match_all": {}},\n                    "script": {\n                        "source": "cosineSimilarity(params.query_vector, \'embedding\') + 1.0",\n                        "params": {"query_vector": query_embedding}\n                    }\n                }\n            },\n            "size": top_k * 2\n        }\n        \n        semantic_results = self.es_client.search(index=self.index_name, body=semantic_query)\n        \n        # Combine and rerank results\n        combined_scores = {}\n        \n        # Add keyword scores\n        for hit in keyword_results["hits"]["hits"]:\n            doc_id = hit["_id"]\n            keyword_score = hit["_score"]\n            combined_scores[doc_id] = {\n                "keyword_score": keyword_score,\n                "semantic_score": 0,\n                "doc": hit["_source"]\n            }\n        \n        # Add semantic scores\n        for hit in semantic_results["hits"]["hits"]:\n            doc_id = hit["_id"]\n            semantic_score = hit["_score"]\n            \n            if doc_id in combined_scores:\n                combined_scores[doc_id]["semantic_score"] = semantic_score\n            else:\n                combined_scores[doc_id] = {\n                    "keyword_score": 0,\n                    "semantic_score": semantic_score,\n                    "doc": hit["_source"]\n                }\n        \n        # Calculate final scores and rank\n        final_results = []\n        for doc_id, scores in combined_scores.items():\n            # Normalize scores (simple min-max normalization)\n            keyword_normalized = scores["keyword_score"] / 10.0  # Adjust based on your data\n            semantic_normalized = (scores["semantic_score"] - 1.0) / 1.0  # Cosine similarity range\n            \n            final_score = alpha * semantic_normalized + (1 - alpha) * keyword_normalized\n            \n            final_results.append({\n                "content": scores["doc"]["content"],\n                "metadata": scores["doc"]["metadata"],\n                "final_score": final_score,\n                "keyword_score": scores["keyword_score"],\n                "semantic_score": scores["semantic_score"]\n            })\n        \n        # Sort by final score and return top k\n        final_results.sort(key=lambda x: x["final_score"], reverse=True)\n        return final_results[:top_k]\n    \n    async def query_with_hybrid_search(self, query: str, top_k: int = 5) -> dict:\n        """Query using hybrid search and generate response"""\n        relevant_docs = self.hybrid_search(query, top_k)\n        \n        # Build context\n        context_parts = []\n        for i, doc in enumerate(relevant_docs, 1):\n            context_parts.append("Document " + str(i) + " (Score: " + str(round(doc["final_score"], 3)) + "):")\n            context_parts.append(doc["content"])\n            context_parts.append("")\n        \n        context = "\\n".join(context_parts)\n        \n        # Generate response\n        prompt = """Context:\n{context}\n\nQuestion: {query}\n\nBased on the context above, provide a comprehensive answer:""".format(\n            context=context,\n            query=query\n        )\n        \n        response = await self.llm_client.complete([\n            {"role": "user", "content": prompt}\n        ])\n        \n        return {\n            "query": query,\n            "answer": response["choices"][0]["message"]["content"],\n            "sources": relevant_docs\n        }\n'})}),"\n",(0,s.jsx)(n.h4,{children:"Multi-Query RAG"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'class MultiQueryRAG:\n    def __init__(self, llm_client, vector_store: VectorStore):\n        self.llm_client = llm_client\n        self.vector_store = vector_store\n    \n    async def generate_query_variations(self, original_query: str, num_variations: int = 3) -> List[str]:\n        """Generate variations of the original query for better retrieval"""\n        prompt = """Given the following question, generate {num_variations} different ways to ask the same question. \nThese variations should help retrieve more comprehensive information.\n\nOriginal question: {query}\n\nGenerate {num_variations} question variations (one per line):""".format(\n            query=original_query,\n            num_variations=num_variations\n        )\n        \n        response = await self.llm_client.complete([\n            {"role": "user", "content": prompt}\n        ], temperature=0.7)\n        \n        variations = []\n        lines = response["choices"][0]["message"]["content"].strip().split(\'\\n\')\n        \n        for line in lines:\n            line = line.strip()\n            if line and not line.startswith(\'Original\'):\n                # Remove numbering if present\n                if line[0].isdigit() and \'.\' in line[:3]:\n                    line = line.split(\'.\', 1)[1].strip()\n                variations.append(line)\n        \n        return variations[:num_variations]\n    \n    async def multi_query_retrieve(\n        self, \n        query: str, \n        num_variations: int = 3,\n        docs_per_query: int = 3\n    ) -> List[dict]:\n        """Retrieve documents using multiple query variations"""\n        \n        # Generate query variations\n        query_variations = await self.generate_query_variations(query, num_variations)\n        all_queries = [query] + query_variations\n        \n        # Retrieve documents for each query\n        all_docs = []\n        seen_content = set()\n        \n        for q in all_queries:\n            docs = self.vector_store.search(q, top_k=docs_per_query)\n            \n            for doc in docs:\n                # Avoid duplicates based on content\n                content_hash = hash(doc["content"])\n                if content_hash not in seen_content:\n                    doc["retrieved_by_query"] = q\n                    all_docs.append(doc)\n                    seen_content.add(content_hash)\n        \n        # Sort by relevance score and return top documents\n        all_docs.sort(key=lambda x: x["distance"])\n        return all_docs[:docs_per_query * len(all_queries)]\n    \n    async def answer_with_multi_query(self, query: str) -> dict:\n        """Answer using multi-query RAG approach"""\n        \n        # Retrieve using multiple queries\n        relevant_docs = await self.multi_query_retrieve(query)\n        \n        # Build enhanced context\n        context_parts = []\n        context_parts.append("Retrieved information from multiple search perspectives:")\n        context_parts.append("")\n        \n        for i, doc in enumerate(relevant_docs, 1):\n            context_parts.append("Source " + str(i) + " (found via: \'" + doc["retrieved_by_query"] + "\'):")\n            context_parts.append(doc["content"])\n            context_parts.append("")\n        \n        context = "\\n".join(context_parts)\n        \n        # Generate comprehensive response\n        prompt = """You have been provided with information retrieved using multiple search approaches for better coverage.\n\n{context}\n\nOriginal question: {query}\n\nProvide a comprehensive answer that synthesizes information from all the sources:""".format(\n            context=context,\n            query=query\n        )\n        \n        response = await self.llm_client.complete([\n            {"role": "user", "content": prompt}\n        ])\n        \n        return {\n            "query": query,\n            "answer": response["choices"][0]["message"]["content"],\n            "sources": relevant_docs,\n            "num_sources": len(relevant_docs)\n        }\n'})}),"\n",(0,s.jsx)(n.h2,{children:"Evaluation and Quality Assurance"}),"\n",(0,s.jsx)(n.h3,{children:"RAG Evaluation Framework"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'class RAGEvaluator:\n    def __init__(self, llm_client):\n        self.llm_client = llm_client\n    \n    async def evaluate_relevance(self, query: str, retrieved_docs: List[dict]) -> List[float]:\n        """Evaluate relevance of retrieved documents to the query"""\n        relevance_scores = []\n        \n        for doc in retrieved_docs:\n            prompt = """Evaluate how relevant this document is to the given query on a scale of 1-10.\n\nQuery: {query}\n\nDocument: {document}\n\nConsider:\n- Does the document contain information that helps answer the query?\n- How directly related is the content to the query?\n- Would this document be useful for someone trying to answer the query?\n\nProvide only a numeric score (1-10):""".format(\n                query=query,\n                document=doc["content"]\n            )\n            \n            response = await self.llm_client.complete([\n                {"role": "user", "content": prompt}\n            ], temperature=0.1, max_tokens=5)\n            \n            try:\n                score = float(response["choices"][0]["message"]["content"].strip())\n                relevance_scores.append(min(max(score, 1), 10))\n            except ValueError:\n                relevance_scores.append(5.0)  # Default score\n        \n        return relevance_scores\n    \n    async def evaluate_answer_quality(\n        self, \n        query: str, \n        generated_answer: str, \n        ground_truth: str = None\n    ) -> dict:\n        """Evaluate the quality of the generated answer"""\n        \n        evaluation_criteria = [\n            "Accuracy: Is the information factually correct?",\n            "Completeness: Does it fully address the query?", \n            "Clarity: Is it easy to understand?",\n            "Relevance: Does it stay focused on the query?"\n        ]\n        \n        evaluation_results = {}\n        \n        for criterion in evaluation_criteria:\n            prompt = """Evaluate the following answer based on this criterion: {criterion}\n\nQuery: {query}\nAnswer: {answer}\n\nRate on a scale of 1-10 and provide a brief explanation.\n\nFormat: Score: X/10\nExplanation: [brief explanation]""".format(\n                criterion=criterion,\n                query=query,\n                answer=generated_answer\n            )\n            \n            response = await self.llm_client.complete([\n                {"role": "user", "content": prompt}\n            ], temperature=0.2)\n            \n            content = response["choices"][0]["message"]["content"]\n            \n            # Parse score and explanation\n            score = 5.0  # default\n            explanation = content\n            \n            if "Score:" in content:\n                try:\n                    score_line = [line for line in content.split(\'\\n\') if \'Score:\' in line][0]\n                    score = float(score_line.split(\'Score:\')[1].split(\'/\')[0].strip())\n                except:\n                    pass\n            \n            criterion_name = criterion.split(\':\')[0].lower()\n            evaluation_results[criterion_name] = {\n                "score": score,\n                "explanation": explanation\n            }\n        \n        # Calculate overall score\n        overall_score = sum(result["score"] for result in evaluation_results.values()) / len(evaluation_results)\n        evaluation_results["overall"] = {"score": overall_score}\n        \n        return evaluation_results\n    \n    async def evaluate_rag_system(\n        self, \n        test_queries: List[dict],  # [{"query": "...", "expected_answer": "..."}]\n        rag_system\n    ) -> dict:\n        """Comprehensive evaluation of RAG system"""\n        \n        results = {\n            "total_queries": len(test_queries),\n            "average_relevance": 0,\n            "average_quality": 0,\n            "detailed_results": []\n        }\n        \n        total_relevance = 0\n        total_quality = 0\n        \n        for test_case in test_queries:\n            query = test_case["query"]\n            expected = test_case.get("expected_answer", "")\n            \n            # Get RAG response\n            rag_response = await rag_system.retrieve_and_generate(query)\n            \n            # Evaluate retrieval relevance\n            relevance_scores = await self.evaluate_relevance(query, rag_response["sources"])\n            avg_relevance = sum(relevance_scores) / len(relevance_scores) if relevance_scores else 0\n            \n            # Evaluate answer quality\n            quality_eval = await self.evaluate_answer_quality(\n                query, \n                rag_response["answer"], \n                expected\n            )\n            \n            result = {\n                "query": query,\n                "answer": rag_response["answer"],\n                "relevance_score": avg_relevance,\n                "quality_score": quality_eval["overall"]["score"],\n                "sources_count": len(rag_response["sources"]),\n                "detailed_quality": quality_eval\n            }\n            \n            results["detailed_results"].append(result)\n            total_relevance += avg_relevance\n            total_quality += quality_eval["overall"]["score"]\n        \n        results["average_relevance"] = total_relevance / len(test_queries)\n        results["average_quality"] = total_quality / len(test_queries)\n        \n        return results\n\n# Usage example\nasync def main():\n    evaluator = RAGEvaluator(llm_client)\n    \n    test_queries = [\n        {\n            "query": "What are the benefits of using Python for data science?",\n            "expected_answer": "Python offers libraries like pandas, numpy, excellent community support..."\n        },\n        {\n            "query": "How do you implement a REST API?",\n            "expected_answer": "REST APIs can be implemented using frameworks like Flask, FastAPI..."\n        }\n    ]\n    \n    evaluation_results = await evaluator.evaluate_rag_system(test_queries, rag_system)\n    \n    print("Average Relevance Score:", evaluation_results["average_relevance"])\n    print("Average Quality Score:", evaluation_results["average_quality"])\n'})}),"\n",(0,s.jsx)(n.h2,{children:"Key Takeaways for Part 2"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Advanced Prompting"}),": Use few-shot, chain-of-thought, and tree-of-thought techniques for better results"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"RAG Architecture"}),": Build robust retrieval systems with proper chunking and vector storage"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Hybrid Search"}),": Combine keyword and semantic search for better retrieval"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Multi-Query Approach"}),": Use query variations to capture more relevant information"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Evaluation is Critical"}),": Implement systematic evaluation for both retrieval and generation quality"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{children:"What's Next?"}),"\n",(0,s.jsxs)(n.p,{children:["In ",(0,s.jsx)(n.strong,{children:"Part 3"}),", we'll focus on production deployment and scaling of LLM applications, covering infrastructure patterns, monitoring, security, and performance optimization strategies."]}),"\n",(0,s.jsx)(n.p,{children:"We'll cover:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Infrastructure and deployment patterns"}),"\n",(0,s.jsx)(n.li,{children:"Monitoring and observability for LLM applications"}),"\n",(0,s.jsx)(n.li,{children:"Security, safety, and compliance considerations"}),"\n",(0,s.jsx)(n.li,{children:"Scaling strategies and performance optimization"}),"\n",(0,s.jsx)(n.li,{children:"Cost optimization and resource management"}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:"This series provides practical, implementation-focused guidance for engineers building production LLM applications."})})]})}function l(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(o,{...e})}):o(e)}},78027:function(e,n,t){t.r(n),t.d(n,{default:function(){return l},frontmatter:function(){return a},metadata:function(){return i}});var s=t(57437),r=t(52671);let a=void 0,i={postId:"2a8f6e4c-7b5d-4e9a-a1c3-6d8e9f0a1b2c",title:"LLM Engineering Mastery: Part 3 - Production Deployment and Scaling",date:"2024-02-10",excerpt:"Part 3 of the LLM Engineering Mastery series: Master production deployment, scaling strategies, monitoring, and security for enterprise-grade LLM applications.",author:"Abstract Algorithms",tags:["llm","production","deployment","scaling","monitoring","security"],coverImage:"/posts/llm-engineering-part-3/assets/overview.png",series:{name:"LLM Engineering Mastery",order:3,total:3,prev:"/posts/llm-engineering-mastery-part-2-advanced-prompt-engineering-and-rag-systems",coverImage:"/posts/llm-engineering-part-3/assets/assets/llm-engineering-series.png",overview:"/posts/llm-engineering-mastery-series/"}};function o(e){let n={blockquote:"blockquote",br:"br",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{children:"LLM Engineering Mastery: Part 3 - Production Deployment and Scaling"}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Part 3 of the LLM Engineering Mastery Series"}),(0,s.jsx)(n.br,{}),"\n","The final part completes your LLM engineering journey with production deployment strategies, scaling patterns, monitoring, and security. Turn your LLM applications into enterprise-grade systems."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"In this final part of the LLM Engineering Mastery series, we'll cover everything you need to deploy, scale, and maintain LLM applications in production environments. From infrastructure patterns to monitoring and security, this guide provides the practical knowledge needed for enterprise-grade deployments."}),"\n",(0,s.jsx)(n.h2,{children:"Infrastructure Patterns for LLM Applications"}),"\n",(0,s.jsx)(n.h3,{children:"1. Microservices Architecture for LLM Systems"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'from fastapi import FastAPI, HTTPException, Depends\nfrom pydantic import BaseModel\nfrom typing import List, Optional\nimport asyncio\nimport httpx\nfrom datetime import datetime\nimport logging\n\n# Data models\nclass ChatRequest(BaseModel):\n    messages: List[dict]\n    model: str = "gpt-3.5-turbo"\n    temperature: float = 0.7\n    max_tokens: int = 1000\n\nclass RAGRequest(BaseModel):\n    query: str\n    collection: str = "default"\n    top_k: int = 5\n\nclass ChatResponse(BaseModel):\n    response: str\n    model_used: str\n    tokens_used: int\n    processing_time: float\n    request_id: str\n\n# LLM Service\nclass LLMService:\n    def __init__(self):\n        self.app = FastAPI(title="LLM Service", version="1.0.0")\n        self.setup_routes()\n        self.setup_middleware()\n    \n    def setup_middleware(self):\n        @self.app.middleware("http")\n        async def log_requests(request, call_next):\n            start_time = datetime.now()\n            \n            response = await call_next(request)\n            \n            processing_time = (datetime.now() - start_time).total_seconds()\n            \n            logging.info(\n                "Request processed",\n                extra={\n                    "method": request.method,\n                    "url": str(request.url),\n                    "status_code": response.status_code,\n                    "processing_time": processing_time\n                }\n            )\n            \n            return response\n    \n    def setup_routes(self):\n        @self.app.post("/chat/completions", response_model=ChatResponse)\n        async def chat_completion(request: ChatRequest):\n            start_time = datetime.now()\n            \n            try:\n                # Route to appropriate model provider\n                if request.model.startswith("gpt"):\n                    result = await self._call_openai(request)\n                elif request.model.startswith("claude"):\n                    result = await self._call_anthropic(request)\n                else:\n                    raise HTTPException(status_code=400, detail="Unsupported model")\n                \n                processing_time = (datetime.now() - start_time).total_seconds()\n                \n                return ChatResponse(\n                    response=result["content"],\n                    model_used=request.model,\n                    tokens_used=result["tokens"],\n                    processing_time=processing_time,\n                    request_id=result["request_id"]\n                )\n                \n            except Exception as e:\n                logging.error("Chat completion failed", extra={"error": str(e)})\n                raise HTTPException(status_code=500, detail="Internal server error")\n        \n        @self.app.get("/health")\n        async def health_check():\n            return {"status": "healthy", "timestamp": datetime.now().isoformat()}\n        \n        @self.app.get("/models")\n        async def list_models():\n            return {\n                "available_models": [\n                    "gpt-3.5-turbo",\n                    "gpt-4-turbo", \n                    "claude-3-sonnet",\n                    "claude-3-haiku"\n                ]\n            }\n    \n    async def _call_openai(self, request: ChatRequest) -> dict:\n        # Implementation for OpenAI API calls\n        # This would include the robust client from Part 1\n        pass\n    \n    async def _call_anthropic(self, request: ChatRequest) -> dict:\n        # Implementation for Anthropic API calls\n        pass\n\n# RAG Service\nclass RAGService:\n    def __init__(self, llm_service_url: str):\n        self.app = FastAPI(title="RAG Service", version="1.0.0")\n        self.llm_service_url = llm_service_url\n        self.setup_routes()\n    \n    def setup_routes(self):\n        @self.app.post("/rag/query")\n        async def rag_query(request: RAGRequest):\n            try:\n                # Retrieve relevant documents\n                relevant_docs = await self._retrieve_documents(\n                    request.query, \n                    request.collection, \n                    request.top_k\n                )\n                \n                # Build context\n                context = self._build_context(relevant_docs)\n                \n                # Generate response using LLM service\n                llm_request = ChatRequest(\n                    messages=[\n                        {\n                            "role": "system",\n                            "content": "Answer based on the provided context."\n                        },\n                        {\n                            "role": "user", \n                            "content": "Context:\\n" + context + "\\n\\nQuestion: " + request.query\n                        }\n                    ]\n                )\n                \n                async with httpx.AsyncClient() as client:\n                    response = await client.post(\n                        self.llm_service_url + "/chat/completions",\n                        json=llm_request.dict()\n                    )\n                    response.raise_for_status()\n                    llm_response = response.json()\n                \n                return {\n                    "answer": llm_response["response"],\n                    "sources": relevant_docs,\n                    "tokens_used": llm_response["tokens_used"]\n                }\n                \n            except Exception as e:\n                logging.error("RAG query failed", extra={"error": str(e)})\n                raise HTTPException(status_code=500, detail="RAG processing failed")\n    \n    async def _retrieve_documents(self, query: str, collection: str, top_k: int):\n        # Implementation for document retrieval\n        # This would use the vector store from Part 2\n        pass\n    \n    def _build_context(self, documents: List[dict]) -> str:\n        context_parts = []\n        for i, doc in enumerate(documents, 1):\n            context_parts.append("Document " + str(i) + ":")\n            context_parts.append(doc["content"])\n            context_parts.append("")\n        return "\\n".join(context_parts)\n\n# API Gateway\nclass APIGateway:\n    def __init__(self, llm_service_url: str, rag_service_url: str):\n        self.app = FastAPI(title="LLM API Gateway", version="1.0.0")\n        self.llm_service_url = llm_service_url\n        self.rag_service_url = rag_service_url\n        self.setup_routes()\n        self.setup_middleware()\n    \n    def setup_middleware(self):\n        # Rate limiting, authentication, etc.\n        pass\n    \n    def setup_routes(self):\n        @self.app.post("/v1/chat/completions")\n        async def proxy_chat(request: ChatRequest):\n            async with httpx.AsyncClient() as client:\n                response = await client.post(\n                    self.llm_service_url + "/chat/completions",\n                    json=request.dict(),\n                    timeout=60.0\n                )\n                response.raise_for_status()\n                return response.json()\n        \n        @self.app.post("/v1/rag/query")\n        async def proxy_rag(request: RAGRequest):\n            async with httpx.AsyncClient() as client:\n                response = await client.post(\n                    self.rag_service_url + "/rag/query",\n                    json=request.dict(),\n                    timeout=60.0\n                )\n                response.raise_for_status()\n                return response.json()\n\n# Docker Compose for local development\ndocker_compose_content = """\nversion: \'3.8\'\n\nservices:\n  llm-service:\n    build: ./llm-service\n    ports:\n      - "8001:8000"\n    environment:      - OPENAI_API_KEY=\\$\\{OPENAI_API_KEY\\}\n      - ANTHROPIC_API_KEY=\\$\\{ANTHROPIC_API_KEY\\}\n    healthcheck:\n      test: ["CMD", "curl", "-f", "http://localhost:8000/health"]\n      interval: 30s\n      timeout: 10s\n      retries: 3\n\n  rag-service:\n    build: ./rag-service\n    ports:\n      - "8002:8000"\n    environment:\n      - LLM_SERVICE_URL=http://llm-service:8000\n      - VECTOR_DB_URL=\\$\\{VECTOR_DB_URL\\}\n    depends_on:\n      - llm-service\n      - vector-db\n    healthcheck:\n      test: ["CMD", "curl", "-f", "http://localhost:8000/health"]\n      interval: 30s\n      timeout: 10s\n      retries: 3\n\n  api-gateway:\n    build: ./api-gateway\n    ports:\n      - "8000:8000"\n    environment:\n      - LLM_SERVICE_URL=http://llm-service:8000\n      - RAG_SERVICE_URL=http://rag-service:8000\n    depends_on:\n      - llm-service\n      - rag-service\n\n  vector-db:\n    image: chromadb/chroma:latest\n    ports:\n      - "8003:8000"\n    volumes:\n      - vector_data:/chroma/chroma\n\n  redis:\n    image: redis:alpine\n    ports:\n      - "6379:6379"\n\n  prometheus:\n    image: prom/prometheus:latest\n    ports:\n      - "9090:9090"\n    volumes:\n      - ./prometheus.yml:/etc/prometheus/prometheus.yml\n\n  grafana:\n    image: grafana/grafana:latest\n    ports:\n      - "3000:3000"\n    environment:\n      - GF_SECURITY_ADMIN_PASSWORD=admin\n\nvolumes:\n  vector_data:\n"""\n'})}),"\n",(0,s.jsx)(n.h3,{children:"2. Kubernetes Deployment Configuration"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:'# llm-deployment.yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: llm-service\n  labels:\n    app: llm-service\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: llm-service\n  template:\n    metadata:\n      labels:\n        app: llm-service\n    spec:\n      containers:\n      - name: llm-service\n        image: your-registry/llm-service:latest\n        ports:\n        - containerPort: 8000\n        env:\n        - name: OPENAI_API_KEY\n          valueFrom:\n            secretKeyRef:\n              name: api-secrets\n              key: openai-api-key\n        - name: ANTHROPIC_API_KEY\n          valueFrom:\n            secretKeyRef:\n              name: api-secrets\n              key: anthropic-api-key\n        resources:\n          requests:\n            memory: "512Mi"\n            cpu: "250m"\n          limits:\n            memory: "1Gi"\n            cpu: "500m"\n        livenessProbe:\n          httpGet:\n            path: /health\n            port: 8000\n          initialDelaySeconds: 30\n          periodSeconds: 10\n        readinessProbe:\n          httpGet:\n            path: /health\n            port: 8000\n          initialDelaySeconds: 5\n          periodSeconds: 5\n\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: llm-service\nspec:\n  selector:\n    app: llm-service\n  ports:\n  - port: 80\n    targetPort: 8000\n  type: ClusterIP\n\n---\napiVersion: autoscaling/v2\nkind: HorizontalPodAutoscaler\nmetadata:\n  name: llm-service-hpa\nspec:\n  scaleTargetRef:\n    apiVersion: apps/v1\n    kind: Deployment\n    name: llm-service\n  minReplicas: 2\n  maxReplicas: 10\n  metrics:\n  - type: Resource\n    resource:\n      name: cpu\n      target:\n        type: Utilization\n        averageUtilization: 70\n  - type: Resource\n    resource:\n      name: memory\n      target:\n        type: Utilization\n        averageUtilization: 80\n\n---\n# Ingress for external access\napiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: llm-ingress\n  annotations:\n    nginx.ingress.kubernetes.io/rate-limit: "100"\n    nginx.ingress.kubernetes.io/rate-limit-window: "1m"\n    cert-manager.io/cluster-issuer: "letsencrypt-prod"\nspec:\n  tls:\n  - hosts:\n    - api.yourdomain.com\n    secretName: llm-tls\n  rules:\n  - host: api.yourdomain.com\n    http:\n      paths:\n      - path: /v1\n        pathType: Prefix\n        backend:\n          service:\n            name: api-gateway\n            port:\n              number: 80\n'})}),"\n",(0,s.jsx)(n.h2,{children:"Monitoring and Observability"}),"\n",(0,s.jsx)(n.h3,{children:"1. Comprehensive Monitoring System"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'import logging\nimport time\nfrom prometheus_client import Counter, Histogram, Gauge, start_http_server\nfrom functools import wraps\nimport structlog\nfrom typing import Any, Callable\nimport asyncio\n\n# Prometheus metrics\nREQUEST_COUNT = Counter(\n    \'llm_requests_total\',\n    \'Total number of LLM requests\',\n    [\'model\', \'endpoint\', \'status\']\n)\n\nREQUEST_DURATION = Histogram(\n    \'llm_request_duration_seconds\',\n    \'Time spent processing LLM requests\',\n    [\'model\', \'endpoint\']\n)\n\nTOKEN_USAGE = Counter(\n    \'llm_tokens_total\',\n    \'Total number of tokens processed\',\n    [\'model\', \'type\']  # type: input/output\n)\n\nCOST_TRACKING = Counter(\n    \'llm_cost_total_usd\',\n    \'Total cost in USD\',\n    [\'model\', \'provider\']\n)\n\nACTIVE_REQUESTS = Gauge(\n    \'llm_active_requests\',\n    \'Number of currently active requests\',\n    [\'model\']\n)\n\nERROR_RATE = Counter(\n    \'llm_errors_total\',\n    \'Total number of errors\',\n    [\'model\', \'error_type\']\n)\n\nclass MetricsCollector:\n    def __init__(self):\n        self.logger = structlog.get_logger()\n    \n    def record_request(self, model: str, endpoint: str, status: str):\n        """Record a request with its status"""\n        REQUEST_COUNT.labels(model=model, endpoint=endpoint, status=status).inc()\n    \n    def record_duration(self, model: str, endpoint: str, duration: float):\n        """Record request duration"""\n        REQUEST_DURATION.labels(model=model, endpoint=endpoint).observe(duration)\n    \n    def record_token_usage(self, model: str, input_tokens: int, output_tokens: int):\n        """Record token usage"""\n        TOKEN_USAGE.labels(model=model, type=\'input\').inc(input_tokens)\n        TOKEN_USAGE.labels(model=model, type=\'output\').inc(output_tokens)\n    \n    def record_cost(self, model: str, provider: str, cost: float):\n        """Record cost"""\n        COST_TRACKING.labels(model=model, provider=provider).inc(cost)\n    \n    def record_error(self, model: str, error_type: str):\n        """Record error"""\n        ERROR_RATE.labels(model=model, error_type=error_type).inc()\n    \n    def track_active_request(self, model: str, increment: bool = True):\n        """Track active requests"""\n        if increment:\n            ACTIVE_REQUESTS.labels(model=model).inc()\n        else:\n            ACTIVE_REQUESTS.labels(model=model).dec()\n\n# Monitoring decorator\ndef monitor_llm_request(model: str, endpoint: str):\n    def decorator(func: Callable) -> Callable:\n        @wraps(func)\n        async def async_wrapper(*args, **kwargs) -> Any:\n            metrics = MetricsCollector()\n            start_time = time.time()\n            \n            metrics.track_active_request(model, increment=True)\n            \n            try:\n                result = await func(*args, **kwargs)\n                \n                # Record success metrics\n                duration = time.time() - start_time\n                metrics.record_request(model, endpoint, \'success\')\n                metrics.record_duration(model, endpoint, duration)\n                \n                # Record token usage if available\n                if hasattr(result, \'tokens_used\'):\n                    metrics.record_token_usage(\n                        model, \n                        result.input_tokens, \n                        result.output_tokens\n                    )\n                \n                return result\n                \n            except Exception as e:\n                # Record error metrics\n                duration = time.time() - start_time\n                metrics.record_request(model, endpoint, \'error\')\n                metrics.record_duration(model, endpoint, duration)\n                metrics.record_error(model, type(e).__name__)\n                \n                # Log structured error\n                structlog.get_logger().error(\n                    "LLM request failed",\n                    model=model,\n                    endpoint=endpoint,\n                    error=str(e),\n                    duration=duration\n                )\n                \n                raise\n            \n            finally:\n                metrics.track_active_request(model, increment=False)\n        \n        return async_wrapper\n    return decorator\n\n# Usage example\nclass MonitoredLLMClient:\n    def __init__(self, model: str):\n        self.model = model\n        self.metrics = MetricsCollector()\n    \n    @monitor_llm_request("gpt-3.5-turbo", "chat_completion")\n    async def chat_completion(self, messages: list, **kwargs):\n        # Your LLM API call implementation\n        pass\n\n# Structured logging configuration\ndef setup_logging():\n    structlog.configure(\n        processors=[\n            structlog.stdlib.filter_by_level,\n            structlog.stdlib.add_logger_name,\n            structlog.stdlib.add_log_level,\n            structlog.stdlib.PositionalArgumentsFormatter(),\n            structlog.processors.TimeStamper(fmt="iso"),\n            structlog.processors.StackInfoRenderer(),\n            structlog.processors.format_exc_info,\n            structlog.processors.UnicodeDecoder(),\n            structlog.processors.JSONRenderer()\n        ],\n        context_class=dict,\n        logger_factory=structlog.stdlib.LoggerFactory(),\n        wrapper_class=structlog.stdlib.BoundLogger,\n        cache_logger_on_first_use=True,\n    )\n\n# Health check endpoint with detailed diagnostics\nclass HealthChecker:\n    def __init__(self, llm_client, vector_store):\n        self.llm_client = llm_client\n        self.vector_store = vector_store\n    \n    async def comprehensive_health_check(self) -> dict:\n        """Perform comprehensive health check"""\n        checks = {}\n        overall_healthy = True\n        \n        # Check LLM service connectivity\n        try:\n            test_response = await self.llm_client.complete([\n                {"role": "user", "content": "Health check test"}\n            ], max_tokens=5)\n            \n            checks["llm_service"] = {\n                "status": "healthy",\n                "response_time": 0.5,  # Calculate actual response time\n                "last_check": time.time()\n            }\n        except Exception as e:\n            checks["llm_service"] = {\n                "status": "unhealthy",\n                "error": str(e),\n                "last_check": time.time()\n            }\n            overall_healthy = False\n        \n        # Check vector store connectivity\n        try:\n            # Test vector store query\n            test_results = self.vector_store.search("health check", top_k=1)\n            \n            checks["vector_store"] = {\n                "status": "healthy",\n                "documents_count": len(test_results),\n                "last_check": time.time()\n            }\n        except Exception as e:\n            checks["vector_store"] = {\n                "status": "unhealthy", \n                "error": str(e),\n                "last_check": time.time()\n            }\n            overall_healthy = False\n        \n        # Check system resources\n        import psutil\n        \n        checks["system_resources"] = {\n            "cpu_percent": psutil.cpu_percent(),\n            "memory_percent": psutil.virtual_memory().percent,\n            "disk_percent": psutil.disk_usage(\'/\').percent\n        }\n        \n        # Check if resources are within acceptable limits\n        if (checks["system_resources"]["cpu_percent"] > 90 or \n            checks["system_resources"]["memory_percent"] > 90):\n            overall_healthy = False\n        \n        return {\n            "status": "healthy" if overall_healthy else "unhealthy",\n            "timestamp": time.time(),\n            "checks": checks\n        }\n\n# Start metrics server\ndef start_metrics_server(port: int = 8080):\n    start_http_server(port)\n    print("Metrics server started on port " + str(port))\n'})}),"\n",(0,s.jsx)(n.h3,{children:"2. Custom Dashboards and Alerting"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'# Grafana dashboard configuration (JSON)\ngrafana_dashboard = {\n    "dashboard": {\n        "title": "LLM Application Monitoring",\n        "panels": [\n            {\n                "title": "Request Rate",\n                "type": "graph",\n                "targets": [\n                    {\n                        "expr": "rate(llm_requests_total[5m])",\n                        "legendFormat": "\\\\{\\\\{model\\\\}\\\\} - \\\\{\\\\{endpoint\\\\}\\\\}"\n                    }\n                ]\n            },\n            {\n                "title": "Response Time",\n                "type": "graph", \n                "targets": [\n                    {\n                        "expr": "histogram_quantile(0.95, rate(llm_request_duration_seconds_bucket[5m]))",\n                        "legendFormat": "95th percentile"\n                    },\n                    {\n                        "expr": "histogram_quantile(0.50, rate(llm_request_duration_seconds_bucket[5m]))",\n                        "legendFormat": "50th percentile"\n                    }\n                ]\n            },\n            {\n                "title": "Error Rate",\n                "type": "graph",\n                "targets": [\n                    {\n                        "expr": "rate(llm_errors_total[5m]) / rate(llm_requests_total[5m])",\n                        "legendFormat": "Error Rate"\n                    }\n                ]\n            },\n            {\n                "title": "Token Usage",\n                "type": "graph",\n                "targets": [\n                    {\n                        "expr": "rate(llm_tokens_total[5m])",\n                        "legendFormat": "\\\\{\\\\{type\\\\}\\\\} tokens"\n                    }\n                ]\n            },\n            {\n                "title": "Cost Tracking",\n                "type": "singlestat",\n                "targets": [\n                    {\n                        "expr": "sum(llm_cost_total_usd)",\n                        "legendFormat": "Total Cost (USD)"\n                    }\n                ]\n            }\n        ]\n    }\n}\n\n# Alerting rules for Prometheus\nalerting_rules = """\ngroups:\n- name: llm_application_alerts\n  rules:\n  - alert: HighErrorRate\n    expr: rate(llm_errors_total[5m]) / rate(llm_requests_total[5m]) > 0.1\n    for: 2m\n    labels:\n      severity: warning\n    annotations:\n      summary: "High error rate detected"\n      description: "Error rate is \\\\{\\\\{ $value | humanizePercentage \\\\}\\\\} for the last 5 minutes"\n\n  - alert: HighResponseTime\n    expr: histogram_quantile(0.95, rate(llm_request_duration_seconds_bucket[5m])) > 10\n    for: 5m\n    labels:\n      severity: warning\n    annotations:\n      summary: "High response time detected"\n      description: "95th percentile response time is \\\\{\\\\{ $value \\\\}\\\\}s"\n\n  - alert: ServiceDown\n    expr: up{job="llm-service"} == 0\n    for: 1m\n    labels:\n      severity: critical\n    annotations:\n      summary: "LLM service is down"\n      description: "LLM service has been down for more than 1 minute"\n\n  - alert: HighCostBurn\n    expr: increase(llm_cost_total_usd[1h]) > 50\n    for: 0m\n    labels:\n      severity: warning\n    annotations:\n      summary: "High cost burn rate"\n      description: "Cost increased by $\\\\{\\\\{ $value \\\\}\\\\} in the last hour"\n"""\n\n# Slack alerting integration\nimport requests\nimport json\n\nclass SlackAlerter:\n    def __init__(self, webhook_url: str, channel: str = "#alerts"):\n        self.webhook_url = webhook_url\n        self.channel = channel\n    \n    def send_alert(self, title: str, message: str, severity: str = "warning"):\n        """Send alert to Slack"""\n        \n        color_map = {\n            "info": "#36a64f",     # green\n            "warning": "#ffaa00",  # orange  \n            "critical": "#ff0000"  # red\n        }\n        \n        payload = {\n            "channel": self.channel,\n            "username": "LLM Monitor",\n            "attachments": [\n                {\n                    "color": color_map.get(severity, "#808080"),\n                    "title": title,\n                    "text": message,\n                    "fields": [\n                        {\n                            "title": "Severity",\n                            "value": severity.upper(),\n                            "short": True\n                        },\n                        {\n                            "title": "Timestamp", \n                            "value": time.strftime("%Y-%m-%d %H:%M:%S"),\n                            "short": True\n                        }\n                    ]\n                }\n            ]\n        }\n        \n        try:\n            response = requests.post(\n                self.webhook_url,\n                data=json.dumps(payload),\n                headers={\'Content-Type\': \'application/json\'},\n                timeout=10\n            )\n            response.raise_for_status()\n        except Exception as e:\n            logging.error("Failed to send Slack alert", extra={"error": str(e)})\n'})}),"\n",(0,s.jsx)(n.h2,{children:"Security and Compliance"}),"\n",(0,s.jsx)(n.h3,{children:"1. Authentication and Authorization"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'from fastapi import FastAPI, Depends, HTTPException, status\nfrom fastapi.security import HTTPBearer, HTTPAuthorizationCredentials\nimport jwt\nfrom datetime import datetime, timedelta\nimport hashlib\nimport secrets\nfrom typing import Optional, List\nimport redis\nimport asyncio\n\nclass SecurityManager:\n    def __init__(self, secret_key: str, redis_client: redis.Redis):\n        self.secret_key = secret_key\n        self.redis_client = redis_client\n        self.security = HTTPBearer()\n    \n    def create_access_token(self, user_id: str, scopes: List[str]) -> str:\n        """Create JWT access token with scopes"""\n        to_encode = {\n            "sub": user_id,\n            "scopes": scopes,\n            "exp": datetime.utcnow() + timedelta(hours=24),\n            "iat": datetime.utcnow(),\n            "type": "access"\n        }\n        \n        encoded_jwt = jwt.encode(to_encode, self.secret_key, algorithm="HS256")\n        return encoded_jwt\n    \n    def create_api_key(self, user_id: str, name: str, scopes: List[str]) -> tuple:\n        """Create API key for service-to-service communication"""\n        api_key = "ak_" + secrets.token_urlsafe(32)\n        api_secret = secrets.token_urlsafe(64)\n        \n        # Hash the secret for storage\n        secret_hash = hashlib.sha256(api_secret.encode()).hexdigest()\n        \n        # Store in Redis\n        key_data = {\n            "user_id": user_id,\n            "name": name,\n            "scopes": ",".join(scopes),\n            "secret_hash": secret_hash,\n            "created_at": datetime.utcnow().isoformat(),\n            "last_used": None\n        }\n        \n        self.redis_client.hset("api_keys:" + api_key, mapping=key_data)\n        \n        return api_key, api_secret\n    \n    async def verify_token(self, credentials: HTTPAuthorizationCredentials) -> dict:\n        """Verify JWT token"""\n        try:\n            payload = jwt.decode(\n                credentials.credentials, \n                self.secret_key, \n                algorithms=["HS256"]\n            )\n            \n            user_id = payload.get("sub")\n            scopes = payload.get("scopes", [])\n            \n            if user_id is None:\n                raise HTTPException(\n                    status_code=status.HTTP_401_UNAUTHORIZED,\n                    detail="Invalid token"\n                )\n            \n            return {"user_id": user_id, "scopes": scopes}\n            \n        except jwt.ExpiredSignatureError:\n            raise HTTPException(\n                status_code=status.HTTP_401_UNAUTHORIZED,\n                detail="Token has expired"\n            )\n        except jwt.JWTError:\n            raise HTTPException(\n                status_code=status.HTTP_401_UNAUTHORIZED,\n                detail="Invalid token"\n            )\n    \n    async def verify_api_key(self, api_key: str, api_secret: str) -> dict:\n        """Verify API key and secret"""\n        key_data = self.redis_client.hgetall("api_keys:" + api_key)\n        \n        if not key_data:\n            raise HTTPException(\n                status_code=status.HTTP_401_UNAUTHORIZED,\n                detail="Invalid API key"\n            )\n        \n        # Verify secret\n        secret_hash = hashlib.sha256(api_secret.encode()).hexdigest()\n        if secret_hash != key_data[b"secret_hash"].decode():\n            raise HTTPException(\n                status_code=status.HTTP_401_UNAUTHORIZED,\n                detail="Invalid API secret"\n            )\n        \n        # Update last used timestamp\n        self.redis_client.hset(\n            "api_keys:" + api_key, \n            "last_used", \n            datetime.utcnow().isoformat()\n        )\n        \n        return {\n            "user_id": key_data[b"user_id"].decode(),\n            "scopes": key_data[b"scopes"].decode().split(",")\n        }\n    \n    def require_scope(self, required_scope: str):\n        """Decorator to require specific scope"""\n        def decorator(func):\n            @wraps(func)\n            async def wrapper(*args, **kwargs):\n                # Extract auth info from kwargs or dependency injection\n                auth_info = kwargs.get("auth_info")\n                if not auth_info or required_scope not in auth_info.get("scopes", []):\n                    raise HTTPException(\n                        status_code=status.HTTP_403_FORBIDDEN,\n                        detail="Insufficient permissions"\n                    )\n                return await func(*args, **kwargs)\n            return wrapper\n        return decorator\n\n# Rate limiting\nclass RateLimiter:\n    def __init__(self, redis_client: redis.Redis):\n        self.redis_client = redis_client\n    \n    async def is_allowed(\n        self, \n        key: str, \n        limit: int, \n        window_seconds: int\n    ) -> tuple[bool, dict]:\n        """Check if request is allowed under rate limit"""\n        \n        current_time = int(time.time())\n        window_start = current_time - window_seconds\n        \n        pipe = self.redis_client.pipeline()\n        \n        # Remove old entries\n        pipe.zremrangebyscore(key, 0, window_start)\n        \n        # Count current requests\n        pipe.zcard(key)\n        \n        # Add current request\n        pipe.zadd(key, {str(current_time): current_time})\n        \n        # Set expiry\n        pipe.expire(key, window_seconds)\n        \n        results = pipe.execute()\n        current_requests = results[1]\n        \n        allowed = current_requests < limit\n        \n        return allowed, {\n            "limit": limit,\n            "current": current_requests,\n            "remaining": max(0, limit - current_requests - 1),\n            "reset_time": current_time + window_seconds\n        }\n\n# Secure FastAPI application\ndef create_secure_app() -> FastAPI:\n    app = FastAPI(title="Secure LLM API")\n    \n    redis_client = redis.Redis(host=\'localhost\', port=6379, db=0)\n    security_manager = SecurityManager("your-secret-key", redis_client)\n    rate_limiter = RateLimiter(redis_client)\n    \n    @app.middleware("http")\n    async def security_middleware(request, call_next):\n        # Add security headers\n        response = await call_next(request)\n        response.headers["X-Content-Type-Options"] = "nosniff"\n        response.headers["X-Frame-Options"] = "DENY"\n        response.headers["X-XSS-Protection"] = "1; mode=block"\n        response.headers["Strict-Transport-Security"] = "max-age=31536000; includeSubDomains"\n        return response\n    \n    async def get_current_user(\n        credentials: HTTPAuthorizationCredentials = Depends(security_manager.security)\n    ):\n        return await security_manager.verify_token(credentials)\n    \n    @app.post("/v1/chat/completions")\n    @security_manager.require_scope("llm:chat")\n    async def secure_chat_completion(\n        request: ChatRequest,\n        auth_info: dict = Depends(get_current_user)\n    ):\n        user_id = auth_info["user_id"]\n        \n        # Apply rate limiting\n        allowed, rate_info = await rate_limiter.is_allowed(\n            "user:" + user_id,\n            limit=100,  # 100 requests per hour\n            window_seconds=3600\n        )\n        \n        if not allowed:\n            raise HTTPException(\n                status_code=status.HTTP_429_TOO_MANY_REQUESTS,\n                detail="Rate limit exceeded",\n                headers={\n                    "X-RateLimit-Limit": str(rate_info["limit"]),\n                    "X-RateLimit-Remaining": str(rate_info["remaining"]),\n                    "X-RateLimit-Reset": str(rate_info["reset_time"])\n                }\n            )\n        \n        # Process the request\n        # ... your chat completion logic here\n        \n        return {"message": "Chat completion processed securely"}\n    \n    return app\n'})}),"\n",(0,s.jsx)(n.h3,{children:"2. Data Privacy and Compliance"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'import hashlib\nimport hmac\nfrom datetime import datetime, timedelta\nfrom typing import Dict, Any, Optional\nimport json\nimport asyncio\n\nclass DataPrivacyManager:\n    def __init__(self, encryption_key: str):\n        self.encryption_key = encryption_key.encode()\n    \n    def anonymize_user_data(self, user_id: str) -> str:\n        """Create anonymous user identifier"""\n        return hmac.new(\n            self.encryption_key,\n            user_id.encode(),\n            hashlib.sha256\n        ).hexdigest()[:16]\n    \n    def sanitize_conversation(self, messages: List[dict]) -> List[dict]:\n        """Remove PII from conversation data"""\n        sanitized = []\n        \n        pii_patterns = [\n            r\'\\b\\d{3}-\\d{2}-\\d{4}\\b\',  # SSN\n            r\'\\b\\d{4}\\s?\\d{4}\\s?\\d{4}\\s?\\d{4}\\b\',  # Credit card\n            r\'\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]{2,}\\b\',  # Email\n            r\'\\b\\d{3}-\\d{3}-\\d{4}\\b\',  # Phone number\n        ]\n        \n        for message in messages:\n            content = message.get("content", "")\n            \n            # Replace PII patterns with placeholders\n            for pattern in pii_patterns:\n                content = re.sub(pattern, "[REDACTED]", content)\n            \n            sanitized.append({\n                **message,\n                "content": content\n            })\n        \n        return sanitized\n    \n    def log_data_access(self, user_id: str, data_type: str, purpose: str):\n        """Log data access for compliance"""\n        access_log = {\n            "timestamp": datetime.utcnow().isoformat(),\n            "user_id": self.anonymize_user_data(user_id),\n            "data_type": data_type,\n            "purpose": purpose,\n            "access_granted": True\n        }\n        \n        # Store in compliance log (implement your storage mechanism)\n        self._store_compliance_log(access_log)\n    \n    def handle_data_deletion_request(self, user_id: str) -> bool:\n        """Handle GDPR/CCPA deletion requests"""\n        try:\n            # Delete user conversations\n            # Delete user preferences\n            # Delete user analytics data\n            # Update logs to reflect deletion\n            \n            deletion_log = {\n                "timestamp": datetime.utcnow().isoformat(),\n                "user_id": self.anonymize_user_data(user_id),\n                "action": "data_deletion",\n                "status": "completed"\n            }\n            \n            self._store_compliance_log(deletion_log)\n            return True\n            \n        except Exception as e:\n            logging.error("Data deletion failed", extra={"error": str(e)})\n            return False\n    \n    def _store_compliance_log(self, log_entry: dict):\n        """Store compliance log entry"""\n        # Implement your preferred storage mechanism\n        # Could be database, file system, or external compliance service\n        pass\n\n# Content filtering for safety\nclass ContentFilter:\n    def __init__(self):\n        self.harmful_patterns = [\n            r\'\\b(kill|murder|suicide)\\b\',\n            r\'\\b(bomb|explosive|weapon)\\b\',\n            r\'\\b(hack|exploit|vulnerability)\\b\',\n            # Add more patterns based on your safety requirements\n        ]\n    \n    async def filter_content(self, content: str) -> tuple[bool, List[str]]:\n        """Filter content for harmful patterns"""\n        violations = []\n        \n        for pattern in self.harmful_patterns:\n            if re.search(pattern, content, re.IGNORECASE):\n                violations.append(pattern)\n        \n        is_safe = len(violations) == 0\n        return is_safe, violations\n    \n    async def filter_request(self, request: ChatRequest) -> ChatRequest:\n        """Filter incoming request"""\n        filtered_messages = []\n        \n        for message in request.messages:\n            content = message.get("content", "")\n            is_safe, violations = await self.filter_content(content)\n            \n            if not is_safe:\n                # Log the violation\n                logging.warning(\n                    "Content violation detected",\n                    extra={\n                        "violations": violations,\n                        "content_preview": content[:100]\n                    }\n                )\n                \n                # Replace with safe content or reject\n                message["content"] = "[Content filtered for safety]"\n            \n            filtered_messages.append(message)\n        \n        return ChatRequest(\n            **{**request.dict(), "messages": filtered_messages}\n        )\n'})}),"\n",(0,s.jsx)(n.h2,{children:"Scaling Strategies and Performance Optimization"}),"\n",(0,s.jsx)(n.h3,{children:"1. Caching Strategies"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'import redis\nimport json\nimport hashlib\nfrom typing import Optional, Any\nimport asyncio\n\nclass LLMCache:\n    def __init__(self, redis_client: redis.Redis):\n        self.redis_client = redis_client\n        self.default_ttl = 3600  # 1 hour\n    \n    def _generate_cache_key(self, messages: List[dict], model: str, **kwargs) -> str:\n        """Generate deterministic cache key"""\n        # Create a deterministic representation\n        cache_data = {\n            "messages": messages,\n            "model": model,\n            **{k: v for k, v in kwargs.items() if k in ["temperature", "max_tokens"]}\n        }\n        \n        # Sort for deterministic ordering\n        cache_string = json.dumps(cache_data, sort_keys=True)\n        \n        # Hash for compact key\n        return "llm_cache:" + hashlib.md5(cache_string.encode()).hexdigest()\n    \n    async def get(self, messages: List[dict], model: str, **kwargs) -> Optional[dict]:\n        """Get cached response"""\n        cache_key = self._generate_cache_key(messages, model, **kwargs)\n        \n        try:\n            cached_data = self.redis_client.get(cache_key)\n            if cached_data:\n                return json.loads(cached_data)\n        except Exception as e:\n            logging.warning("Cache retrieval failed", extra={"error": str(e)})\n        \n        return None\n    \n    async def set(\n        self, \n        messages: List[dict], \n        model: str, \n        response: dict, \n        ttl: Optional[int] = None,\n        **kwargs\n    ):\n        """Cache response"""\n        cache_key = self._generate_cache_key(messages, model, **kwargs)\n        ttl = ttl or self.default_ttl\n        \n        try:\n            self.redis_client.setex(\n                cache_key,\n                ttl,\n                json.dumps(response)\n            )\n        except Exception as e:\n            logging.warning("Cache storage failed", extra={"error": str(e)})\n    \n    async def invalidate_pattern(self, pattern: str):\n        """Invalidate cache entries matching pattern"""\n        try:\n            keys = self.redis_client.keys(pattern)\n            if keys:\n                self.redis_client.delete(*keys)\n        except Exception as e:\n            logging.warning("Cache invalidation failed", extra={"error": str(e)})\n\nclass CachedLLMClient:\n    def __init__(self, llm_client, cache: LLMCache):\n        self.llm_client = llm_client\n        self.cache = cache\n    \n    async def complete(self, messages: List[dict], **kwargs) -> dict:\n        """Complete with caching"""\n        \n        # Check cache first\n        cached_response = await self.cache.get(messages, self.llm_client.model, **kwargs)\n        if cached_response:\n            logging.info("Cache hit", extra={"cache_key": "hit"})\n            return cached_response\n        \n        # Call LLM API\n        response = await self.llm_client.complete(messages, **kwargs)\n        \n        # Cache the response\n        await self.cache.set(messages, self.llm_client.model, response, **kwargs)\n        \n        return response\n\n# Connection pooling and load balancing\nclass LLMLoadBalancer:\n    def __init__(self, providers: List[dict]):\n        """\n        providers: [\n            {"name": "openai", "client": openai_client, "weight": 0.7},\n            {"name": "anthropic", "client": anthropic_client, "weight": 0.3}\n        ]\n        """\n        self.providers = providers\n        self.current_loads = {p["name"]: 0 for p in providers}\n    \n    async def select_provider(self, request_type: str = "chat") -> dict:\n        """Select provider based on load and weights"""\n        \n        # Calculate weighted scores based on current load\n        best_provider = None\n        best_score = float(\'in\')\n        \n        for provider in self.providers:\n            current_load = self.current_loads[provider["name"]]\n            weight = provider["weight"]\n            \n            # Score = load / weight (lower is better)\n            score = current_load / weight\n            \n            if score < best_score:\n                best_score = score\n                best_provider = provider\n        \n        # Update load tracking\n        if best_provider:\n            self.current_loads[best_provider["name"]] += 1\n        \n        return best_provider\n    \n    async def complete_with_load_balancing(self, messages: List[dict], **kwargs) -> dict:\n        """Complete request with load balancing"""\n        \n        provider = await self.select_provider()\n        \n        try:\n            response = await provider["client"].complete(messages, **kwargs)\n            return response\n        except Exception as e:\n            logging.error(\n                "Provider failed, attempting fallback",\n                extra={"provider": provider["name"], "error": str(e)}\n            )\n            \n            # Try other providers as fallback\n            for fallback_provider in self.providers:\n                if fallback_provider["name"] != provider["name"]:\n                    try:\n                        return await fallback_provider["client"].complete(messages, **kwargs)\n                    except Exception as fe:\n                        logging.error(\n                            "Fallback provider failed",\n                            extra={"provider": fallback_provider["name"], "error": str(fe)}\n                        )\n            \n            # If all providers fail, raise the original exception\n            raise e\n        \n        finally:\n            # Decrease load counter\n            self.current_loads[provider["name"]] -= 1\n\n# Async request batching\nclass RequestBatcher:\n    def __init__(self, batch_size: int = 10, max_wait_time: float = 0.1):\n        self.batch_size = batch_size\n        self.max_wait_time = max_wait_time\n        self.pending_requests = []\n        self.batch_timer = None\n    \n    async def add_request(self, request: dict, response_future: asyncio.Future):\n        """Add request to batch"""\n        self.pending_requests.append({\n            "request": request,\n            "future": response_future\n        })\n        \n        # Start timer if this is the first request\n        if len(self.pending_requests) == 1:\n            self.batch_timer = asyncio.create_task(\n                self._wait_and_process_batch()\n            )\n        \n        # Process immediately if batch is full\n        if len(self.pending_requests) >= self.batch_size:\n            if self.batch_timer:\n                self.batch_timer.cancel()\n            await self._process_batch()\n    \n    async def _wait_and_process_batch(self):\n        """Wait for max_wait_time then process batch"""\n        try:\n            await asyncio.sleep(self.max_wait_time)\n            await self._process_batch()\n        except asyncio.CancelledError:\n            pass\n    \n    async def _process_batch(self):\n        """Process current batch of requests"""\n        if not self.pending_requests:\n            return\n        \n        batch = self.pending_requests.copy()\n        self.pending_requests.clear()\n        \n        # Process batch requests\n        try:\n            # Implement batch processing logic here\n            # This could involve parallel API calls or optimized batch API endpoints\n            \n            responses = await self._execute_batch([req["request"] for req in batch])\n            \n            # Resolve futures with responses\n            for i, batch_item in enumerate(batch):\n                batch_item["future"].set_result(responses[i])\n                \n        except Exception as e:\n            # Reject all futures with the error\n            for batch_item in batch:\n                batch_item["future"].set_exception(e)\n    \n    async def _execute_batch(self, requests: List[dict]) -> List[dict]:\n        """Execute batch of requests"""\n        # Implement parallel execution\n        tasks = []\n        for request in requests:\n            task = asyncio.create_task(self._execute_single_request(request))\n            tasks.append(task)\n        \n        return await asyncio.gather(*tasks)\n    \n    async def _execute_single_request(self, request: dict) -> dict:\n        """Execute single request (implement your LLM client call here)"""\n        # This is where you\'.format(\n            "request": request,\n            "future": response_future\n        )d call your actual LLM client\n        pass\n'})}),"\n",(0,s.jsx)(n.h2,{children:"Key Takeaways for Part 3"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Infrastructure Patterns"}),": Use microservices architecture with proper service separation"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Monitoring is Essential"}),": Implement comprehensive monitoring with metrics, logging, and alerting"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Security First"}),": Implement authentication, authorization, rate limiting, and content filtering"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Performance Optimization"}),": Use caching, load balancing, and request batching for scale"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Compliance Matters"}),": Handle data privacy, PII protection, and regulatory requirements"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{children:"Series Conclusion"}),"\n",(0,s.jsxs)(n.p,{children:["Congratulations! You've completed the ",(0,s.jsx)(n.strong,{children:"LLM Engineering Mastery"})," series. You now have the practical knowledge to:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Select and integrate foundation models effectively"}),"\n",(0,s.jsx)(n.li,{children:"Build advanced RAG systems with proper evaluation"}),"\n",(0,s.jsx)(n.li,{children:"Deploy and scale LLM applications in production"}),"\n",(0,s.jsx)(n.li,{children:"Monitor and maintain enterprise-grade systems"}),"\n",(0,s.jsx)(n.li,{children:"Implement security and compliance best practices"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"The field of LLM engineering is rapidly evolving, but these foundational patterns and practices will serve you well as you build the next generation of AI-powered applications."}),"\n",(0,s.jsx)(n.h3,{children:"Next Steps"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Practice"}),": Implement these patterns in your own projects"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Stay Updated"}),": Follow LLM research and new model releases"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Community"}),": Join LLM engineering communities and share your experiences"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Experiment"}),": Try new techniques and optimization strategies"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Scale Gradually"}),": Start small and scale based on real usage patterns"]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:"This concludes the LLM Engineering Mastery series. Keep building amazing AI applications!"})})]})}function l(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(o,{...e})}):o(e)}},33986:function(e,n,t){t.r(n),t.d(n,{default:function(){return l},frontmatter:function(){return a},metadata:function(){return i}});var s=t(57437),r=t(52671);let a=void 0,i={postId:"c3d4e5f6-7g8h-9i0j-1k2l-m3n4o5p6q7r8",title:"Multi-Agent Architectures: Orchestrating Intelligent Agent Teams",date:"2025-06-26",excerpt:"Explore advanced multi-agent architectures that enable teams of specialized AI agents to collaborate, coordinate, and solve complex problems. Learn patterns for agent communication, task delegation, and collective intelligence.",author:"Abstract Algorithms",tags:["Multi-Agent","Agent Coordination","Distributed AI","LangChain","Agent Teams","Workflow Orchestration"],coverImage:"/posts/multi-agent-architectures-orchestrating-intelligent-agent-teams/assets/multi-agent-architecture.png",series:{name:"AI Agent Development",order:3,total:5,prev:"/posts/step-by-step-ai-agent-development-from-concept-to-production",next:"/posts/langchain-framework-deep-dive-building-production-ready-ai-agents",coverImage:"/posts/multi-agent-architectures-orchestrating-intelligent-agent-teams/assets/assets/ai-agent-development-series.png",overview:"/posts/ai-agent-development-series/"}};function o(e){let n={blockquote:"blockquote",br:"br",code:"code",h2:"h2",h3:"h3",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Part 3 of the AI Agent Development Series"}),(0,s.jsx)(n.br,{}),"\n","With single agent development mastered, it's time to explore multi-agent systems. Learn how teams of specialized agents can tackle complex problems through coordination and collaboration."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["As AI agents become more sophisticated, the next evolution is ",(0,s.jsx)(n.strong,{children:"multi-agent systems"}),"—teams of specialized agents working together to solve complex problems that exceed the capabilities of any single agent. This guide explores architectures, patterns, and implementations for building effective agent teams."]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{children:"\uD83C\uDFD7️ Multi-Agent Architecture Patterns"}),"\n",(0,s.jsx)(n.h3,{children:"1. Hierarchical Architecture (Command & Control)"}),"\n",(0,s.jsx)(n.p,{children:"In hierarchical systems, a coordinator agent manages and delegates tasks to specialized worker agents."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'from abc import ABC, abstractmethod\nfrom typing import List, Dict, Any, Optional\nfrom enum import Enum\n\nclass AgentRole(Enum):\n    COORDINATOR = "coordinator"\n    WORKER = "worker"\n    SPECIALIST = "specialist"\n\nclass MultiAgentCoordinator:\n    def __init__(self, name: str):\n        self.name = name\n        self.worker_agents = {}\n        self.task_queue = []\n        self.active_tasks = {}\n    \n    def register_agent(self, agent_id: str, agent_instance, capabilities: List[str]):\n        """Register a worker agent with its capabilities"""\n        self.worker_agents[agent_id] = {\n            "instance": agent_instance,\n            "capabilities": capabilities,\n            "status": "idle",\n            "current_task": None,\n            "performance_score": 1.0\n        }\n    \n    async def process_complex_task(self, task: Dict[str, Any]) -> Dict[str, Any]:\n        """Break down complex task and coordinate execution"""\n        \n        # 1. Analyze task and decompose into subtasks\n        subtasks = await self.decompose_task(task)\n        \n        # 2. Match subtasks to appropriate agents\n        task_assignments = self.assign_tasks_to_agents(subtasks)\n        \n        # 3. Execute tasks in parallel or sequence\n        results = await self.execute_coordinated_tasks(task_assignments)\n        \n        # 4. Aggregate and synthesize results\n        final_result = await self.synthesize_results(results, task)\n        \n        return final_result\n    \n    async def decompose_task(self, task: Dict[str, Any]) -> List[Dict[str, Any]]:\n        """Decompose complex task into manageable subtasks"""\n        # Use LLM to analyze task and create breakdown\n        decomposition_prompt = f"""\n        Analyze this complex task and break it into subtasks:\n        \n        Task: {task[\'description\']}\n        Context: {task.get(\'context\', \'\')}\n        Requirements: {task.get(\'requirements\', [])}\n        \n        Break this into subtasks that can be handled by specialized agents:\n        - Data collection and analysis\n        - External system interactions  \n        - Decision making and recommendations\n        - Communication and notifications\n        \n        For each subtask, specify:\n        - Description\n        - Required capabilities\n        - Dependencies on other subtasks\n        - Success criteria\n        """\n        \n        # Implementation would use LLM to generate subtask breakdown\n        return [\n            {\n                "id": "subtask_1",\n                "description": "Collect relevant data",\n                "capabilities_required": ["data_retrieval", "log_analysis"],\n                "dependencies": [],\n                "priority": 1\n            },\n            {\n                "id": "subtask_2", \n                "description": "Analyze patterns and anomalies",\n                "capabilities_required": ["pattern_analysis", "anomaly_detection"],\n                "dependencies": ["subtask_1"],\n                "priority": 2\n            }\n        ]\n    \n    def assign_tasks_to_agents(self, subtasks: List[Dict[str, Any]]) -> Dict[str, str]:\n        """Assign subtasks to best-suited available agents"""\n        assignments = {}\n        \n        for subtask in subtasks:\n            required_caps = subtask["capabilities_required"]\n            \n            # Find best agent for this subtask\n            best_agent = self.find_best_agent_for_task(required_caps)\n            \n            if best_agent:\n                assignments[subtask["id"]] = best_agent\n                self.worker_agents[best_agent]["status"] = "assigned"\n            else:\n                # No suitable agent available - add to queue\n                self.task_queue.append(subtask)\n        \n        return assignments\n    \n    def find_best_agent_for_task(self, required_capabilities: List[str]) -> Optional[str]:\n        """Find the best available agent for a task"""\n        best_agent = None\n        best_score = 0\n        \n        for agent_id, agent_info in self.worker_agents.items():\n            if agent_info["status"] != "idle":\n                continue\n            \n            # Calculate capability match score\n            agent_caps = set(agent_info["capabilities"])\n            required_caps = set(required_capabilities)\n            \n            if required_caps.issubset(agent_caps):\n                # Agent has all required capabilities\n                overlap_score = len(required_caps) / len(agent_caps)\n                performance_score = agent_info["performance_score"]\n                total_score = overlap_score * performance_score\n                \n                if total_score > best_score:\n                    best_score = total_score\n                    best_agent = agent_id\n        \n        return best_agent\n'})}),"\n",(0,s.jsx)(n.h3,{children:"2. Peer-to-Peer Architecture (Collaborative)"}),"\n",(0,s.jsx)(n.p,{children:"In P2P systems, agents communicate directly and collaborate as equals."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'class PeerToPeerAgent:\n    def __init__(self, agent_id: str, capabilities: List[str]):\n        self.agent_id = agent_id\n        self.capabilities = capabilities\n        self.peer_agents = {}\n        self.message_inbox = []\n        self.collaboration_history = {}\n    \n    def register_peer(self, peer_id: str, peer_instance, peer_capabilities: List[str]):\n        """Register another agent as a peer"""\n        self.peer_agents[peer_id] = {\n            "instance": peer_instance,\n            "capabilities": peer_capabilities,\n            "trust_score": 0.5,  # Initial neutral trust\n            "collaboration_count": 0\n        }\n    \n    async def request_collaboration(self, task: Dict[str, Any]) -> Dict[str, Any]:\n        """Request collaboration from peer agents"""\n        \n        # Analyze what capabilities are needed\n        required_capabilities = await self.analyze_task_requirements(task)\n        \n        # Find peers with complementary capabilities\n        collaboration_partners = self.find_collaboration_partners(required_capabilities)\n        \n        # Send collaboration requests\n        collaboration_responses = []\n        for peer_id in collaboration_partners:\n            response = await self.send_collaboration_request(peer_id, task)\n            if response.get("accepted"):\n                collaboration_responses.append({\n                    "peer_id": peer_id,\n                    "contribution": response["contribution"],\n                    "confidence": response["confidence"]\n                })\n        \n        # Execute collaborative task\n        if collaboration_responses:\n            result = await self.execute_collaborative_task(task, collaboration_responses)\n            \n            # Update trust scores based on contribution quality\n            await self.update_collaboration_scores(collaboration_responses, result)\n            \n            return result\n        else:\n            # No collaboration possible, execute independently\n            return await self.execute_independent_task(task)\n    \n    def find_collaboration_partners(self, required_capabilities: List[str]) -> List[str]:\n        """Find peers with complementary capabilities"""\n        partners = []\n        my_capabilities = set(self.capabilities)\n        \n        for peer_id, peer_info in self.peer_agents.items():\n            peer_capabilities = set(peer_info["capabilities"])\n            \n            # Check if peer has capabilities we lack\n            complementary_caps = set(required_capabilities) - my_capabilities\n            if complementary_caps.intersection(peer_capabilities):\n                # Peer has useful complementary capabilities\n                if peer_info["trust_score"] > 0.3:  # Trust threshold\n                    partners.append(peer_id)\n        \n        # Sort by trust score and collaboration history\n        partners.sort(key=lambda p: (\n            self.peer_agents[p]["trust_score"],\n            self.peer_agents[p]["collaboration_count"]\n        ), reverse=True)\n        \n        return partners[:3]  # Limit to top 3 partners\n    \n    async def send_collaboration_request(self, peer_id: str, task: Dict[str, Any]) -> Dict[str, Any]:\n        """Send collaboration request to a peer agent"""\n        request = {\n            "type": "collaboration_request",\n            "from": self.agent_id,\n            "task": task,\n            "my_capabilities": self.capabilities,\n            "timestamp": datetime.utcnow().isoformat()\n        }\n        \n        peer_instance = self.peer_agents[peer_id]["instance"]\n        response = await peer_instance.handle_collaboration_request(request)\n        \n        return response\n    \n    async def handle_collaboration_request(self, request: Dict[str, Any]) -> Dict[str, Any]:\n        """Handle incoming collaboration request"""\n        task = request["task"]\n        requesting_agent = request["from"]\n        \n        # Analyze if we can contribute meaningfully\n        my_contribution = await self.assess_potential_contribution(task)\n        \n        if my_contribution["can_contribute"]:\n            return {\n                "accepted": True,\n                "contribution": my_contribution["contribution_type"],\n                "confidence": my_contribution["confidence"],\n                "estimated_effort": my_contribution["effort"]\n            }\n        else:\n            return {\n                "accepted": False,\n                "reason": "No meaningful contribution possible"\n            }\n'})}),"\n",(0,s.jsx)(n.h3,{children:"3. Market-Based Architecture (Auction/Bidding)"}),"\n",(0,s.jsx)(n.p,{children:"Agents bid for tasks based on their capabilities and current workload."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'class MarketBasedCoordinator:\n    def __init__(self):\n        self.registered_agents = {}\n        self.active_auctions = {}\n        self.completed_tasks = []\n    \n    async def create_task_auction(self, task: Dict[str, Any]) -> str:\n        """Create an auction for a task"""\n        auction_id = "auction_{uuid.uuid4()}".format(uuid.uuid4())\n        \n        auction = {\n            "id": auction_id,\n            "task": task,\n            "created_at": datetime.utcnow(),\n            "deadline": datetime.utcnow() + timedelta(minutes=5),\n            "bids": [],\n            "status": "open"\n        }\n        \n        self.active_auctions[auction_id] = auction\n        \n        # Broadcast auction to all eligible agents\n        await self.broadcast_auction(auction)\n        \n        return auction_id\n    \n    async def broadcast_auction(self, auction: Dict[str, Any]):\n        """Send auction notice to all capable agents"""\n        task = auction["task"]\n        required_capabilities = task.get("required_capabilities", [])\n        \n        for agent_id, agent_info in self.registered_agents.items():\n            agent_capabilities = set(agent_info["capabilities"])\n            required_caps = set(required_capabilities)\n            \n            # Only notify agents with relevant capabilities\n            if required_caps.intersection(agent_capabilities):\n                await agent_info["instance"].receive_auction_notice(auction)\n    \n    async def receive_bid(self, auction_id: str, bid: Dict[str, Any]) -> bool:\n        """Receive and process a bid from an agent"""\n        if auction_id not in self.active_auctions:\n            return False\n        \n        auction = self.active_auctions[auction_id]\n        \n        if auction["status"] != "open":\n            return False\n        \n        # Validate bid\n        if self.validate_bid(bid, auction["task"]):\n            auction["bids"].append(bid)\n            return True\n        \n        return False\n    \n    def evaluate_bids(self, auction_id: str) -> Optional[Dict[str, Any]]:\n        """Evaluate bids and select winner"""\n        auction = self.active_auctions[auction_id]\n        bids = auction["bids"]\n        \n        if not bids:\n            return None\n        \n        # Multi-criteria evaluation\n        best_bid = None\n        best_score = 0\n        \n        for bid in bids:\n            score = self.calculate_bid_score(bid, auction["task"])\n            if score > best_score:\n                best_score = score\n                best_bid = bid\n        \n        return best_bid\n    \n    def calculate_bid_score(self, bid: Dict[str, Any], task: Dict[str, Any]) -> float:\n        """Calculate bid score based on multiple criteria"""\n        \n        # Capability match (40%)\n        capability_score = self.calculate_capability_match(\n            bid["agent_capabilities"], \n            task.get("required_capabilities", [])\n        )\n        \n        # Cost efficiency (30%)\n        cost_score = 1.0 / max(bid["estimated_cost"], 1)  # Lower cost is better\n        \n        # Time efficiency (20%)  \n        time_score = 1.0 / max(bid["estimated_time"], 1)  # Faster is better\n        \n        # Agent reputation (10%)\n        agent_id = bid["agent_id"]\n        reputation_score = self.registered_agents[agent_id].get("reputation", 0.5)\n        \n        total_score = (\n            capability_score * 0.4 +\n            cost_score * 0.3 + \n            time_score * 0.2 +\n            reputation_score * 0.1\n        )\n        \n        return total_score\n\nclass BiddingAgent:\n    def __init__(self, agent_id: str, capabilities: List[str]):\n        self.agent_id = agent_id\n        self.capabilities = capabilities\n        self.current_workload = 0.0\n        self.reputation_score = 0.5\n        self.bid_history = []\n    \n    async def receive_auction_notice(self, auction: Dict[str, Any]):\n        """Receive auction notice and decide whether to bid"""\n        task = auction["task"]\n        \n        # Evaluate if we should bid\n        should_bid = await self.evaluate_bidding_opportunity(task)\n        \n        if should_bid:\n            bid = await self.create_bid(auction)\n            await self.submit_bid(auction["id"], bid)\n    \n    async def evaluate_bidding_opportunity(self, task: Dict[str, Any]) -> bool:\n        """Decide whether to bid on a task"""\n        \n        # Check capability match\n        required_caps = set(task.get("required_capabilities", []))\n        my_caps = set(self.capabilities)\n        \n        if not required_caps.issubset(my_caps):\n            return False  # Can\'t fulfill requirements\n        \n        # Check current workload\n        if self.current_workload > 0.8:\n            return False  # Too busy\n        \n        # Check task value vs effort\n        estimated_effort = await self.estimate_effort(task)\n        task_value = task.get("priority_score", 1.0)\n        \n        if task_value / estimated_effort > 0.5:  # Value threshold\n            return True\n        \n        return False\n    \n    async def create_bid(self, auction: Dict[str, Any]) -> Dict[str, Any]:\n        """Create a competitive bid for the task"""\n        task = auction["task"]\n        \n        # Estimate effort and resources needed\n        effort_estimate = await self.estimate_effort(task)\n        time_estimate = await self.estimate_completion_time(task)\n        \n        # Calculate competitive price\n        base_cost = effort_estimate * self.get_hourly_rate()\n        \n        # Adjust based on workload and competition\n        workload_multiplier = 1.0 + (self.current_workload * 0.5)\n        competitive_cost = base_cost * workload_multiplier\n        \n        bid = {\n            "auction_id": auction["id"],\n            "agent_id": self.agent_id,\n            "agent_capabilities": self.capabilities,\n            "estimated_cost": competitive_cost,\n            "estimated_time": time_estimate,\n            "confidence_level": self.calculate_confidence(task),\n            "proposed_approach": await self.outline_approach(task),\n            "reputation_score": self.reputation_score\n        }\n        \n        return bid\n'})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{children:"\uD83D\uDD04 Agent Communication Patterns"}),"\n",(0,s.jsx)(n.h3,{children:"1. Message Passing System"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'from dataclasses import dataclass\nfrom typing import Any, Callable\nimport asyncio\nfrom enum import Enum\n\nclass MessageType(Enum):\n    TASK_REQUEST = "task_request"\n    TASK_RESPONSE = "task_response"\n    COLLABORATION_INVITE = "collaboration_invite"\n    STATUS_UPDATE = "status_update"\n    ERROR_NOTIFICATION = "error_notification"\n    RESOURCE_SHARING = "resource_sharing"\n\n@dataclass\nclass AgentMessage:\n    message_id: str\n    from_agent: str\n    to_agent: str\n    message_type: MessageType\n    content: Dict[str, Any]\n    timestamp: datetime\n    priority: int = 1\n    requires_response: bool = False\n    correlation_id: Optional[str] = None\n\nclass MessageBus:\n    def __init__(self):\n        self.subscribers = {}\n        self.message_queue = asyncio.Queue()\n        self.message_history = []\n        self.delivery_guarantees = {}\n    \n    def subscribe(self, agent_id: str, message_types: List[MessageType], \n                 callback: Callable[[AgentMessage], None]):\n        """Subscribe an agent to specific message types"""\n        if agent_id not in self.subscribers:\n            self.subscribers[agent_id] = {}\n        \n        for msg_type in message_types:\n            if msg_type not in self.subscribers[agent_id]:\n                self.subscribers[agent_id][msg_type] = []\n            self.subscribers[agent_id][msg_type].append(callback)\n    \n    async def publish(self, message: AgentMessage) -> bool:\n        """Publish a message to the bus"""\n        \n        # Store message in history\n        self.message_history.append(message)\n        \n        # Route to specific recipient if specified\n        if message.to_agent and message.to_agent in self.subscribers:\n            await self.deliver_to_agent(message.to_agent, message)\n            return True\n        \n        # Broadcast to all subscribers of this message type\n        else:\n            delivered = False\n            for agent_id, subscriptions in self.subscribers.items():\n                if message.message_type in subscriptions:\n                    await self.deliver_to_agent(agent_id, message)\n                    delivered = True\n            return delivered\n    \n    async def deliver_to_agent(self, agent_id: str, message: AgentMessage):\n        """Deliver message to a specific agent"""\n        callbacks = self.subscribers[agent_id].get(message.message_type, [])\n        \n        for callback in callbacks:\n            try:\n                await callback(message)\n            except Exception as e:\n                logger.error("Message delivery failed", \n                           agent_id=agent_id, \n                           message_id=message.message_id,\n                           error=str(e))\n\nclass CommunicatingAgent:\n    def __init__(self, agent_id: str, message_bus: MessageBus):\n        self.agent_id = agent_id\n        self.message_bus = message_bus\n        self.pending_responses = {}\n        \n        # Subscribe to relevant message types\n        self.message_bus.subscribe(\n            agent_id,\n            [MessageType.TASK_REQUEST, MessageType.COLLABORATION_INVITE, MessageType.STATUS_UPDATE],\n            self.handle_message\n        )\n    \n    async def handle_message(self, message: AgentMessage):\n        """Handle incoming messages"""\n        \n        if message.message_type == MessageType.TASK_REQUEST:\n            await self.handle_task_request(message)\n        \n        elif message.message_type == MessageType.COLLABORATION_INVITE:\n            await self.handle_collaboration_invite(message)\n        \n        elif message.message_type == MessageType.STATUS_UPDATE:\n            await self.handle_status_update(message)\n        \n        # Send response if required\n        if message.requires_response:\n            response = await self.create_response(message)\n            await self.send_message(response)\n    \n    async def send_task_request(self, target_agent: str, task: Dict[str, Any]) -> str:\n        """Send a task request to another agent"""\n        message = AgentMessage(\n            message_id=str(uuid.uuid4()),\n            from_agent=self.agent_id,\n            to_agent=target_agent,\n            message_type=MessageType.TASK_REQUEST,\n            content={"task": task},\n            timestamp=datetime.utcnow(),\n            requires_response=True\n        )\n        \n        await self.message_bus.publish(message)\n        \n        # Store pending response\n        self.pending_responses[message.message_id] = {\n            "sent_at": datetime.utcnow(),\n            "target_agent": target_agent,\n            "task": task\n        }\n        \n        return message.message_id\n    \n    async def send_collaboration_invite(self, agents: List[str], \n                                      task: Dict[str, Any]) -> List[str]:\n        """Send collaboration invites to multiple agents"""\n        message_ids = []\n        \n        for agent_id in agents:\n            message = AgentMessage(\n                message_id=str(uuid.uuid4()),\n                from_agent=self.agent_id,\n                to_agent=agent_id,\n                message_type=MessageType.COLLABORATION_INVITE,\n                content={\n                    "task": task,\n                    "collaboration_type": "peer_review",\n                    "deadline": (datetime.utcnow() + timedelta(hours=1)).isoformat()\n                },\n                timestamp=datetime.utcnow(),\n                requires_response=True\n            )\n            \n            await self.message_bus.publish(message)\n            message_ids.append(message.message_id)\n        \n        return message_ids\n'})}),"\n",(0,s.jsx)(n.h3,{children:"2. Shared Memory System"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'class SharedMemorySystem:\n    def __init__(self, redis_client):\n        self.redis = redis_client\n        self.namespace = "multiagent_shared"\n        self.access_locks = {}\n    \n    async def write_shared_data(self, key: str, data: Dict[str, Any], \n                              agent_id: str, ttl: int = 3600):\n        """Write data to shared memory with metadata"""\n        \n        shared_entry = {\n            "data": data,\n            "written_by": agent_id,\n            "written_at": datetime.utcnow().isoformat(),\n            "version": self.get_next_version(key),\n            "access_count": 0\n        }\n        \n        full_key = "{self.namespace}:{key}".format(key)\n        \n        # Use Redis transaction for atomic write\n        pipe = self.redis.pipeline()\n        pipe.setex(full_key, ttl, json.dumps(shared_entry))\n        pipe.setex("{full_key}:lock".format(full_key), 30, agent_id)  # Short lock\n        await pipe.execute()\n    \n    async def read_shared_data(self, key: str, agent_id: str) -> Optional[Dict[str, Any]]:\n        """Read data from shared memory with access tracking"""\n        \n        full_key = "{self.namespace}:{key}".format(key)\n        data = await self.redis.get(full_key)\n        \n        if not data:\n            return None\n        \n        shared_entry = json.loads(data)\n        \n        # Increment access count\n        shared_entry["access_count"] += 1\n        shared_entry["last_accessed_by"] = agent_id\n        shared_entry["last_accessed_at"] = datetime.utcnow().isoformat()\n        \n        # Update entry\n        await self.redis.setex(full_key, 3600, json.dumps(shared_entry))\n        \n        return shared_entry["data"]\n    \n    def get_next_version(self, key: str) -> int:\n        """Get next version number for a key"""\n        version_key = "{self.namespace}:{key}:version".format(key)\n        return self.redis.incr(version_key)\n    \n    async def create_shared_workspace(self, workspace_id: str, \n                                    participating_agents: List[str]) -> str:\n        """Create a shared workspace for agent collaboration"""\n        \n        workspace = {\n            "workspace_id": workspace_id,\n            "participants": participating_agents,\n            "created_at": datetime.utcnow().isoformat(),\n            "shared_variables": {},\n            "task_results": {},\n            "communication_log": []\n        }\n        \n        workspace_key = "{self.namespace}:workspace:{workspace_id}".format(workspace_id)\n        await self.redis.setex(workspace_key, 7200, json.dumps(workspace))  # 2 hours\n        \n        return workspace_key\n    \n    async def update_workspace(self, workspace_id: str, agent_id: str, \n                             update_data: Dict[str, Any]):\n        """Update shared workspace with new data"""\n        \n        workspace_key = "{self.namespace}:workspace:{workspace_id}".format(workspace_id)\n        workspace_data = await self.redis.get(workspace_key)\n        \n        if not workspace_data:\n            raise ValueError("Workspace {workspace_id} not found".format(workspace_id))\n        \n        workspace = json.loads(workspace_data)\n        \n        # Add update to workspace\n        for key, value in update_data.items():\n            if key == "shared_variables":\n                workspace["shared_variables"].update(value)\n            elif key == "task_results":\n                workspace["task_results"].update(value)\n            elif key == "communication":\n                workspace["communication_log"].append({\n                    "agent_id": agent_id,\n                    "timestamp": datetime.utcnow().isoformat(),\n                    "message": value\n                })\n        \n        workspace["last_updated_by"] = agent_id\n        workspace["last_updated_at"] = datetime.utcnow().isoformat()\n        \n        await self.redis.setex(workspace_key, 7200, json.dumps(workspace))\n'})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{children:"\uD83C\uDFAF Specialized Agent Roles"}),"\n",(0,s.jsx)(n.h3,{children:"1. Data Collection Agent"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'class DataCollectionAgent(BaseAgent):\n    def __init__(self, agent_id: str, data_sources: Dict[str, Any]):\n        super().__init__(agent_id, ["data_collection", "web_scraping", "api_integration"])\n        self.data_sources = data_sources\n        self.collection_history = []\n    \n    async def collect_data(self, request: Dict[str, Any]) -> Dict[str, Any]:\n        """Collect data based on request specifications"""\n        \n        data_type = request.get("data_type")\n        sources = request.get("sources", [])\n        time_range = request.get("time_range")\n        \n        collected_data = {}\n        \n        for source in sources:\n            if source in self.data_sources:\n                try:\n                    source_data = await self.collect_from_source(source, request)\n                    collected_data[source] = source_data\n                except Exception as e:\n                    collected_data[source] = {"error": str(e)}\n        \n        # Store collection history\n        self.collection_history.append({\n            "timestamp": datetime.utcnow().isoformat(),\n            "request": request,\n            "sources_accessed": list(collected_data.keys()),\n            "data_points": sum(len(v) if isinstance(v, list) else 1 \n                             for v in collected_data.values())\n        })\n        \n        return {\n            "agent_id": self.agent_id,\n            "collection_timestamp": datetime.utcnow().isoformat(),\n            "data": collected_data,\n            "metadata": {\n                "sources_count": len(collected_data),\n                "total_data_points": sum(len(v) if isinstance(v, list) else 1 \n                                       for v in collected_data.values()),\n                "collection_duration": time.time() - start_time\n            }\n        }\n\nclass AnalysisAgent(BaseAgent):\n    def __init__(self, agent_id: str, analysis_models: Dict[str, Any]):\n        super().__init__(agent_id, ["pattern_analysis", "anomaly_detection", "statistical_analysis"])\n        self.analysis_models = analysis_models\n        self.analysis_cache = {}\n    \n    async def analyze_data(self, data: Dict[str, Any], \n                          analysis_type: str) -> Dict[str, Any]:\n        """Perform specified analysis on provided data"""\n        \n        # Check cache for similar analysis\n        cache_key = self.generate_cache_key(data, analysis_type)\n        if cache_key in self.analysis_cache:\n            cached_result = self.analysis_cache[cache_key]\n            if self.is_cache_valid(cached_result):\n                return cached_result["result"]\n        \n        # Perform analysis\n        if analysis_type == "pattern_analysis":\n            result = await self.perform_pattern_analysis(data)\n        elif analysis_type == "anomaly_detection":\n            result = await self.perform_anomaly_detection(data)\n        elif analysis_type == "trend_analysis":\n            result = await self.perform_trend_analysis(data)\n        else:\n            raise ValueError("Unknown analysis type: {analysis_type}".format(analysis_type))\n        \n        # Cache result\n        self.analysis_cache[cache_key] = {\n            "result": result,\n            "timestamp": datetime.utcnow(),\n            "ttl": timedelta(hours=1)\n        }\n        \n        return result\n\nclass DecisionAgent(BaseAgent):\n    def __init__(self, agent_id: str, decision_frameworks: Dict[str, Any]):\n        super().__init__(agent_id, ["decision_making", "risk_assessment", "recommendation_generation"])\n        self.decision_frameworks = decision_frameworks\n        self.decision_history = []\n    \n    async def make_decision(self, context: Dict[str, Any], \n                           options: List[Dict[str, Any]]) -> Dict[str, Any]:\n        """Make a decision based on context and available options"""\n        \n        # Evaluate each option\n        option_evaluations = []\n        \n        for option in options:\n            evaluation = await self.evaluate_option(option, context)\n            option_evaluations.append({\n                "option": option,\n                "evaluation": evaluation,\n                "score": evaluation["total_score"]\n            })\n        \n        # Rank options by score\n        option_evaluations.sort(key=lambda x: x["score"], reverse=True)\n        \n        # Make final decision\n        recommended_option = option_evaluations[0]\n        \n        decision = {\n            "agent_id": self.agent_id,\n            "decision_timestamp": datetime.utcnow().isoformat(),\n            "recommended_option": recommended_option["option"],\n            "confidence_score": recommended_option["evaluation"]["confidence"],\n            "reasoning": recommended_option["evaluation"]["reasoning"],\n            "alternative_options": option_evaluations[1:3],  # Top 2 alternatives\n            "risk_assessment": await self.assess_risks(recommended_option["option"], context)\n        }\n        \n        # Store decision history\n        self.decision_history.append(decision)\n        \n        return decision\n'})}),"\n",(0,s.jsx)(n.h3,{children:"2. Execution Agent"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'class ExecutionAgent(BaseAgent):\n    def __init__(self, agent_id: str, execution_tools: Dict[str, Any]):\n        super().__init__(agent_id, ["task_execution", "system_interaction", "workflow_management"])\n        self.execution_tools = execution_tools\n        self.execution_queue = []\n        self.active_executions = {}\n    \n    async def execute_plan(self, execution_plan: Dict[str, Any]) -> Dict[str, Any]:\n        """Execute a multi-step plan with error handling and rollback"""\n        \n        execution_id = str(uuid.uuid4())\n        \n        execution_context = {\n            "execution_id": execution_id,\n            "plan": execution_plan,\n            "start_time": datetime.utcnow(),\n            "steps_completed": [],\n            "current_step": None,\n            "rollback_stack": [],\n            "status": "in_progress"\n        }\n        \n        self.active_executions[execution_id] = execution_context\n        \n        try:\n            steps = execution_plan["steps"]\n            \n            for i, step in enumerate(steps):\n                execution_context["current_step"] = i\n                \n                # Execute step with rollback support\n                step_result = await self.execute_step_with_rollback(step, execution_context)\n                \n                execution_context["steps_completed"].append({\n                    "step": step,\n                    "result": step_result,\n                    "completed_at": datetime.utcnow().isoformat()\n                })\n                \n                # Check if step failed\n                if step_result.get("status") == "failed":\n                    await self.handle_execution_failure(execution_context, step_result)\n                    break\n            \n            execution_context["status"] = "completed"\n            execution_context["end_time"] = datetime.utcnow()\n            \n        except Exception as e:\n            execution_context["status"] = "error" \n            execution_context["error"] = str(e)\n            await self.rollback_execution(execution_context)\n        \n        finally:\n            del self.active_executions[execution_id]\n        \n        return {\n            "execution_id": execution_id,\n            "status": execution_context["status"],\n            "steps_completed": len(execution_context["steps_completed"]),\n            "total_steps": len(execution_plan["steps"]),\n            "duration": str(execution_context.get("end_time", datetime.utcnow()) - execution_context["start_time"]),\n            "results": execution_context["steps_completed"]\n        }\n'})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{children:"\uD83D\uDD17 Agent Coordination Mechanisms"}),"\n",(0,s.jsx)(n.h3,{children:"1. Consensus Building"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'class ConsensusCoordinator:\n    def __init__(self, participating_agents: List[str]):\n        self.agents = participating_agents\n        self.consensus_rounds = []\n        self.voting_history = {}\n    \n    async def build_consensus(self, decision_topic: Dict[str, Any], \n                            consensus_threshold: float = 0.7) -> Dict[str, Any]:\n        """Build consensus among participating agents"""\n        \n        round_id = str(uuid.uuid4())\n        consensus_round = {\n            "round_id": round_id,\n            "topic": decision_topic,\n            "threshold": consensus_threshold,\n            "votes": {},\n            "iterations": [],\n            "final_decision": None\n        }\n        \n        max_iterations = 5\n        iteration = 0\n        \n        while iteration < max_iterations:\n            iteration += 1\n            \n            # Collect votes from all agents\n            iteration_votes = await self.collect_votes(decision_topic, iteration)\n            \n            # Calculate consensus level\n            consensus_level = self.calculate_consensus_level(iteration_votes)\n            \n            consensus_round["iterations"].append({\n                "iteration": iteration,\n                "votes": iteration_votes,\n                "consensus_level": consensus_level\n            })\n            \n            # Check if threshold reached\n            if consensus_level >= consensus_threshold:\n                final_decision = self.determine_consensus_decision(iteration_votes)\n                consensus_round["final_decision"] = final_decision\n                break\n            \n            # If not, facilitate discussion and prepare for next round\n            await self.facilitate_discussion(iteration_votes, decision_topic)\n        \n        self.consensus_rounds.append(consensus_round)\n        return consensus_round\n    \n    async def collect_votes(self, topic: Dict[str, Any], iteration: int) -> Dict[str, Any]:\n        """Collect votes from all participating agents"""\n        votes = {}\n        \n        for agent_id in self.agents:\n            try:\n                # Send voting request to agent\n                vote_request = {\n                    "topic": topic,\n                    "iteration": iteration,\n                    "previous_votes": self.get_previous_votes(agent_id),\n                    "deadline": datetime.utcnow() + timedelta(minutes=2)\n                }\n                \n                vote = await self.request_agent_vote(agent_id, vote_request)\n                votes[agent_id] = vote\n                \n            except Exception as e:\n                logger.error("Failed to collect vote from {agent_id}: {e}".format(e))\n                votes[agent_id] = {"error": str(e)}\n        \n        return votes\n    \n    def calculate_consensus_level(self, votes: Dict[str, Any]) -> float:\n        """Calculate the level of consensus among votes"""\n        valid_votes = {k: v for k, v in votes.items() if "error" not in v}\n        \n        if not valid_votes:\n            return 0.0\n        \n        # Group votes by decision\n        decision_groups = {}\n        for agent_id, vote in valid_votes.items():\n            decision = vote.get("decision")\n            if decision not in decision_groups:\n                decision_groups[decision] = []\n            decision_groups[decision].append(agent_id)\n        \n        # Find largest group\n        largest_group_size = max(len(group) for group in decision_groups.values())\n        \n        return largest_group_size / len(valid_votes)\n'})}),"\n",(0,s.jsx)(n.h3,{children:"2. Load Balancing"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'class LoadBalancer:\n    def __init__(self, agent_pool: Dict[str, Any]):\n        self.agent_pool = agent_pool\n        self.load_metrics = {}\n        self.routing_history = []\n    \n    def route_task(self, task: Dict[str, Any]) -> str:\n        """Route task to the best available agent"""\n        \n        # Get agents capable of handling this task\n        capable_agents = self.find_capable_agents(task)\n        \n        if not capable_agents:\n            raise ValueError("No agents capable of handling this task")\n        \n        # Calculate load scores for each capable agent\n        agent_scores = {}\n        for agent_id in capable_agents:\n            load_score = self.calculate_load_score(agent_id, task)\n            agent_scores[agent_id] = load_score\n        \n        # Select agent with best (lowest) load score\n        best_agent = min(agent_scores.keys(), key=lambda x: agent_scores[x])\n        \n        # Update load metrics\n        self.update_agent_load(best_agent, task)\n        \n        # Record routing decision\n        self.routing_history.append({\n            "timestamp": datetime.utcnow().isoformat(),\n            "task": task,\n            "selected_agent": best_agent,\n            "agent_scores": agent_scores,\n            "reason": "lowest_load_score"\n        })\n        \n        return best_agent\n    \n    def calculate_load_score(self, agent_id: str, task: Dict[str, Any]) -> float:\n        """Calculate load score for an agent (lower is better)"""\n        \n        agent_info = self.agent_pool[agent_id]\n        current_load = self.load_metrics.get(agent_id, {})\n        \n        # Factors in load calculation:\n        # 1. Current CPU/memory usage\n        cpu_load = current_load.get("cpu_usage", 0.0)\n        memory_load = current_load.get("memory_usage", 0.0)\n        \n        # 2. Number of active tasks\n        active_tasks = current_load.get("active_tasks", 0)\n        max_concurrent = agent_info.get("max_concurrent_tasks", 5)\n        task_load = active_tasks / max_concurrent\n        \n        # 3. Task complexity match\n        task_complexity = task.get("complexity", 1.0)\n        agent_capability = agent_info.get("capability_score", 1.0)\n        complexity_mismatch = abs(task_complexity - agent_capability)\n        \n        # 4. Recent performance\n        recent_performance = current_load.get("recent_performance", 1.0)\n        \n        # Weighted load score\n        load_score = (\n            cpu_load * 0.3 +\n            memory_load * 0.2 +\n            task_load * 0.3 +\n            complexity_mismatch * 0.1 +\n            (1.0 - recent_performance) * 0.1\n        )\n        \n        return load_score\n    \n    def update_agent_load(self, agent_id: str, task: Dict[str, Any]):\n        """Update load metrics for an agent"""\n        if agent_id not in self.load_metrics:\n            self.load_metrics[agent_id] = {\n                "active_tasks": 0,\n                "cpu_usage": 0.0,\n                "memory_usage": 0.0,\n                "recent_performance": 1.0\n            }\n        \n        # Increment active task count\n        self.load_metrics[agent_id]["active_tasks"] += 1\n        \n        # Estimate resource usage increase\n        task_size = task.get("estimated_resources", {})\n        self.load_metrics[agent_id]["cpu_usage"] += task_size.get("cpu", 0.1)\n        self.load_metrics[agent_id]["memory_usage"] += task_size.get("memory", 0.1)\n'})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{children:"\uD83D\uDCCA Multi-Agent Performance Monitoring"}),"\n",(0,s.jsx)(n.h3,{children:"Monitoring Dashboard"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'class MultiAgentMonitor:\n    def __init__(self, agent_registry: Dict[str, Any]):\n        self.agent_registry = agent_registry\n        self.performance_history = {}\n        self.system_metrics = {}\n        self.alert_thresholds = {\n            "response_time": 30.0,  # seconds\n            "error_rate": 0.1,      # 10%\n            "collaboration_failure_rate": 0.2  # 20%\n        }\n    \n    async def collect_system_metrics(self) -> Dict[str, Any]:\n        """Collect comprehensive system metrics"""\n        \n        metrics = {\n            "timestamp": datetime.utcnow().isoformat(),\n            "agent_metrics": {},\n            "collaboration_metrics": {},\n            "system_health": {}\n        }\n        \n        # Collect individual agent metrics\n        for agent_id, agent_info in self.agent_registry.items():\n            agent_metrics = await self.collect_agent_metrics(agent_id)\n            metrics["agent_metrics"][agent_id] = agent_metrics\n        \n        # Collect collaboration metrics\n        metrics["collaboration_metrics"] = await self.collect_collaboration_metrics()\n        \n        # Calculate system-wide health scores\n        metrics["system_health"] = self.calculate_system_health(metrics)\n        \n        return metrics\n    \n    def calculate_system_health(self, metrics: Dict[str, Any]) -> Dict[str, Any]:\n        """Calculate overall system health score"""\n        \n        agent_metrics = metrics["agent_metrics"]\n        collaboration_metrics = metrics["collaboration_metrics"]\n        \n        # Individual agent health\n        agent_health_scores = []\n        for agent_id, agent_data in agent_metrics.items():\n            health_score = (\n                (1.0 - agent_data.get("error_rate", 0.0)) * 0.4 +\n                (1.0 / max(agent_data.get("avg_response_time", 1.0), 1.0)) * 0.3 +\n                agent_data.get("availability", 1.0) * 0.3\n            )\n            agent_health_scores.append(health_score)\n        \n        avg_agent_health = sum(agent_health_scores) / len(agent_health_scores) if agent_health_scores else 0.0\n        \n        # Collaboration health\n        collaboration_success_rate = collaboration_metrics.get("success_rate", 1.0)\n        avg_collaboration_time = collaboration_metrics.get("avg_coordination_time", 1.0)\n        collaboration_health = collaboration_success_rate * (1.0 / max(avg_collaboration_time, 1.0))\n        \n        # Overall system health\n        overall_health = (avg_agent_health * 0.7) + (collaboration_health * 0.3)\n        \n        return {\n            "overall_health_score": overall_health,\n            "agent_health_score": avg_agent_health,\n            "collaboration_health_score": collaboration_health,\n            "health_grade": self.get_health_grade(overall_health),\n            "recommendations": self.generate_health_recommendations(metrics)\n        }\n    \n    def generate_health_recommendations(self, metrics: Dict[str, Any]) -> List[str]:\n        """Generate recommendations for improving system health"""\n        recommendations = []\n        \n        # Check individual agent performance\n        for agent_id, agent_data in metrics["agent_metrics"].items():\n            if agent_data.get("error_rate", 0.0) > self.alert_thresholds["error_rate"]:\n                recommendations.append("High error rate in {agent_id} - review error logs and agent logic".format(agent_id))\n            \n            if agent_data.get("avg_response_time", 0.0) > self.alert_thresholds["response_time"]:\n                recommendations.append("Slow response time in {agent_id} - consider optimization or scaling".format(agent_id))\n        \n        # Check collaboration metrics\n        collab_metrics = metrics["collaboration_metrics"]\n        if collab_metrics.get("failure_rate", 0.0) > self.alert_thresholds["collaboration_failure_rate"]:\n            recommendations.append("High collaboration failure rate - review coordination mechanisms")\n        \n        if not recommendations:\n            recommendations.append("System is performing well - no immediate action required")\n        \n        return recommendations\n'})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{children:"\uD83D\uDE80 Best Practices for Multi-Agent Systems"}),"\n",(0,s.jsx)(n.h3,{children:"1. Design Principles"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Single Responsibility"}),": Each agent should have a clearly defined role"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Loose Coupling"}),": Minimize dependencies between agents"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Graceful Degradation"}),": System should function even if some agents fail"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Scalability"}),": Design for horizontal scaling of agent instances"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Observability"}),": Comprehensive monitoring and logging at all levels"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{children:"2. Communication Strategies"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Asynchronous Messaging"}),": Use message queues for reliable communication"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Protocol Standardization"}),": Define clear message formats and protocols"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Timeout Management"}),": Implement timeouts for all inter-agent communications"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Circuit Breakers"}),": Prevent cascade failures in agent networks"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{children:"3. Error Handling"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Isolation"}),": Agent failures should not cascade to other agents"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Recovery"}),": Implement automatic recovery mechanisms"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Escalation"}),": Clear escalation paths for unrecoverable errors"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Learning"}),": Update agent behavior based on failure patterns"]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{children:"\uD83C\uDFAF Real-World Use Cases"}),"\n",(0,s.jsx)(n.p,{children:"Multi-agent architectures excel in scenarios requiring:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Complex Problem Decomposition"}),": Breaking large problems into specialized subtasks"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Parallel Processing"}),": Handling multiple tasks simultaneously"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Fault Tolerance"}),": Maintaining system operation despite individual failures"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Scalability"}),": Adapting to varying workloads by adding/removing agents"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Specialization"}),": Leveraging domain-specific expertise across different agents"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["In our next post, we'll dive deep into ",(0,s.jsx)(n.strong,{children:"LangChain Framework Patterns"})," and explore how to implement these multi-agent systems using LangChain's powerful abstractions and tools."]})]})}function l(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(o,{...e})}):o(e)}},38039:function(e,n,t){t.r(n),t.d(n,{default:function(){return l},frontmatter:function(){return a},metadata:function(){return i}});var s=t(57437),r=t(52671);let a=void 0,i={postId:"a1b2c3d4-multi-agent-001",title:"Multi-Agent Systems: Collaboration and Coordination in Agentic Software",date:"2025-06-21",excerpt:"Explore how multiple agents can collaborate, communicate, and coordinate to solve complex problems in agentic software.",author:"Abstract Algorithms",tags:["Multi-Agent","Agents","Collaboration","Coordination"],coverImage:"/posts/multi-agent-systems-in-practice/assets/overview.png"};function o(e){let n={em:"em",h2:"h2",hr:"hr",li:"li",p:"p",ul:"ul",...(0,r.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:"This post explores the principles and patterns of multi-agent systems, where multiple agents work together to achieve shared or distributed goals."}),"\n",(0,s.jsx)(n.h2,{children:"What is a Multi-Agent System?"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"A system with two or more agents that interact, cooperate, or compete."}),"\n",(0,s.jsx)(n.li,{children:"Used in distributed AI, robotics, simulations, and modern LLM-powered applications."}),"\n"]}),"\n",(0,s.jsx)(n.h2,{children:"Key Concepts"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Communication protocols (messages, signals)"}),"\n",(0,s.jsx)(n.li,{children:"Coordination strategies (leader election, consensus)"}),"\n",(0,s.jsx)(n.li,{children:"Collaboration vs. competition"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{children:"Example Use Cases"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Automated trading bots"}),"\n",(0,s.jsx)(n.li,{children:"Distributed monitoring and alerting"}),"\n",(0,s.jsx)(n.li,{children:"Multi-agent chat assistants"}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:"Next: Learn about LangChain and LangGraph for building agentic workflows."})})]})}function l(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(o,{...e})}):o(e)}},66597:function(e,n,t){t.r(n),t.d(n,{default:function(){return l},frontmatter:function(){return a},metadata:function(){return i}});var s=t(57437),r=t(52671);let a=void 0,i={postId:"multi-agent-systems-20250626",title:"Multi-Agent Systems: Communication, Coordination, and Collaboration",date:"2025-06-26",excerpt:"An introduction to multi-agent systems, how agents communicate, coordinate, and collaborate to solve complex problems.",author:"Abstract Algorithms",tags:["agents","multi-agent","communication","collaboration"],coverImage:"/posts/multi-agent-systems/assets/multi-agent-systems.png"};function o(e){let n={h1:"h1",li:"li",p:"p",ul:"ul",...(0,r.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{children:"Multi-Agent Systems: Communication, Coordination, and Collaboration"}),"\n",(0,s.jsx)(n.p,{children:"This post covers the basics of multi-agent systems (MAS):"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"How agents communicate (messaging, protocols)"}),"\n",(0,s.jsx)(n.li,{children:"Coordination strategies"}),"\n",(0,s.jsx)(n.li,{children:"Collaboration for distributed problem-solving"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Understanding MAS is key for building scalable, robust agentic applications."})]})}function l(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(o,{...e})}):o(e)}}}]);