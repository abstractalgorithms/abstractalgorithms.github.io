"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[27],{6291:function(n,r,e){e.r(r),e.d(r,{default:function(){return o},frontmatter:function(){return s}});var t=e(7437),i=e(4229);let s=void 0;function a(n){let r={blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.a)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(r.h1,{children:"Introduction & Fundamentals"}),"\n",(0,t.jsxs)(r.p,{children:["Welcome to ",(0,t.jsx)(r.strong,{children:"Big O Notation Mastery"})," – your complete guide to understanding and applying algorithm complexity analysis. Whether you're preparing for technical interviews, optimizing production code, or simply want to think like a computer scientist, this series will transform how you analyze and compare algorithms."]}),"\n",(0,t.jsx)(r.h2,{children:"What Is Big O Notation?"}),"\n",(0,t.jsxs)(r.p,{children:["Big O notation is the ",(0,t.jsx)(r.strong,{children:"universal language"})," for describing algorithm efficiency. It tells us how an algorithm's performance scales as input size grows, focusing on the ",(0,t.jsx)(r.strong,{children:"worst-case scenario"})," and ",(0,t.jsx)(r.strong,{children:"dominant growth factors"}),"."]}),"\n",(0,t.jsxs)(r.p,{children:["Think of it as a ",(0,t.jsx)(r.strong,{children:"performance forecast"}),": if your algorithm works well with 100 items, how will it perform with 1,000? 10,000? 1 million?"]}),"\n",(0,t.jsx)(r.h3,{children:"Why Big O Matters"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"// Algorithm A: Linear search\r\nfunction findUser(users, targetId) {\r\n  for (let user of users) {\r\n    if (user.id === targetId) return user;\r\n  }\r\n  return null;\r\n}\r\n\r\n// Algorithm B: Hash table lookup\r\nfunction findUserOptimized(userMap, targetId) {\r\n  return userMap[targetId] || null;\r\n}\n"})}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Algorithm A"}),": O(n) - performance degrades linearly"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Algorithm B"}),": O(1) - consistent performance regardless of data size"]}),"\n"]}),"\n",(0,t.jsxs)(r.blockquote,{children:["\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.strong,{children:"Real Impact"}),": With 1 million users, Algorithm A might take 500,000 operations on average, while Algorithm B takes just 1."]}),"\n"]}),"\n",(0,t.jsx)(r.h2,{children:"Core Principles"}),"\n",(0,t.jsx)(r.h3,{children:"1. Focus on Growth Rate, Not Exact Values"}),"\n",(0,t.jsx)(r.p,{children:"Big O ignores constants and lower-order terms:"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{children:"3n\xb2 + 5n + 10 → O(n\xb2)\n"})}),"\n",(0,t.jsxs)(r.p,{children:["Why? As ",(0,t.jsx)(r.code,{children:"n"})," grows large, the ",(0,t.jsx)(r.code,{children:"n\xb2"})," term dominates everything else."]}),"\n",(0,t.jsx)(r.h3,{children:"2. Worst-Case Analysis"}),"\n",(0,t.jsxs)(r.p,{children:["We analyze the ",(0,t.jsx)(r.strong,{children:"worst possible scenario"}),":"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"function linearSearch(arr, target) {\r\n  for (let i = 0; i < arr.length; i++) {\r\n    if (arr[i] === target) return i;\r\n  }\r\n  return -1; // Worst case: element not found or at the end\r\n}\n"})}),"\n",(0,t.jsx)(r.h3,{children:"3. Input Size Matters Most"}),"\n",(0,t.jsxs)(r.p,{children:["Big O describes how performance changes ",(0,t.jsx)(r.strong,{children:"relative to input size"}),", not absolute performance."]}),"\n",(0,t.jsx)(r.h2,{children:"Time vs Space Complexity"}),"\n",(0,t.jsx)(r.h3,{children:"Time Complexity"}),"\n",(0,t.jsxs)(r.p,{children:["How ",(0,t.jsx)(r.strong,{children:"execution time"})," grows with input size."]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"// O(n) time - must check each element\r\nfunction sum(numbers) {\r\n  let total = 0;\r\n  for (let num of numbers) {\r\n    total += num;\r\n  }\r\n  return total;\r\n}\n"})}),"\n",(0,t.jsx)(r.h3,{children:"Space Complexity"}),"\n",(0,t.jsxs)(r.p,{children:["How ",(0,t.jsx)(r.strong,{children:"memory usage"})," grows with input size."]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"// O(n) space - creates a copy of the array\r\nfunction reverseArray(arr) {\r\n  return [...arr].reverse();\r\n}\r\n\r\n// O(1) space - modifies in place\r\nfunction reverseInPlace(arr) {\r\n  let left = 0, right = arr.length - 1;\r\n  while (left < right) {\r\n    [arr[left], arr[right]] = [arr[right], arr[left]];\r\n    left++;\r\n    right--;\r\n  }\r\n  return arr;\r\n}\n"})}),"\n",(0,t.jsx)(r.h2,{children:"The Big O Hierarchy"}),"\n",(0,t.jsx)(r.p,{children:"From fastest to slowest growth rates:"}),"\n",(0,t.jsxs)(r.table,{children:[(0,t.jsx)(r.thead,{children:(0,t.jsxs)(r.tr,{children:[(0,t.jsx)(r.th,{children:"Notation"}),(0,t.jsx)(r.th,{children:"Name"}),(0,t.jsx)(r.th,{children:"Example"})]})}),(0,t.jsxs)(r.tbody,{children:[(0,t.jsxs)(r.tr,{children:[(0,t.jsx)(r.td,{children:"O(1)"}),(0,t.jsx)(r.td,{children:"Constant"}),(0,t.jsx)(r.td,{children:"Array access"})]}),(0,t.jsxs)(r.tr,{children:[(0,t.jsx)(r.td,{children:"O(log n)"}),(0,t.jsx)(r.td,{children:"Logarithmic"}),(0,t.jsx)(r.td,{children:"Binary search"})]}),(0,t.jsxs)(r.tr,{children:[(0,t.jsx)(r.td,{children:"O(n)"}),(0,t.jsx)(r.td,{children:"Linear"}),(0,t.jsx)(r.td,{children:"Linear search"})]}),(0,t.jsxs)(r.tr,{children:[(0,t.jsx)(r.td,{children:"O(n log n)"}),(0,t.jsx)(r.td,{children:"Linearithmic"}),(0,t.jsx)(r.td,{children:"Merge sort"})]}),(0,t.jsxs)(r.tr,{children:[(0,t.jsx)(r.td,{children:"O(n\xb2)"}),(0,t.jsx)(r.td,{children:"Quadratic"}),(0,t.jsx)(r.td,{children:"Bubble sort"})]}),(0,t.jsxs)(r.tr,{children:[(0,t.jsx)(r.td,{children:"O(2ⁿ)"}),(0,t.jsx)(r.td,{children:"Exponential"}),(0,t.jsx)(r.td,{children:"Tower of Hanoi"})]}),(0,t.jsxs)(r.tr,{children:[(0,t.jsx)(r.td,{children:"O(n!)"}),(0,t.jsx)(r.td,{children:"Factorial"}),(0,t.jsx)(r.td,{children:"All permutations"})]})]})]}),"\n",(0,t.jsx)(r.h3,{children:"Visual Growth Comparison"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{children:"n = 10:\r\nO(1): 1 operation\r\nO(log n): ~3 operations\r\nO(n): 10 operations\r\nO(n\xb2): 100 operations\r\nO(2ⁿ): 1,024 operations\r\n\r\nn = 1,000:\r\nO(1): 1 operation\r\nO(log n): ~10 operations\r\nO(n): 1,000 operations\r\nO(n\xb2): 1,000,000 operations\r\nO(2ⁿ): 1.07 \xd7 10\xb3⁰\xb9 operations (impossible!)\n"})}),"\n",(0,t.jsx)(r.h2,{children:"Key Takeaways"}),"\n",(0,t.jsxs)(r.ol,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Big O predicts scalability"}),", not absolute speed"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Worst-case analysis"})," ensures reliable performance estimates"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Growth rate dominates"})," - constants become irrelevant at scale"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Both time and space"})," complexity matter in real applications"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Choose the right algorithm"})," for your expected data size"]}),"\n"]}),"\n",(0,t.jsx)(r.hr,{}),"\n",(0,t.jsxs)(r.p,{children:["Ready to dive deeper? In the next part, we'll explore ",(0,t.jsx)(r.strong,{children:"Common Time Complexities"})," with detailed examples and practical applications that will solidify your understanding of each complexity class."]}),"\n",(0,t.jsx)(r.h3,{children:"What's Next?"}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.strong,{children:"Part 2: Common Time Complexities"})," - Master O(1), O(log n), O(n), O(n log n), and O(n\xb2) with real code examples and optimization techniques."]})]})}function o(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:r}={...(0,i.a)(),...n.components};return r?(0,t.jsx)(r,{...n,children:(0,t.jsx)(a,{...n})}):a(n)}},2069:function(n,r,e){e.r(r),e.d(r,{default:function(){return o},frontmatter:function(){return s}});var t=e(7437),i=e(4229);let s=void 0;function a(n){let r={blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.a)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(r.h1,{children:"Common Time Complexities"}),"\n",(0,t.jsx)(r.p,{children:"Understanding the most frequent complexity classes is essential for algorithm analysis. Let's explore each one with practical examples, optimization techniques, and real-world applications."}),"\n",(0,t.jsx)(r.h2,{children:"O(1) - Constant Time"}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.strong,{children:"Definition"}),": Performance remains constant regardless of input size."]}),"\n",(0,t.jsx)(r.h3,{children:"Key Characteristics"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Same execution time"})," for any input size"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Most efficient"})," possible complexity"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Direct access"})," operations"]}),"\n"]}),"\n",(0,t.jsx)(r.h3,{children:"Examples"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"// Array element access\r\nfunction getFirstElement(arr) {\r\n  return arr[0]; // Always one operation\r\n}\r\n\r\n// Hash table operations\r\nconst userMap = new Map();\r\nfunction getUser(id) {\r\n  return userMap.get(id); // O(1) average case\r\n}\r\n\r\n// Mathematical operations\r\nfunction isEven(n) {\r\n  return n % 2 === 0; // Always constant time\r\n}\n"})}),"\n",(0,t.jsx)(r.h3,{children:"Real-World Applications"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsx)(r.li,{children:"Database primary key lookups"}),"\n",(0,t.jsx)(r.li,{children:"Hash table operations"}),"\n",(0,t.jsx)(r.li,{children:"Stack push/pop operations"}),"\n",(0,t.jsx)(r.li,{children:"Array index access"}),"\n"]}),"\n",(0,t.jsxs)(r.blockquote,{children:["\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.strong,{children:"Pro Tip"}),": Strive for O(1) operations in critical code paths. Hash tables and arrays with direct indexing are your best friends."]}),"\n"]}),"\n",(0,t.jsx)(r.h2,{children:"O(log n) - Logarithmic Time"}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.strong,{children:"Definition"}),": Divides the problem in half with each step."]}),"\n",(0,t.jsx)(r.h3,{children:"Key Characteristics"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Extremely efficient"})," for large datasets"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Divide-and-conquer"})," approach"]}),"\n",(0,t.jsx)(r.li,{children:"Growth rate slows as input increases"}),"\n"]}),"\n",(0,t.jsx)(r.h3,{children:"Binary Search Example"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"function binarySearch(sortedArr, target) {\r\n  let left = 0;\r\n  let right = sortedArr.length - 1;\r\n  \r\n  while (left <= right) {\r\n    const mid = Math.floor((left + right) / 2);\r\n    \r\n    if (sortedArr[mid] === target) {\r\n      return mid; // Found it!\r\n    }\r\n    \r\n    if (sortedArr[mid] < target) {\r\n      left = mid + 1; // Search right half\r\n    } else {\r\n      right = mid - 1; // Search left half\r\n    }\r\n  }\r\n  \r\n  return -1; // Not found\r\n}\r\n\r\n// Performance: 1 million items = ~20 comparisons max!\n"})}),"\n",(0,t.jsx)(r.h3,{children:"Tree Operations"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"// Binary search tree lookup\r\nclass BST {\r\n  find(value, node = this.root) {\r\n    if (!node) return null;\r\n    \r\n    if (value === node.value) return node;\r\n    if (value < node.value) return this.find(value, node.left);\r\n    return this.find(value, node.right);\r\n  }\r\n}\n"})}),"\n",(0,t.jsx)(r.h3,{children:"Real-World Applications"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsx)(r.li,{children:"Binary search in sorted data"}),"\n",(0,t.jsx)(r.li,{children:"Balanced tree operations"}),"\n",(0,t.jsx)(r.li,{children:"Database B-tree indexes"}),"\n",(0,t.jsx)(r.li,{children:"Logarithmic algorithms (merge sort's divide step)"}),"\n"]}),"\n",(0,t.jsx)(r.h2,{children:"O(n) - Linear Time"}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.strong,{children:"Definition"}),": Performance scales directly with input size."]}),"\n",(0,t.jsx)(r.h3,{children:"Key Characteristics"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"One pass"})," through the data"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Proportional growth"})," to input size"]}),"\n",(0,t.jsxs)(r.li,{children:["Often ",(0,t.jsx)(r.strong,{children:"unavoidable"})," when processing all data"]}),"\n"]}),"\n",(0,t.jsx)(r.h3,{children:"Examples"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"// Linear search\r\nfunction findElement(arr, target) {\r\n  for (let i = 0; i < arr.length; i++) {\r\n    if (arr[i] === target) return i;\r\n  }\r\n  return -1;\r\n}\r\n\r\n// Array sum\r\nfunction calculateSum(numbers) {\r\n  let sum = 0;\r\n  for (let num of numbers) {\r\n    sum += num; // Must visit each element\r\n  }\r\n  return sum;\r\n}\r\n\r\n// String operations\r\nfunction countVowels(str) {\r\n  let count = 0;\r\n  const vowels = 'aeiouAEIOU';\r\n  \r\n  for (let char of str) {\r\n    if (vowels.includes(char)) count++;\r\n  }\r\n  return count;\r\n}\n"})}),"\n",(0,t.jsx)(r.h3,{children:"Optimization Techniques"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"// Bad: O(n) inside O(n) = O(n\xb2)\r\nfunction hasDuplicates(arr) {\r\n  for (let i = 0; i < arr.length; i++) {\r\n    for (let j = i + 1; j < arr.length; j++) {\r\n      if (arr[i] === arr[j]) return true;\r\n    }\r\n  }\r\n  return false;\r\n}\r\n\r\n// Better: O(n) using Set\r\nfunction hasDuplicatesOptimized(arr) {\r\n  const seen = new Set();\r\n  for (let item of arr) {\r\n    if (seen.has(item)) return true;\r\n    seen.add(item);\r\n  }\r\n  return false;\r\n}\n"})}),"\n",(0,t.jsx)(r.h2,{children:"O(n log n) - Linearithmic Time"}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.strong,{children:"Definition"}),": Combination of linear and logarithmic factors."]}),"\n",(0,t.jsx)(r.h3,{children:"Key Characteristics"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Optimal"})," for comparison-based sorting"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Divide-and-conquer"})," with linear work per level"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Efficient"})," for large datasets"]}),"\n"]}),"\n",(0,t.jsx)(r.h3,{children:"Merge Sort Example"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"function mergeSort(arr) {\r\n  if (arr.length <= 1) return arr;\r\n  \r\n  // Divide: O(log n) levels\r\n  const mid = Math.floor(arr.length / 2);\r\n  const left = mergeSort(arr.slice(0, mid));\r\n  const right = mergeSort(arr.slice(mid));\r\n  \r\n  // Conquer: O(n) work per level\r\n  return merge(left, right);\r\n}\r\n\r\nfunction merge(left, right) {\r\n  const result = [];\r\n  let i = 0, j = 0;\r\n  \r\n  while (i < left.length && j < right.length) {\r\n    if (left[i] <= right[j]) {\r\n      result.push(left[i++]);\r\n    } else {\r\n      result.push(right[j++]);\r\n    }\r\n  }\r\n  \r\n  return result.concat(left.slice(i), right.slice(j));\r\n}\n"})}),"\n",(0,t.jsx)(r.h3,{children:"Real-World Applications"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsx)(r.li,{children:"Efficient sorting algorithms (merge sort, heap sort)"}),"\n",(0,t.jsx)(r.li,{children:"Building balanced trees"}),"\n",(0,t.jsx)(r.li,{children:"Fast Fourier Transform"}),"\n",(0,t.jsx)(r.li,{children:"Closest pair problems"}),"\n"]}),"\n",(0,t.jsx)(r.h2,{children:"O(n\xb2) - Quadratic Time"}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.strong,{children:"Definition"}),": Performance grows quadratically with input size."]}),"\n",(0,t.jsx)(r.h3,{children:"Key Characteristics"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Nested loops"})," over the same dataset"]}),"\n",(0,t.jsx)(r.li,{children:(0,t.jsx)(r.strong,{children:"Rapid performance degradation"})}),"\n",(0,t.jsxs)(r.li,{children:["Often indicates ",(0,t.jsx)(r.strong,{children:"optimization opportunity"})]}),"\n"]}),"\n",(0,t.jsx)(r.h3,{children:"Examples"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"// Bubble sort\r\nfunction bubbleSort(arr) {\r\n  const n = arr.length;\r\n  \r\n  for (let i = 0; i < n - 1; i++) {      // Outer loop: n times\r\n    for (let j = 0; j < n - i - 1; j++) { // Inner loop: n times\r\n      if (arr[j] > arr[j + 1]) {\r\n        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];\r\n      }\r\n    }\r\n  }\r\n  return arr;\r\n}\r\n\r\n// Matrix multiplication\r\nfunction multiplyMatrices(A, B) {\r\n  const rows = A.length;\r\n  const cols = B[0].length;\r\n  const result = Array(rows).fill().map(() => Array(cols).fill(0));\r\n  \r\n  for (let i = 0; i < rows; i++) {\r\n    for (let j = 0; j < cols; j++) {\r\n      for (let k = 0; k < A[0].length; k++) {\r\n        result[i][j] += A[i][k] * B[k][j];\r\n      }\r\n    }\r\n  }\r\n  return result;\r\n}\n"})}),"\n",(0,t.jsx)(r.h3,{children:"When O(n\xb2) Is Acceptable"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"// Small datasets (n < 50)\r\nfunction insertionSort(arr) {\r\n  for (let i = 1; i < arr.length; i++) {\r\n    let current = arr[i];\r\n    let j = i - 1;\r\n    \r\n    while (j >= 0 && arr[j] > current) {\r\n      arr[j + 1] = arr[j];\r\n      j--;\r\n    }\r\n    arr[j + 1] = current;\r\n  }\r\n  return arr;\r\n}\n"})}),"\n",(0,t.jsx)(r.h2,{children:"Performance Comparison"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"// Performance test for different complexities\r\nconst sizes = [100, 1000, 10000];\r\n\r\nsizes.forEach(n => {\r\n  console.log(`Input size: ${n}`);\r\n  console.log(`O(1):       1 operation`);\r\n  console.log(`O(log n):   ${Math.ceil(Math.log2(n))} operations`);\r\n  console.log(`O(n):       ${n} operations`);\r\n  console.log(`O(n log n): ${Math.ceil(n * Math.log2(n))} operations`);\r\n  console.log(`O(n\xb2):      ${n * n} operations`);\r\n  console.log('---');\r\n});\n"})}),"\n",(0,t.jsx)(r.h2,{children:"Optimization Strategies"}),"\n",(0,t.jsx)(r.h3,{children:"1. Cache Results"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"// Memoization for expensive O(n) operations\r\nconst cache = new Map();\r\nfunction expensiveOperation(arr) {\r\n  const key = arr.join(',');\r\n  if (cache.has(key)) return cache.get(key);\r\n  \r\n  const result = arr.reduce((sum, num) => sum + num, 0);\r\n  cache.set(key, result);\r\n  return result;\r\n}\n"})}),"\n",(0,t.jsx)(r.h3,{children:"2. Use Better Data Structures"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"// O(n\xb2) approach\r\nfunction findIntersection(arr1, arr2) {\r\n  const result = [];\r\n  for (let item1 of arr1) {\r\n    for (let item2 of arr2) {\r\n      if (item1 === item2 && !result.includes(item1)) {\r\n        result.push(item1);\r\n      }\r\n    }\r\n  }\r\n  return result;\r\n}\r\n\r\n// O(n) approach\r\nfunction findIntersectionOptimized(arr1, arr2) {\r\n  const set1 = new Set(arr1);\r\n  const result = new Set();\r\n  \r\n  for (let item of arr2) {\r\n    if (set1.has(item)) {\r\n      result.add(item);\r\n    }\r\n  }\r\n  return Array.from(result);\r\n}\n"})}),"\n",(0,t.jsx)(r.h2,{children:"Key Takeaways"}),"\n",(0,t.jsxs)(r.ol,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"O(1) and O(log n)"})," scale excellently - prioritize these when possible"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"O(n)"})," is often unavoidable but efficient for single-pass operations"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"O(n log n)"})," is optimal for comparison-based sorting"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"O(n\xb2)"})," should be avoided for large datasets - look for optimization opportunities"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Choose algorithms"})," based on expected input size and performance requirements"]}),"\n"]}),"\n",(0,t.jsx)(r.hr,{}),"\n",(0,t.jsxs)(r.p,{children:["Next up: ",(0,t.jsx)(r.strong,{children:"Algorithm Analysis Techniques"})," - Learn systematic methods for calculating complexity and master the rules that govern Big O analysis."]}),"\n",(0,t.jsx)(r.h3,{children:"What's Next?"}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.strong,{children:"Part 3: Algorithm Analysis Techniques"})," - Step-by-step methods for calculating complexity, mathematical rules, and practical analysis strategies."]})]})}function o(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:r}={...(0,i.a)(),...n.components};return r?(0,t.jsx)(r,{...n,children:(0,t.jsx)(a,{...n})}):a(n)}},7130:function(n,r,e){e.r(r),e.d(r,{default:function(){return o},frontmatter:function(){return s}});var t=e(7437),i=e(4229);let s=void 0;function a(n){let r={code:"code",h1:"h1",h2:"h2",h3:"h3",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.a)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(r.h1,{children:"Algorithm Analysis Techniques"}),"\n",(0,t.jsx)(r.p,{children:"Calculating Big O complexity isn't guesswork – it's a systematic process. Master these analysis techniques and you'll be able to determine the complexity of any algorithm with confidence."}),"\n",(0,t.jsx)(r.h2,{children:"The Step-by-Step Analysis Method"}),"\n",(0,t.jsx)(r.h3,{children:"1. Identify the Input"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsx)(r.li,{children:"What parameter determines the algorithm's workload?"}),"\n",(0,t.jsx)(r.li,{children:"Is it array length, string length, tree height, or something else?"}),"\n"]}),"\n",(0,t.jsx)(r.h3,{children:"2. Count Basic Operations"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsx)(r.li,{children:"Focus on the most frequently executed operation"}),"\n",(0,t.jsx)(r.li,{children:"Usually: comparisons, assignments, arithmetic operations"}),"\n"]}),"\n",(0,t.jsx)(r.h3,{children:"3. Express as a Function of Input Size"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsx)(r.li,{children:"How many times does the basic operation execute?"}),"\n",(0,t.jsx)(r.li,{children:"Create a mathematical expression: T(n) = ..."}),"\n"]}),"\n",(0,t.jsx)(r.h3,{children:"4. Apply Big O Rules"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsx)(r.li,{children:"Drop constants and lower-order terms"}),"\n",(0,t.jsx)(r.li,{children:"Focus on the dominant growth factor"}),"\n"]}),"\n",(0,t.jsx)(r.h2,{children:"Loop Analysis Patterns"}),"\n",(0,t.jsx)(r.h3,{children:"Single Loop = O(n)"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"function sumArray(arr) {\r\n  let sum = 0;                    // O(1)\r\n  for (let i = 0; i < arr.length; i++) {  // Loop runs n times\r\n    sum += arr[i];                // O(1) operation \xd7 n times\r\n  }\r\n  return sum;                     // O(1)\r\n}\r\n// Total: O(1) + O(n) + O(1) = O(n)\n"})}),"\n",(0,t.jsx)(r.h3,{children:"Nested Loops = O(n\xb2)"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"function bubbleSort(arr) {\r\n  const n = arr.length;\r\n  for (let i = 0; i < n; i++) {          // Outer: n iterations\r\n    for (let j = 0; j < n - 1; j++) {    // Inner: n iterations each\r\n      if (arr[j] > arr[j + 1]) {         // O(1) \xd7 n \xd7 n = O(n\xb2)\r\n        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];\r\n      }\r\n    }\r\n  }\r\n}\r\n// Total: O(n\xb2)\n"})}),"\n",(0,t.jsx)(r.h3,{children:"Variable Inner Loop"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"function printPairs(arr) {\r\n  for (let i = 0; i < arr.length; i++) {\r\n    for (let j = i + 1; j < arr.length; j++) {\r\n      console.log(arr[i], arr[j]);\r\n    }\r\n  }\r\n}\r\n/*\r\nAnalysis:\r\ni=0: inner loop runs n-1 times\r\ni=1: inner loop runs n-2 times\r\n...\r\ni=n-2: inner loop runs 1 time\r\n\r\nTotal: (n-1) + (n-2) + ... + 1 = n(n-1)/2 = O(n\xb2)\r\n*/\n"})}),"\n",(0,t.jsx)(r.h2,{children:"Conditional Analysis"}),"\n",(0,t.jsx)(r.h3,{children:"Best, Average, and Worst Case"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"function linearSearch(arr, target) {\r\n  for (let i = 0; i < arr.length; i++) {\r\n    if (arr[i] === target) {\r\n      return i;  // Found it!\r\n    }\r\n  }\r\n  return -1;  // Not found\r\n}\r\n\r\n/*\r\nBest case: O(1) - element is first\r\nAverage case: O(n/2) = O(n) - element in middle\r\nWorst case: O(n) - element last or not present\r\n\r\nBig O focuses on worst case: O(n)\r\n*/\n"})}),"\n",(0,t.jsx)(r.h3,{children:"Complex Conditionals"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"function smartSearch(arr, target) {\r\n  // If array is small, use linear search\r\n  if (arr.length < 10) {              // O(n) for small arrays\r\n    return linearSearch(arr, target);\r\n  }\r\n  \r\n  // If array is sorted, use binary search\r\n  if (isSorted(arr)) {                // O(n) to check + O(log n) to search\r\n    return binarySearch(arr, target);\r\n  }\r\n  \r\n  // Otherwise, use linear search\r\n  return linearSearch(arr, target);   // O(n)\r\n}\r\n\r\n/*\r\nAnalysis:\r\n- isSorted check: O(n)\r\n- Best case after check: O(log n)\r\n- Worst case: O(n) + O(n) = O(n)\r\n\r\nOverall: O(n) (worst case dominates)\r\n*/\n"})}),"\n",(0,t.jsx)(r.h2,{children:"Recursive Algorithm Analysis"}),"\n",(0,t.jsx)(r.h3,{children:"Master Method for Divide-and-Conquer"}),"\n",(0,t.jsxs)(r.p,{children:["For recurrences of the form: ",(0,t.jsx)(r.strong,{children:"T(n) = aT(n/b) + f(n)"})]}),"\n",(0,t.jsx)(r.p,{children:"Where:"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"a"})," = number of subproblems"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"n/b"})," = size of each subproblem"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"f(n)"})," = cost of work outside recursion"]}),"\n"]}),"\n",(0,t.jsx)(r.h3,{children:"Binary Search Analysis"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"function binarySearch(arr, target, left = 0, right = arr.length - 1) {\r\n  if (left > right) return -1;               // Base case: O(1)\r\n  \r\n  const mid = Math.floor((left + right) / 2); // O(1)\r\n  \r\n  if (arr[mid] === target) return mid;       // O(1)\r\n  \r\n  if (arr[mid] < target) {\r\n    return binarySearch(arr, target, mid + 1, right);  // T(n/2)\r\n  } else {\r\n    return binarySearch(arr, target, left, mid - 1);   // T(n/2)\r\n  }\r\n}\r\n\r\n/*\r\nRecurrence: T(n) = T(n/2) + O(1)\r\n- a = 1 (one subproblem)\r\n- b = 2 (problem size halved)\r\n- f(n) = O(1) (constant work)\r\n\r\nSolution: T(n) = O(log n)\r\n*/\n"})}),"\n",(0,t.jsx)(r.h3,{children:"Merge Sort Analysis"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"function mergeSort(arr) {\r\n  if (arr.length <= 1) return arr;           // Base case: O(1)\r\n  \r\n  const mid = Math.floor(arr.length / 2);\r\n  const left = mergeSort(arr.slice(0, mid)); // T(n/2)\r\n  const right = mergeSort(arr.slice(mid));   // T(n/2)\r\n  \r\n  return merge(left, right);                 // O(n)\r\n}\r\n\r\n/*\r\nRecurrence: T(n) = 2T(n/2) + O(n)\r\n- a = 2 (two subproblems)\r\n- b = 2 (problem size halved)\r\n- f(n) = O(n) (linear merge cost)\r\n\r\nSolution: T(n) = O(n log n)\r\n*/\n"})}),"\n",(0,t.jsx)(r.h3,{children:"Fibonacci Analysis (Naive)"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"function fibonacci(n) {\r\n  if (n <= 1) return n;                    // Base case: O(1)\r\n  return fibonacci(n - 1) + fibonacci(n - 2); // 2 recursive calls\r\n}\r\n\r\n/*\r\nRecurrence: T(n) = T(n-1) + T(n-2) + O(1)\r\n\r\nThis creates a binary tree of height n:\r\n- Each level roughly doubles the calls\r\n- Total calls ≈ 2^n\r\n\r\nResult: O(2^n) - exponential!\r\n*/\n"})}),"\n",(0,t.jsx)(r.h2,{children:"Advanced Analysis Rules"}),"\n",(0,t.jsx)(r.h3,{children:"Rule 1: Drop Constants"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"// All of these are O(n)\r\nfunction example1(arr) {\r\n  for (let i = 0; i < arr.length; i++) { /* O(1) */ }\r\n}\r\n\r\nfunction example2(arr) {\r\n  for (let i = 0; i < arr.length; i++) { /* O(1) */ }\r\n  for (let i = 0; i < arr.length; i++) { /* O(1) */ }\r\n}\r\n\r\nfunction example3(arr) {\r\n  for (let i = 0; i < arr.length; i += 2) { /* O(1) */ }\r\n}\n"})}),"\n",(0,t.jsx)(r.h3,{children:"Rule 2: Drop Lower-Order Terms"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:'function mixedComplexity(arr) {\r\n  // O(n\xb2) nested loops\r\n  for (let i = 0; i < arr.length; i++) {\r\n    for (let j = 0; j < arr.length; j++) {\r\n      console.log(arr[i], arr[j]);\r\n    }\r\n  }\r\n  \r\n  // O(n) single loop\r\n  for (let i = 0; i < arr.length; i++) {\r\n    console.log(arr[i]);\r\n  }\r\n  \r\n  // O(1) constant operation\r\n  console.log("Done");\r\n}\r\n\r\n// Total: O(n\xb2) + O(n) + O(1) = O(n\xb2)\n'})}),"\n",(0,t.jsx)(r.h3,{children:"Rule 3: Different Inputs = Different Variables"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:'function compareArrays(arr1, arr2) {\r\n  for (let i = 0; i < arr1.length; i++) {     // O(m)\r\n    for (let j = 0; j < arr2.length; j++) {   // O(n)\r\n      if (arr1[i] === arr2[j]) {\r\n        console.log("Match found");\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n// This is O(m \xd7 n), NOT O(n\xb2)!\r\n// Different inputs need different variables\n'})}),"\n",(0,t.jsx)(r.h2,{children:"Common Analysis Mistakes"}),"\n",(0,t.jsx)(r.h3,{children:"Mistake 1: Confusing Best and Worst Case"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"function quicksort(arr) {\r\n  // Best/Average case: O(n log n)\r\n  // Worst case: O(n\xb2) - already sorted array\r\n  \r\n  // Big O reports worst case: O(n\xb2)\r\n  // But average case performance matters too!\r\n}\n"})}),"\n",(0,t.jsx)(r.h3,{children:"Mistake 2: Ignoring Hidden Complexity"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"function hasCommonElements(arr1, arr2) {\r\n  for (let item1 of arr1) {              // O(n)\r\n    if (arr2.includes(item1)) {          // includes() is O(m)!\r\n      return true;\r\n    }\r\n  }\r\n  return false;\r\n}\r\n\r\n// Total: O(n \xd7 m), not O(n)!\n"})}),"\n",(0,t.jsx)(r.h3,{children:"Mistake 3: Recursive Space Complexity"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"function factorial(n) {\r\n  if (n <= 1) return 1;\r\n  return n * factorial(n - 1);\r\n}\r\n\r\n/*\r\nTime: O(n) - n recursive calls\r\nSpace: O(n) - call stack grows to depth n\r\n\r\nDon't forget space complexity in recursive algorithms!\r\n*/\n"})}),"\n",(0,t.jsx)(r.h2,{children:"Practical Analysis Workflow"}),"\n",(0,t.jsx)(r.h3,{children:"Step 1: Identify the Input Size"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"function processMatrix(matrix) {\r\n  // Input size could be:\r\n  // - Total elements: m \xd7 n\r\n  // - Number of rows: m\r\n  // - Number of columns: n\r\n  // Choose based on the algorithm's behavior\r\n}\n"})}),"\n",(0,t.jsx)(r.h3,{children:"Step 2: Count Operations"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"function example(arr) {\r\n  let count = 0;\r\n  \r\n  // Count each operation type:\r\n  for (let i = 0; i < arr.length; i++) {     // n iterations\r\n    count++;                                 // 1 assignment per iteration\r\n    if (arr[i] > 0) {                       // 1 comparison per iteration\r\n      console.log(arr[i]);                  // 1 output per iteration (worst case)\r\n    }\r\n  }\r\n  \r\n  // Total: n \xd7 (1 + 1 + 1) = 3n = O(n)\r\n}\n"})}),"\n",(0,t.jsx)(r.h3,{children:"Step 3: Simplify Using Rules"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"// Before simplification\r\nfunction complex(arr) {\r\n  // Phase 1: O(n)\r\n  for (let i = 0; i < arr.length; i++) { /* ... */ }\r\n  \r\n  // Phase 2: O(n\xb2)\r\n  for (let i = 0; i < arr.length; i++) {\r\n    for (let j = 0; j < arr.length; j++) { /* ... */ }\r\n  }\r\n  \r\n  // Phase 3: O(log n)\r\n  binarySearch(arr, target);\r\n}\r\n\r\n// After simplification: O(n) + O(n\xb2) + O(log n) = O(n\xb2)\n"})}),"\n",(0,t.jsx)(r.h2,{children:"Key Takeaways"}),"\n",(0,t.jsxs)(r.ol,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Follow systematic steps"}),": input → operations → expression → simplification"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Count the dominant operation"})," in the innermost loop"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Consider all cases"})," but report the worst case for Big O"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Use different variables"})," for different inputs"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Don't ignore space complexity"})," in recursive algorithms"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Practice with real code"})," to build intuition"]}),"\n"]}),"\n",(0,t.jsx)(r.hr,{}),"\n",(0,t.jsx)(r.p,{children:"Ready to master space complexity? Next, we'll explore memory analysis and learn when space-time tradeoffs make sense."}),"\n",(0,t.jsx)(r.h3,{children:"What's Next?"}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.strong,{children:"Part 4: Space Complexity Deep Dive"})," - Memory analysis, auxiliary space calculations, and understanding space-time tradeoffs in algorithm design."]})]})}function o(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:r}={...(0,i.a)(),...n.components};return r?(0,t.jsx)(r,{...n,children:(0,t.jsx)(a,{...n})}):a(n)}},3760:function(n,r,e){e.r(r),e.d(r,{default:function(){return o},frontmatter:function(){return s}});var t=e(7437),i=e(4229);let s=void 0;function a(n){let r={blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,i.a)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(r.h1,{children:"Space Complexity Deep Dive"}),"\n",(0,t.jsx)(r.p,{children:"While time complexity gets most attention, space complexity is equally crucial in real-world applications. Understanding memory usage patterns helps you build systems that scale efficiently and avoid out-of-memory errors."}),"\n",(0,t.jsx)(r.h2,{children:"Understanding Space Complexity"}),"\n",(0,t.jsxs)(r.p,{children:["Space complexity measures how an algorithm's ",(0,t.jsx)(r.strong,{children:"memory usage"})," grows with input size. It includes:"]}),"\n",(0,t.jsxs)(r.ol,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Input space"})," - memory for the input data"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Auxiliary space"})," - extra memory used by the algorithm"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Output space"})," - memory for the result"]}),"\n"]}),"\n",(0,t.jsxs)(r.blockquote,{children:["\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.strong,{children:"Important"}),": Big O space complexity typically refers to ",(0,t.jsx)(r.strong,{children:"auxiliary space"})," only – the extra memory beyond the input."]}),"\n"]}),"\n",(0,t.jsx)(r.h2,{children:"Input vs Auxiliary Space"}),"\n",(0,t.jsx)(r.h3,{children:"Input Space"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"function processArray(arr) {\r\n  // arr takes O(n) space, but that's input space\r\n  // We don't count this in auxiliary space complexity\r\n  for (let item of arr) {\r\n    console.log(item);\r\n  }\r\n}\r\n// Auxiliary space: O(1)\n"})}),"\n",(0,t.jsx)(r.h3,{children:"Auxiliary Space"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"function copyAndReverse(arr) {\r\n  const reversed = [];           // O(n) auxiliary space\r\n  for (let i = arr.length - 1; i >= 0; i--) {\r\n    reversed.push(arr[i]);       // Growing the new array\r\n  }\r\n  return reversed;\r\n}\r\n// Auxiliary space: O(n)\n"})}),"\n",(0,t.jsx)(r.h2,{children:"Common Space Complexity Patterns"}),"\n",(0,t.jsx)(r.h3,{children:"O(1) - Constant Space"}),"\n",(0,t.jsx)(r.p,{children:"Algorithms that use a fixed amount of extra memory regardless of input size."}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"// In-place array reversal\r\nfunction reverseInPlace(arr) {\r\n  let left = 0;                  // O(1) space\r\n  let right = arr.length - 1;    // O(1) space\r\n  \r\n  while (left < right) {\r\n    // Swap elements without extra array\r\n    [arr[left], arr[right]] = [arr[right], arr[left]];\r\n    left++;\r\n    right--;\r\n  }\r\n  return arr;\r\n}\r\n// Space: O(1) - only uses a few variables\n"})}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"// Finding maximum element\r\nfunction findMax(arr) {\r\n  let max = arr[0];              // O(1) space\r\n  \r\n  for (let i = 1; i < arr.length; i++) {\r\n    if (arr[i] > max) {\r\n      max = arr[i];              // Still O(1) space\r\n    }\r\n  }\r\n  return max;\r\n}\r\n// Space: O(1) - single variable regardless of array size\n"})}),"\n",(0,t.jsx)(r.h3,{children:"O(n) - Linear Space"}),"\n",(0,t.jsx)(r.p,{children:"Memory usage grows proportionally with input size."}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"// Creating a frequency map\r\nfunction countFrequency(arr) {\r\n  const frequency = {};          // O(n) space in worst case\r\n  \r\n  for (let item of arr) {\r\n    frequency[item] = (frequency[item] || 0) + 1;\r\n  }\r\n  return frequency;\r\n}\r\n// Space: O(n) - map can contain up to n unique elements\n"})}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"// Implementing stack-based operations\r\nfunction reverseString(str) {\r\n  const stack = [];              // O(n) space\r\n  \r\n  // Push all characters\r\n  for (let char of str) {\r\n    stack.push(char);\r\n  }\r\n  \r\n  // Pop to create reversed string\r\n  let reversed = '';\r\n  while (stack.length > 0) {\r\n    reversed += stack.pop();\r\n  }\r\n  \r\n  return reversed;\r\n}\r\n// Space: O(n) - stack holds all n characters\n"})}),"\n",(0,t.jsx)(r.h3,{children:"O(n\xb2) - Quadratic Space"}),"\n",(0,t.jsx)(r.p,{children:"Memory usage grows quadratically with input size."}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"// Creating a 2D distance matrix\r\nfunction createDistanceMatrix(points) {\r\n  const n = points.length;\r\n  const matrix = [];             // O(n\xb2) space\r\n  \r\n  for (let i = 0; i < n; i++) {\r\n    matrix[i] = [];\r\n    for (let j = 0; j < n; j++) {\r\n      matrix[i][j] = calculateDistance(points[i], points[j]);\r\n    }\r\n  }\r\n  return matrix;\r\n}\r\n// Space: O(n\xb2) - n\xd7n matrix\n"})}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"// Dynamic programming table\r\nfunction longestCommonSubsequence(str1, str2) {\r\n  const m = str1.length;\r\n  const n = str2.length;\r\n  const dp = Array(m + 1).fill().map(() => Array(n + 1).fill(0)); // O(m\xd7n)\r\n  \r\n  for (let i = 1; i <= m; i++) {\r\n    for (let j = 1; j <= n; j++) {\r\n      if (str1[i-1] === str2[j-1]) {\r\n        dp[i][j] = dp[i-1][j-1] + 1;\r\n      } else {\r\n        dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);\r\n      }\r\n    }\r\n  }\r\n  return dp[m][n];\r\n}\r\n// Space: O(m\xd7n) - 2D DP table\n"})}),"\n",(0,t.jsx)(r.h2,{children:"Recursive Space Complexity"}),"\n",(0,t.jsxs)(r.p,{children:["Recursive algorithms use the ",(0,t.jsx)(r.strong,{children:"call stack"}),", which consumes memory for each function call."]}),"\n",(0,t.jsx)(r.h3,{children:"Linear Recursive Space - O(n)"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"function factorial(n) {\r\n  if (n <= 1) return 1;          // Base case\r\n  return n * factorial(n - 1);   // Recursive call\r\n}\r\n\r\n/*\r\nCall stack analysis:\r\nfactorial(5)\r\n  factorial(4)\r\n    factorial(3)\r\n      factorial(2)\r\n        factorial(1) → returns 1\r\n      returns 2\r\n    returns 6\r\n  returns 24\r\nreturns 120\r\n\r\nMaximum stack depth: 5 = O(n)\r\nSpace complexity: O(n)\r\n*/\n"})}),"\n",(0,t.jsx)(r.h3,{children:"Logarithmic Recursive Space - O(log n)"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"function binarySearch(arr, target, left = 0, right = arr.length - 1) {\r\n  if (left > right) return -1;\r\n  \r\n  const mid = Math.floor((left + right) / 2);\r\n  \r\n  if (arr[mid] === target) return mid;\r\n  \r\n  if (arr[mid] < target) {\r\n    return binarySearch(arr, target, mid + 1, right);\r\n  } else {\r\n    return binarySearch(arr, target, left, mid - 1);\r\n  }\r\n}\r\n\r\n/*\r\nCall stack analysis for array of size 8:\r\nbinarySearch(arr, target, 0, 7)    // Search entire array\r\n  binarySearch(arr, target, 4, 7)  // Search right half\r\n    binarySearch(arr, target, 6, 7) // Search smaller portion\r\n      ...\r\n\r\nMaximum stack depth: log₂(8) = 3 = O(log n)\r\nSpace complexity: O(log n)\r\n*/\n"})}),"\n",(0,t.jsx)(r.h3,{children:"Exponential Recursive Space - O(n)"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"function fibonacci(n) {\r\n  if (n <= 1) return n;\r\n  return fibonacci(n - 1) + fibonacci(n - 2);\r\n}\r\n\r\n/*\r\nDespite exponential time complexity O(2^n),\r\nspace complexity is only O(n) because:\r\n\r\n- Maximum stack depth is n (longest path from root to leaf)\r\n- Each call uses O(1) space\r\n- Total space: O(n)\r\n\r\nTime: O(2^n), Space: O(n)\r\n*/\n"})}),"\n",(0,t.jsx)(r.h2,{children:"Space-Time Tradeoffs"}),"\n",(0,t.jsx)(r.p,{children:"Often, you can trade space for time or vice versa. Understanding these tradeoffs is crucial for optimization."}),"\n",(0,t.jsx)(r.h3,{children:"Trading Space for Time: Memoization"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"// Time: O(2^n), Space: O(n) - Naive approach\r\nfunction fibonacciNaive(n) {\r\n  if (n <= 1) return n;\r\n  return fibonacciNaive(n - 1) + fibonacciNaive(n - 2);\r\n}\r\n\r\n// Time: O(n), Space: O(n) - Memoized approach\r\nfunction fibonacciMemo(n, memo = {}) {\r\n  if (n in memo) return memo[n];     // O(1) lookup\r\n  if (n <= 1) return n;\r\n  \r\n  memo[n] = fibonacciMemo(n - 1, memo) + fibonacciMemo(n - 2, memo);\r\n  return memo[n];\r\n}\r\n\r\n/*\r\nTradeoff analysis:\r\n- Naive: Fast space, slow time\r\n- Memoized: More space, much faster time\r\n- Best choice depends on available memory and performance needs\r\n*/\n"})}),"\n",(0,t.jsx)(r.h3,{children:"Trading Time for Space: Multiple Passes"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"// One pass, more space: O(n) time, O(n) space\r\nfunction findTwoSumHashMap(arr, target) {\r\n  const seen = new Map();        // O(n) space\r\n  \r\n  for (let i = 0; i < arr.length; i++) {\r\n    const complement = target - arr[i];\r\n    if (seen.has(complement)) {\r\n      return [seen.get(complement), i];\r\n    }\r\n    seen.set(arr[i], i);\r\n  }\r\n  return null;\r\n}\r\n\r\n// Nested loops, less space: O(n\xb2) time, O(1) space\r\nfunction findTwoSumBruteForce(arr, target) {\r\n  for (let i = 0; i < arr.length; i++) {\r\n    for (let j = i + 1; j < arr.length; j++) {\r\n      if (arr[i] + arr[j] === target) {\r\n        return [i, j];\r\n      }\r\n    }\r\n  }\r\n  return null;\r\n}\r\n\r\n/*\r\nTradeoff:\r\n- HashMap: O(n) time, O(n) space - good for large datasets\r\n- Brute force: O(n\xb2) time, O(1) space - good when memory is limited\r\n*/\n"})}),"\n",(0,t.jsx)(r.h2,{children:"In-Place Algorithms"}),"\n",(0,t.jsx)(r.p,{children:"Algorithms that modify input data directly without using significant auxiliary space."}),"\n",(0,t.jsx)(r.h3,{children:"In-Place Sorting"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"// In-place quicksort: O(log n) average space (recursion stack)\r\nfunction quicksortInPlace(arr, low = 0, high = arr.length - 1) {\r\n  if (low < high) {\r\n    const pivotIndex = partition(arr, low, high);\r\n    quicksortInPlace(arr, low, pivotIndex - 1);\r\n    quicksortInPlace(arr, pivotIndex + 1, high);\r\n  }\r\n}\r\n\r\nfunction partition(arr, low, high) {\r\n  const pivot = arr[high];\r\n  let i = low - 1;\r\n  \r\n  for (let j = low; j < high; j++) {\r\n    if (arr[j] <= pivot) {\r\n      i++;\r\n      [arr[i], arr[j]] = [arr[j], arr[i]]; // In-place swap\r\n    }\r\n  }\r\n  \r\n  [arr[i + 1], arr[high]] = [arr[high], arr[i + 1]];\r\n  return i + 1;\r\n}\n"})}),"\n",(0,t.jsx)(r.h3,{children:"In-Place Array Manipulation"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"// Remove duplicates from sorted array in-place\r\nfunction removeDuplicates(arr) {\r\n  if (arr.length <= 1) return arr.length;\r\n  \r\n  let writeIndex = 1;            // O(1) space\r\n  \r\n  for (let readIndex = 1; readIndex < arr.length; readIndex++) {\r\n    if (arr[readIndex] !== arr[readIndex - 1]) {\r\n      arr[writeIndex] = arr[readIndex];\r\n      writeIndex++;\r\n    }\r\n  }\r\n  \r\n  return writeIndex; // New length\r\n}\r\n// Space: O(1) - modifies array in place\n"})}),"\n",(0,t.jsx)(r.h2,{children:"Space Optimization Techniques"}),"\n",(0,t.jsx)(r.h3,{children:"1. Reuse Variables"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"// Less optimal: O(n) space\r\nfunction calculateRunningSum(arr) {\r\n  const result = [];\r\n  let sum = 0;\r\n  \r\n  for (let num of arr) {\r\n    sum += num;\r\n    result.push(sum);\r\n  }\r\n  return result;\r\n}\r\n\r\n// More optimal: O(1) auxiliary space (modifying input)\r\nfunction calculateRunningSumInPlace(arr) {\r\n  for (let i = 1; i < arr.length; i++) {\r\n    arr[i] += arr[i - 1];        // Reuse input array\r\n  }\r\n  return arr;\r\n}\n"})}),"\n",(0,t.jsx)(r.h3,{children:"2. Streaming Processing"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"// Memory-intensive: Load all data\r\nfunction processLargeFile(filename) {\r\n  const allData = readEntireFile(filename);  // O(file size) space\r\n  return processData(allData);\r\n}\r\n\r\n// Memory-efficient: Process in chunks\r\nfunction processLargeFileStreaming(filename) {\r\n  const stream = createReadStream(filename);\r\n  let result = 0;                            // O(1) space\r\n  \r\n  stream.on('data', chunk => {\r\n    result += processChunk(chunk);           // Process small chunks\r\n  });\r\n  \r\n  return result;\r\n}\n"})}),"\n",(0,t.jsx)(r.h3,{children:"3. Space-Optimized Dynamic Programming"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"// Standard DP: O(n) space\r\nfunction climbStairsDP(n) {\r\n  const dp = new Array(n + 1);\r\n  dp[0] = 1;\r\n  dp[1] = 1;\r\n  \r\n  for (let i = 2; i <= n; i++) {\r\n    dp[i] = dp[i - 1] + dp[i - 2];\r\n  }\r\n  return dp[n];\r\n}\r\n\r\n// Space-optimized: O(1) space\r\nfunction climbStairsOptimized(n) {\r\n  if (n <= 1) return 1;\r\n  \r\n  let prev2 = 1;                 // dp[i-2]\r\n  let prev1 = 1;                 // dp[i-1]\r\n  \r\n  for (let i = 2; i <= n; i++) {\r\n    const current = prev1 + prev2;\r\n    prev2 = prev1;               // Slide the window\r\n    prev1 = current;\r\n  }\r\n  return prev1;\r\n}\n"})}),"\n",(0,t.jsx)(r.h2,{children:"Analyzing Memory Usage"}),"\n",(0,t.jsx)(r.h3,{children:"Stack vs Heap"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"// Stack allocation (function parameters, local variables)\r\nfunction stackExample(n) {\r\n  let localVar = 5;              // Stack: O(1)\r\n  \r\n  if (n > 0) {\r\n    return stackExample(n - 1);  // Stack: O(n) recursive calls\r\n  }\r\n  return localVar;\r\n}\r\n\r\n// Heap allocation (dynamic objects, arrays)\r\nfunction heapExample(n) {\r\n  const largeArray = new Array(n); // Heap: O(n)\r\n  const obj = { data: largeArray }; // Heap: O(n)\r\n  return obj;\r\n}\n"})}),"\n",(0,t.jsx)(r.h3,{children:"Memory Leaks and Cleanup"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"// Potential memory leak\r\nfunction createClosure(largeData) {\r\n  return function(query) {\r\n    // This closure keeps largeData in memory\r\n    return largeData.includes(query);\r\n  };\r\n}\r\n\r\n// Memory-conscious approach\r\nfunction createEfficientClosure(largeData) {\r\n  const processedData = processAndMinimize(largeData); // Minimize data\r\n  largeData = null;              // Explicit cleanup\r\n  \r\n  return function(query) {\r\n    return processedData.includes(query);\r\n  };\r\n}\n"})}),"\n",(0,t.jsx)(r.h2,{children:"Key Takeaways"}),"\n",(0,t.jsxs)(r.ol,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Space complexity matters"})," - especially in memory-constrained environments"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Distinguish between input and auxiliary space"})," when analyzing algorithms"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Recursive algorithms use stack space"})," - factor in call stack depth"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Space-time tradeoffs"})," are common - choose based on constraints"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"In-place algorithms"})," can dramatically reduce space complexity"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Consider memory allocation patterns"})," - stack vs heap usage"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Optimize space when possible"})," - but don't sacrifice readability unnecessarily"]}),"\n"]}),"\n",(0,t.jsx)(r.hr,{}),"\n",(0,t.jsx)(r.p,{children:"Ready for advanced complexity analysis? Next, we'll explore exponential algorithms, amortized analysis, and other advanced concepts."}),"\n",(0,t.jsx)(r.h3,{children:"What's Next?"}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.strong,{children:"Part 5: Advanced Complexities"})," - Exponential and factorial time, amortized analysis, and how to handle algorithms that don't fit standard patterns."]})]})}function o(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:r}={...(0,i.a)(),...n.components};return r?(0,t.jsx)(r,{...n,children:(0,t.jsx)(a,{...n})}):a(n)}},8478:function(n,r,e){e.r(r),e.d(r,{default:function(){return o},frontmatter:function(){return s}});var t=e(7437),i=e(4229);let s=void 0;function a(n){let r={code:"code",h1:"h1",h2:"h2",h3:"h3",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.a)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(r.h1,{children:"Advanced Complexities"}),"\n",(0,t.jsx)(r.p,{children:"Beyond the common complexities lie algorithms with exponential growth, factorial behavior, and complex amortized patterns. Understanding these advanced concepts is crucial for tackling difficult problems and making informed algorithmic choices."}),"\n",(0,t.jsx)(r.h2,{children:"Exponential Time Complexity - O(2ⁿ)"}),"\n",(0,t.jsx)(r.p,{children:"Exponential algorithms double their work with each increase in input size. While often impractical for large inputs, they're sometimes the only known solution to certain problems."}),"\n",(0,t.jsx)(r.h3,{children:"Characteristics"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Doubles work"})," with each additional input"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Quickly becomes intractable"})," (unusable for n > 30-40)"]}),"\n",(0,t.jsxs)(r.li,{children:["Often appears in ",(0,t.jsx)(r.strong,{children:"brute force"})," solutions"]}),"\n",(0,t.jsxs)(r.li,{children:["Common in ",(0,t.jsx)(r.strong,{children:"combinatorial problems"})]}),"\n"]}),"\n",(0,t.jsx)(r.h3,{children:"Classic Example: Fibonacci (Naive)"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"function fibonacci(n) {\r\n  if (n <= 1) return n;\r\n  return fibonacci(n - 1) + fibonacci(n - 2);\r\n}\r\n\r\n/*\r\nCall tree for fibonacci(5):\r\n                    fib(5)\r\n                  /        \\\r\n              fib(4)        fib(3)\r\n             /      \\      /      \\\r\n        fib(3)    fib(2) fib(2)  fib(1)\r\n       /     \\    /    \\ /    \\\r\n   fib(2)  fib(1) fib(1) fib(0) fib(1) fib(0)\r\n   /    \\\r\nfib(1) fib(0)\r\n\r\nEach level roughly doubles the number of calls.\r\nTotal calls ≈ 2^n\r\nTime complexity: O(2^n)\r\n*/\n"})}),"\n",(0,t.jsx)(r.h3,{children:"Subset Generation"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"function generateSubsets(nums) {\r\n  const result = [];\r\n  \r\n  function backtrack(index, currentSubset) {\r\n    if (index === nums.length) {\r\n      result.push([...currentSubset]);  // O(n) to copy\r\n      return;\r\n    }\r\n    \r\n    // Include current element\r\n    currentSubset.push(nums[index]);\r\n    backtrack(index + 1, currentSubset);\r\n    \r\n    // Exclude current element\r\n    currentSubset.pop();\r\n    backtrack(index + 1, currentSubset);\r\n  }\r\n  \r\n  backtrack(0, []);\r\n  return result;\r\n}\r\n\r\n/*\r\nAnalysis:\r\n- 2 choices per element (include/exclude)\r\n- n elements total\r\n- Total subsets: 2^n\r\n- Time: O(n \xd7 2^n) - copying takes O(n) time\r\n- Space: O(n \xd7 2^n) - storing all subsets\r\n*/\n"})}),"\n",(0,t.jsx)(r.h3,{children:"Traveling Salesman Problem (Brute Force)"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"function tspBruteForce(distances) {\r\n  const n = distances.length;\r\n  const cities = Array.from({ length: n }, (_, i) => i);\r\n  let minCost = Infinity;\r\n  \r\n  function permute(arr, start = 0) {\r\n    if (start === arr.length - 1) {\r\n      const cost = calculateTourCost(arr, distances);\r\n      minCost = Math.min(minCost, cost);\r\n      return;\r\n    }\r\n    \r\n    for (let i = start; i < arr.length; i++) {\r\n      [arr[start], arr[i]] = [arr[i], arr[start]];\r\n      permute(arr, start + 1);\r\n      [arr[start], arr[i]] = [arr[i], arr[start]]; // backtrack\r\n    }\r\n  }\r\n  \r\n  permute(cities.slice(1)); // Fix first city\r\n  return minCost;\r\n}\r\n\r\n/*\r\nTime complexity: O(n!) - factorial time\r\nEven worse than exponential!\r\n*/\n"})}),"\n",(0,t.jsx)(r.h2,{children:"Factorial Time Complexity - O(n!)"}),"\n",(0,t.jsx)(r.p,{children:"Factorial complexity appears when generating all permutations or exploring all possible orderings."}),"\n",(0,t.jsx)(r.h3,{children:"Permutation Generation"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"function generatePermutations(arr) {\r\n  if (arr.length <= 1) return [arr];\r\n  \r\n  const result = [];\r\n  \r\n  for (let i = 0; i < arr.length; i++) {\r\n    const rest = [...arr.slice(0, i), ...arr.slice(i + 1)];\r\n    const perms = generatePermutations(rest);\r\n    \r\n    for (let perm of perms) {\r\n      result.push([arr[i], ...perm]);\r\n    }\r\n  }\r\n  \r\n  return result;\r\n}\r\n\r\n/*\r\nAnalysis:\r\n- n choices for first position\r\n- (n-1) choices for second position\r\n- ...\r\n- 1 choice for last position\r\n- Total: n \xd7 (n-1) \xd7 ... \xd7 1 = n!\r\n\r\nFor n=10: 3,628,800 permutations!\r\n*/\n"})}),"\n",(0,t.jsx)(r.h3,{children:"When Factorial Complexity Is Unavoidable"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"// Brute force solution to NP-complete problems\r\nfunction hamiltonianPath(graph) {\r\n  const vertices = Object.keys(graph);\r\n  const n = vertices.length;\r\n  \r\n  function hasPath(path) {\r\n    for (let i = 0; i < path.length - 1; i++) {\r\n      if (!graph[path[i]].includes(path[i + 1])) {\r\n        return false;\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n  \r\n  // Try all possible permutations\r\n  const permutations = generatePermutations(vertices);\r\n  \r\n  for (let perm of permutations) {\r\n    if (hasPath(perm)) return perm;\r\n  }\r\n  \r\n  return null; // No Hamiltonian path exists\r\n}\r\n\r\n// Time: O(n! \xd7 n) - checking each permutation takes O(n)\n"})}),"\n",(0,t.jsx)(r.h2,{children:"Amortized Analysis"}),"\n",(0,t.jsxs)(r.p,{children:["Amortized analysis considers the ",(0,t.jsx)(r.strong,{children:"average performance"})," over a sequence of operations, not just worst-case single operations."]}),"\n",(0,t.jsx)(r.h3,{children:"Dynamic Array (ArrayList) Analysis"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"class DynamicArray {\r\n  constructor() {\r\n    this.data = new Array(1);\r\n    this.size = 0;\r\n    this.capacity = 1;\r\n  }\r\n  \r\n  push(item) {\r\n    if (this.size === this.capacity) {\r\n      this.resize();                    // Expensive: O(n)\r\n    }\r\n    \r\n    this.data[this.size] = item;        // Cheap: O(1)\r\n    this.size++;\r\n  }\r\n  \r\n  resize() {\r\n    const newCapacity = this.capacity * 2;\r\n    const newData = new Array(newCapacity);\r\n    \r\n    for (let i = 0; i < this.size; i++) {\r\n      newData[i] = this.data[i];        // Copy all elements: O(n)\r\n    }\r\n    \r\n    this.data = newData;\r\n    this.capacity = newCapacity;\r\n  }\r\n}\r\n\r\n/*\r\nSingle operation analysis:\r\n- Normal push: O(1)\r\n- Push with resize: O(n)\r\n\r\nAmortized analysis:\r\n- Resize happens at: 1, 2, 4, 8, 16, 32, ... elements\r\n- Cost sequence: 1, 2, 1, 4, 1, 1, 1, 8, ...\r\n- Total cost for n pushes: n + (1 + 2 + 4 + 8 + ... + n) < 3n\r\n- Amortized cost per push: O(1)\r\n*/\n"})}),"\n",(0,t.jsx)(r.h3,{children:"Hash Table with Chaining"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"class HashTable {\r\n  constructor(initialSize = 8) {\r\n    this.buckets = new Array(initialSize).fill(null).map(() => []);\r\n    this.size = 0;\r\n    this.capacity = initialSize;\r\n  }\r\n  \r\n  hash(key) {\r\n    let hash = 0;\r\n    for (let char of key) {\r\n      hash = (hash * 31 + char.charCodeAt(0)) % this.capacity;\r\n    }\r\n    return hash;\r\n  }\r\n  \r\n  set(key, value) {\r\n    const index = this.hash(key);\r\n    const bucket = this.buckets[index];\r\n    \r\n    // Check if key exists\r\n    for (let i = 0; i < bucket.length; i++) {\r\n      if (bucket[i][0] === key) {\r\n        bucket[i][1] = value;\r\n        return;\r\n      }\r\n    }\r\n    \r\n    // Add new key-value pair\r\n    bucket.push([key, value]);\r\n    this.size++;\r\n    \r\n    // Resize if load factor > 0.75\r\n    if (this.size > this.capacity * 0.75) {\r\n      this.resize();\r\n    }\r\n  }\r\n  \r\n  resize() {\r\n    const oldBuckets = this.buckets;\r\n    this.capacity *= 2;\r\n    this.buckets = new Array(this.capacity).fill(null).map(() => []);\r\n    this.size = 0;\r\n    \r\n    // Rehash all elements\r\n    for (let bucket of oldBuckets) {\r\n      for (let [key, value] of bucket) {\r\n        this.set(key, value);           // O(n) total work\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/*\r\nAmortized analysis:\r\n- Normal set: O(1) average\r\n- Set with resize: O(n)\r\n- Resize frequency: every n/2 operations (load factor 0.75)\r\n- Amortized cost: O(1) per operation\r\n*/\n"})}),"\n",(0,t.jsx)(r.h2,{children:"Advanced Recursive Complexities"}),"\n",(0,t.jsx)(r.h3,{children:"Tree Recursion with Memoization"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"// Without memoization: O(2^n)\r\nfunction longestIncreasingSubsequence(arr, index = 0, prev = -Infinity) {\r\n  if (index === arr.length) return 0;\r\n  \r\n  // Choice 1: Skip current element\r\n  let skip = longestIncreasingSubsequence(arr, index + 1, prev);\r\n  \r\n  // Choice 2: Include current element (if valid)\r\n  let include = 0;\r\n  if (arr[index] > prev) {\r\n    include = 1 + longestIncreasingSubsequence(arr, index + 1, arr[index]);\r\n  }\r\n  \r\n  return Math.max(skip, include);\r\n}\r\n\r\n// With memoization: O(n\xb2)\r\nfunction longestIncreasingSubsequenceMemo(arr) {\r\n  const memo = new Map();\r\n  \r\n  function helper(index, prevValue) {\r\n    if (index === arr.length) return 0;\r\n    \r\n    const key = `${index}-${prevValue}`;\r\n    if (memo.has(key)) return memo.get(key);\r\n    \r\n    let skip = helper(index + 1, prevValue);\r\n    let include = 0;\r\n    \r\n    if (arr[index] > prevValue) {\r\n      include = 1 + helper(index + 1, arr[index]);\r\n    }\r\n    \r\n    const result = Math.max(skip, include);\r\n    memo.set(key, result);\r\n    return result;\r\n  }\r\n  \r\n  return helper(0, -Infinity);\r\n}\r\n\r\n/*\r\nMemoization transforms:\r\n- Time: O(2^n) → O(n\xb2)\r\n- Space: O(n) → O(n\xb2)\r\n*/\n"})}),"\n",(0,t.jsx)(r.h2,{children:"Logarithmic Factors in Complex Algorithms"}),"\n",(0,t.jsx)(r.h3,{children:"O(n log n) with Different Log Bases"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"// Merge sort: log₂(n) levels\r\nfunction mergeSort(arr) {\r\n  if (arr.length <= 1) return arr;\r\n  \r\n  const mid = Math.floor(arr.length / 2);\r\n  const left = mergeSort(arr.slice(0, mid));\r\n  const right = mergeSort(arr.slice(mid));\r\n  \r\n  return merge(left, right);\r\n}\r\n\r\n// Ternary merge sort: log₃(n) levels\r\nfunction ternaryMergeSort(arr) {\r\n  if (arr.length <= 1) return arr;\r\n  \r\n  const third1 = Math.floor(arr.length / 3);\r\n  const third2 = Math.floor(2 * arr.length / 3);\r\n  \r\n  const part1 = ternaryMergeSort(arr.slice(0, third1));\r\n  const part2 = ternaryMergeSort(arr.slice(third1, third2));\r\n  const part3 = ternaryMergeSort(arr.slice(third2));\r\n  \r\n  return mergeThree(part1, part2, part3);\r\n}\r\n\r\n/*\r\nBoth are O(n log n), but:\r\n- Binary: log₂(n) levels\r\n- Ternary: log₃(n) levels\r\n\r\nlog₃(n) < log₂(n), so ternary has fewer levels\r\nBut merging 3 arrays is more complex than merging 2\r\nIn practice, binary merge sort is usually faster\r\n*/\n"})}),"\n",(0,t.jsx)(r.h2,{children:"Analyzing Complex Data Structures"}),"\n",(0,t.jsx)(r.h3,{children:"Skip List Operations"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"class SkipListNode {\r\n  constructor(value, level) {\r\n    this.value = value;\r\n    this.forward = new Array(level + 1).fill(null);\r\n  }\r\n}\r\n\r\nclass SkipList {\r\n  constructor(maxLevel = 16) {\r\n    this.maxLevel = maxLevel;\r\n    this.header = new SkipListNode(-Infinity, maxLevel);\r\n    this.level = 0;\r\n  }\r\n  \r\n  randomLevel() {\r\n    let level = 0;\r\n    while (Math.random() < 0.5 && level < this.maxLevel) {\r\n      level++;\r\n    }\r\n    return level;\r\n  }\r\n  \r\n  search(target) {\r\n    let current = this.header;\r\n    \r\n    // Start from highest level, work down\r\n    for (let i = this.level; i >= 0; i--) {\r\n      while (current.forward[i] && current.forward[i].value < target) {\r\n        current = current.forward[i];\r\n      }\r\n    }\r\n    \r\n    current = current.forward[0];\r\n    return current && current.value === target ? current : null;\r\n  }\r\n}\r\n\r\n/*\r\nSkip list analysis:\r\n- Expected height: O(log n)\r\n- Search time: O(log n) expected\r\n- Worst case: O(n) if all elements at same level\r\n- Space: O(n) expected, O(n log n) worst case\r\n\r\nProbabilistic data structure with expected logarithmic performance\r\n*/\n"})}),"\n",(0,t.jsx)(r.h2,{children:"When to Accept High Complexity"}),"\n",(0,t.jsx)(r.h3,{children:"NP-Complete Problems"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"// Graph coloring - no known polynomial solution\r\nfunction graphColoring(graph, numColors) {\r\n  const vertices = Object.keys(graph);\r\n  const coloring = {};\r\n  \r\n  function isValidColoring(vertex, color) {\r\n    for (let neighbor of graph[vertex]) {\r\n      if (coloring[neighbor] === color) {\r\n        return false;\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n  \r\n  function backtrack(vertexIndex) {\r\n    if (vertexIndex === vertices.length) {\r\n      return true; // All vertices colored\r\n    }\r\n    \r\n    const vertex = vertices[vertexIndex];\r\n    \r\n    for (let color = 1; color <= numColors; color++) {\r\n      if (isValidColoring(vertex, color)) {\r\n        coloring[vertex] = color;\r\n        \r\n        if (backtrack(vertexIndex + 1)) {\r\n          return true;\r\n        }\r\n        \r\n        delete coloring[vertex]; // backtrack\r\n      }\r\n    }\r\n    \r\n    return false;\r\n  }\r\n  \r\n  return backtrack(0) ? coloring : null;\r\n}\r\n\r\n/*\r\nTime complexity: O(k^n) where k = numColors, n = vertices\r\nThis is exponential, but it's the best known general solution\r\nFor specific graph types, polynomial algorithms may exist\r\n*/\n"})}),"\n",(0,t.jsx)(r.h3,{children:"Approximation Algorithms"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"// TSP approximation (2-approximation)\r\nfunction tspApproximation(distances) {\r\n  const n = distances.length;\r\n  \r\n  // 1. Find minimum spanning tree - O(n\xb2 log n)\r\n  const mst = findMST(distances);\r\n  \r\n  // 2. DFS traversal of MST - O(n)\r\n  const tour = dfsTraversal(mst, 0);\r\n  \r\n  // 3. Convert to Hamiltonian cycle - O(n)\r\n  return makeHamiltonian(tour);\r\n}\r\n\r\n/*\r\nExact TSP: O(n!)\r\nApproximation: O(n\xb2 log n)\r\n\r\nTradeoff: Get solution within 2\xd7 optimal in polynomial time\r\nversus exponential time for exact solution\r\n*/\n"})}),"\n",(0,t.jsx)(r.h2,{children:"Key Takeaways"}),"\n",(0,t.jsxs)(r.ol,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Exponential algorithms"})," quickly become impractical but may be the only known solution"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Factorial complexity"})," appears in permutation/combination problems"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Amortized analysis"})," reveals true average performance over operation sequences"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Memoization"})," can transform exponential to polynomial complexity"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Probabilistic data structures"})," offer expected good performance"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Approximation algorithms"})," provide polynomial solutions to exponential problems"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Know when to accept high complexity"})," - some problems are inherently hard"]}),"\n"]}),"\n",(0,t.jsx)(r.hr,{}),"\n",(0,t.jsx)(r.p,{children:"Ready to learn systematic analysis methods? Next, we'll explore advanced techniques like the master theorem and recursion trees."}),"\n",(0,t.jsx)(r.h3,{children:"What's Next?"}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.strong,{children:"Part 6: Practical Analysis Methods"})," - Master theorem, recursion trees, loop analysis techniques, and advanced mathematical tools for algorithm analysis."]})]})}function o(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:r}={...(0,i.a)(),...n.components};return r?(0,t.jsx)(r,{...n,children:(0,t.jsx)(a,{...n})}):a(n)}},8346:function(n,r,e){e.r(r),e.d(r,{default:function(){return o},frontmatter:function(){return s}});var t=e(7437),i=e(4229);let s=void 0;function a(n){let r={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.a)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(r.h1,{children:"Practical Analysis Methods"}),"\n",(0,t.jsx)(r.p,{children:"Master the mathematical tools and systematic approaches that computer scientists use to analyze complex algorithms. These techniques will give you confidence to tackle any algorithm analysis challenge."}),"\n",(0,t.jsx)(r.h2,{children:"The Master Theorem"}),"\n",(0,t.jsx)(r.p,{children:"The Master Theorem is a powerful tool for analyzing divide-and-conquer recurrences of the form:"}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.strong,{children:"T(n) = aT(n/b) + f(n)"})}),"\n",(0,t.jsx)(r.p,{children:"Where:"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"a ≥ 1"})," = number of subproblems"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"b > 1"})," = factor by which subproblem size is reduced"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"f(n)"})," = work done outside the recursive calls"]}),"\n"]}),"\n",(0,t.jsx)(r.h3,{children:"Three Cases"}),"\n",(0,t.jsxs)(r.p,{children:["Let ",(0,t.jsx)(r.strong,{children:"c = log_b(a)"})," (the critical exponent)"]}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.strong,{children:"Case 1"}),": If ",(0,t.jsx)(r.code,{children:"f(n) = O(n^k)"})," where ",(0,t.jsx)(r.code,{children:"k < c"}),", then ",(0,t.jsx)(r.code,{children:"T(n) = Θ(n^c)"})]}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.strong,{children:"Case 2"}),": If ",(0,t.jsx)(r.code,{children:"f(n) = O(n^c log^k n)"})," where ",(0,t.jsx)(r.code,{children:"k ≥ 0"}),", then ",(0,t.jsx)(r.code,{children:"T(n) = Θ(n^c log^(k+1) n)"})]}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.strong,{children:"Case 3"}),": If ",(0,t.jsx)(r.code,{children:"f(n) = Ω(n^k)"})," where ",(0,t.jsx)(r.code,{children:"k > c"}),", and ",(0,t.jsx)(r.code,{children:"af(n/b) ≤ cf(n)"})," for some ",(0,t.jsx)(r.code,{children:"c < 1"}),", then ",(0,t.jsx)(r.code,{children:"T(n) = Θ(f(n))"})]}),"\n",(0,t.jsx)(r.h3,{children:"Practical Applications"}),"\n",(0,t.jsx)(r.h4,{children:"Binary Search"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"function binarySearch(arr, target, left = 0, right = arr.length - 1) {\r\n  if (left > right) return -1;\r\n  \r\n  const mid = Math.floor((left + right) / 2);\r\n  \r\n  if (arr[mid] === target) return mid;\r\n  \r\n  if (arr[mid] < target) {\r\n    return binarySearch(arr, target, mid + 1, right);\r\n  } else {\r\n    return binarySearch(arr, target, left, mid - 1);\r\n  }\r\n}\r\n\r\n/*\r\nRecurrence: T(n) = T(n/2) + O(1)\r\n- a = 1 (one subproblem)\r\n- b = 2 (problem size halved)\r\n- f(n) = O(1)\r\n- c = log₂(1) = 0\r\n\r\nCase comparison: f(n) = O(1) = O(n⁰), k = 0, c = 0\r\nThis is Case 2: k = c\r\nResult: T(n) = Θ(n⁰ log n) = Θ(log n)\r\n*/\n"})}),"\n",(0,t.jsx)(r.h4,{children:"Merge Sort"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"function mergeSort(arr) {\r\n  if (arr.length <= 1) return arr;\r\n  \r\n  const mid = Math.floor(arr.length / 2);\r\n  const left = mergeSort(arr.slice(0, mid));    // T(n/2)\r\n  const right = mergeSort(arr.slice(mid));      // T(n/2)\r\n  \r\n  return merge(left, right);                    // O(n)\r\n}\r\n\r\n/*\r\nRecurrence: T(n) = 2T(n/2) + O(n)\r\n- a = 2 (two subproblems)\r\n- b = 2 (problem size halved)\r\n- f(n) = O(n)\r\n- c = log₂(2) = 1\r\n\r\nCase comparison: f(n) = O(n\xb9), k = 1, c = 1\r\nThis is Case 2: k = c\r\nResult: T(n) = Θ(n\xb9 log n) = Θ(n log n)\r\n*/\n"})}),"\n",(0,t.jsx)(r.h4,{children:"Karatsuba Multiplication"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"function karatsuba(x, y) {\r\n  // Base case for small numbers\r\n  if (x < 10 || y < 10) return x * y;\r\n  \r\n  const n = Math.max(x.toString().length, y.toString().length);\r\n  const half = Math.floor(n / 2);\r\n  \r\n  const high1 = Math.floor(x / Math.pow(10, half));\r\n  const low1 = x % Math.pow(10, half);\r\n  const high2 = Math.floor(y / Math.pow(10, half));\r\n  const low2 = y % Math.pow(10, half);\r\n  \r\n  // Three recursive multiplications instead of four\r\n  const z0 = karatsuba(low1, low2);                    // T(n/2)\r\n  const z1 = karatsuba((low1 + high1), (low2 + high2)); // T(n/2)\r\n  const z2 = karatsuba(high1, high2);                   // T(n/2)\r\n  \r\n  return z2 * Math.pow(10, 2 * half) + \r\n         (z1 - z2 - z0) * Math.pow(10, half) + z0;     // O(n)\r\n}\r\n\r\n/*\r\nRecurrence: T(n) = 3T(n/2) + O(n)\r\n- a = 3 (three subproblems)\r\n- b = 2 (problem size halved)\r\n- f(n) = O(n)\r\n- c = log₂(3) ≈ 1.585\r\n\r\nCase comparison: f(n) = O(n\xb9), k = 1, c ≈ 1.585\r\nSince k < c, this is Case 1\r\nResult: T(n) = Θ(n^1.585)\r\n\r\nThis is faster than traditional O(n\xb2) multiplication!\r\n*/\n"})}),"\n",(0,t.jsx)(r.h3,{children:"Master Theorem Limitations"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"// Doesn't apply to: T(n) = 2T(n/2) + O(n log n)\r\nfunction complexRecurrence(arr) {\r\n  if (arr.length <= 1) return arr;\r\n  \r\n  const mid = Math.floor(arr.length / 2);\r\n  const left = complexRecurrence(arr.slice(0, mid));\r\n  const right = complexRecurrence(arr.slice(mid));\r\n  \r\n  return expensiveMerge(left, right); // O(n log n) work\r\n}\r\n\r\n/*\r\nCan't use Master Theorem because f(n) = O(n log n)\r\ndoesn't fit any of the three cases cleanly.\r\nNeed other analysis techniques.\r\n*/\n"})}),"\n",(0,t.jsx)(r.h2,{children:"Recursion Trees"}),"\n",(0,t.jsx)(r.p,{children:"Recursion trees visualize the recursive call structure and help calculate total work."}),"\n",(0,t.jsx)(r.h3,{children:"Building a Recursion Tree"}),"\n",(0,t.jsx)(r.h4,{children:"Merge Sort Tree"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{children:"                    T(n)                     Level 0: 1 \xd7 O(n) = O(n)\r\n                   /    \\\r\n               T(n/2)   T(n/2)               Level 1: 2 \xd7 O(n/2) = O(n)\r\n               /   \\     /   \\\r\n           T(n/4) T(n/4) T(n/4) T(n/4)      Level 2: 4 \xd7 O(n/4) = O(n)\r\n              ...                           ...\r\n                                            Level log n: n \xd7 O(1) = O(n)\r\n\r\nTotal levels: log₂(n)\r\nWork per level: O(n)\r\nTotal work: O(n log n)\n"})}),"\n",(0,t.jsx)(r.h4,{children:"Fibonacci Tree (Naive)"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{children:"                    fib(n)\r\n                   /      \\\r\n               fib(n-1)   fib(n-2)\r\n               /    \\      /     \\\r\n          fib(n-2) fib(n-3) fib(n-3) fib(n-4)\r\n             ...\r\n\r\nHeight: n\r\nNodes at level k: approximately 2^k\r\nTotal nodes: approximately 2^n\r\nTime complexity: O(2^n)\n"})}),"\n",(0,t.jsx)(r.h3,{children:"Calculating Work with Trees"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"function complexDivideConquer(arr, depth = 0) {\r\n  if (arr.length <= 1) return arr;\r\n  \r\n  // Work at this level: O(n^1.5)\r\n  preprocessing(arr); // O(n^1.5)\r\n  \r\n  const third = Math.floor(arr.length / 3);\r\n  \r\n  // Three recursive calls\r\n  const part1 = complexDivideConquer(arr.slice(0, third), depth + 1);\r\n  const part2 = complexDivideConquer(arr.slice(third, 2 * third), depth + 1);\r\n  const part3 = complexDivideConquer(arr.slice(2 * third), depth + 1);\r\n  \r\n  return combine(part1, part2, part3); // O(n)\r\n}\r\n\r\n/*\r\nRecursion tree analysis:\r\nLevel 0: 1 \xd7 O(n^1.5) = O(n^1.5)\r\nLevel 1: 3 \xd7 O((n/3)^1.5) = 3 \xd7 O(n^1.5/3^1.5) = O(n^1.5/√3)\r\nLevel 2: 9 \xd7 O((n/9)^1.5) = 9 \xd7 O(n^1.5/9^1.5) = O(n^1.5/3)\r\n...\r\n\r\nGeometric series with ratio 1/√3 < 1\r\nSum converges, dominated by first level\r\nTotal: O(n^1.5)\r\n*/\n"})}),"\n",(0,t.jsx)(r.h2,{children:"Advanced Loop Analysis"}),"\n",(0,t.jsx)(r.h3,{children:"Multiple Variables"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"function complexLoops(n, m) {\r\n  let operations = 0;\r\n  \r\n  for (let i = 1; i <= n; i *= 2) {      // O(log n) iterations\r\n    for (let j = 0; j < m; j++) {        // O(m) iterations each\r\n      for (let k = 0; k < i; k++) {      // O(i) iterations each\r\n        operations++;                    // O(1)\r\n      }\r\n    }\r\n  }\r\n  \r\n  return operations;\r\n}\r\n\r\n/*\r\nAnalysis:\r\ni takes values: 1, 2, 4, 8, ..., up to n\r\nFor each i: m \xd7 i operations\r\n\r\nTotal: m \xd7 (1 + 2 + 4 + 8 + ... + n)\r\n     = m \xd7 (2n - 1)  [geometric series]\r\n     = O(mn)\r\n*/\n"})}),"\n",(0,t.jsx)(r.h3,{children:"Nested Loop with Dependencies"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"function triangularLoop(n) {\r\n  let operations = 0;\r\n  \r\n  for (let i = 0; i < n; i++) {\r\n    for (let j = i; j < n; j++) {        // j starts at i\r\n      for (let k = 0; k < j - i + 1; k++) { // k depends on i and j\r\n        operations++;\r\n      }\r\n    }\r\n  }\r\n  \r\n  return operations;\r\n}\r\n\r\n/*\r\nAnalysis by counting:\r\ni = 0: j goes 0 to n-1, k goes 0 to (j-0+1) = 1+2+...+n = n(n+1)/2\r\ni = 1: j goes 1 to n-1, k goes 0 to (j-1+1) = 1+2+...+(n-1) = (n-1)n/2\r\n...\r\n\r\nThis is complex - use summation formulas:\r\nTotal ≈ Σ(i=0 to n-1) Σ(j=i to n-1) (j-i+1)\r\n      = O(n\xb3)\r\n*/\n"})}),"\n",(0,t.jsx)(r.h2,{children:"Amortized Analysis Techniques"}),"\n",(0,t.jsx)(r.h3,{children:"Accounting Method"}),"\n",(0,t.jsx)(r.p,{children:'Assign different "costs" to operations to balance expensive and cheap operations.'}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"class Stack {\r\n  constructor() {\r\n    this.items = [];\r\n    this.size = 0;\r\n  }\r\n  \r\n  push(item) {\r\n    this.items[this.size] = item;\r\n    this.size++;\r\n    // Accounting cost: $3\r\n    // Actual cost: $1 (store $2 credit)\r\n  }\r\n  \r\n  pop() {\r\n    if (this.size === 0) return null;\r\n    const item = this.items[--this.size];\r\n    // Accounting cost: $1\r\n    // Actual cost: $1 (use stored credit if needed)\r\n    return item;\r\n  }\r\n  \r\n  multiPop(k) {\r\n    const result = [];\r\n    for (let i = 0; i < k && this.size > 0; i++) {\r\n      result.push(this.pop());\r\n      // Uses credits stored by previous pushes\r\n    }\r\n    return result;\r\n  }\r\n}\r\n\r\n/*\r\nAccounting analysis:\r\n- Push: Pay $3, use $1, store $2\r\n- Pop: Pay $1, use $1\r\n- MultiPop: Uses stored credits\r\n\r\nAmortized cost per operation: O(1)\r\n*/\n"})}),"\n",(0,t.jsx)(r.h3,{children:"Potential Method"}),"\n",(0,t.jsx)(r.p,{children:'Define a potential function that captures "stored energy" in the data structure.'}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"class DynamicArray {\r\n  constructor() {\r\n    this.data = new Array(1);\r\n    this.size = 0;\r\n    this.capacity = 1;\r\n  }\r\n  \r\n  // Potential function: Φ(D) = 2 \xd7 size - capacity\r\n  getPotential() {\r\n    return 2 * this.size - this.capacity;\r\n  }\r\n  \r\n  push(item) {\r\n    const oldPotential = this.getPotential();\r\n    \r\n    if (this.size === this.capacity) {\r\n      this.resize(); // Actual cost: O(n)\r\n    }\r\n    \r\n    this.data[this.size++] = item; // Actual cost: O(1)\r\n    \r\n    const newPotential = this.getPotential();\r\n    const potentialDiff = newPotential - oldPotential;\r\n    \r\n    // Amortized cost = Actual cost + Potential difference\r\n    return { actualCost: this.size === 1 ? this.capacity : 1, \r\n             amortizedCost: 1 + potentialDiff };\r\n  }\r\n}\r\n\r\n/*\r\nAnalysis:\r\n- Before resize: Φ = 2n - n = n\r\n- After resize: Φ = 2n - 2n = 0\r\n- Potential decrease = n\r\n- Actual resize cost = n\r\n- Amortized cost = n - n = 0\r\n\r\nOverall amortized cost per push: O(1)\r\n*/\n"})}),"\n",(0,t.jsx)(r.h2,{children:"Advanced Mathematical Techniques"}),"\n",(0,t.jsx)(r.h3,{children:"Solving Complex Recurrences"}),"\n",(0,t.jsx)(r.h4,{children:"Substitution Method"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"// Prove T(n) = O(n log n) for T(n) = 2T(n/2) + n\r\n\r\n/*\r\nGuess: T(n) ≤ c \xd7 n log n for some constant c\r\n\r\nInductive step:\r\nT(n) = 2T(n/2) + n\r\n     ≤ 2 \xd7 c \xd7 (n/2) \xd7 log(n/2) + n\r\n     = c \xd7 n \xd7 log(n/2) + n\r\n     = c \xd7 n \xd7 (log n - log 2) + n\r\n     = c \xd7 n \xd7 log n - c \xd7 n + n\r\n     = c \xd7 n \xd7 log n + n(1 - c)\r\n\r\nFor this to be ≤ c \xd7 n \xd7 log n, we need:\r\n1 - c ≤ 0, so c ≥ 1\r\n\r\nTherefore, T(n) = O(n log n) with c ≥ 1\r\n*/\n"})}),"\n",(0,t.jsx)(r.h4,{children:"Characteristic Equation Method"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"// For linear homogeneous recurrences like:\r\n// T(n) = 5T(n-1) - 6T(n-2)\r\n\r\n/*\r\nCharacteristic equation: r\xb2 - 5r + 6 = 0\r\nFactoring: (r - 2)(r - 3) = 0\r\nRoots: r₁ = 2, r₂ = 3\r\n\r\nGeneral solution: T(n) = A \xd7 2ⁿ + B \xd7 3ⁿ\r\n\r\nSince 3ⁿ grows faster: T(n) = Θ(3ⁿ)\r\n*/\n"})}),"\n",(0,t.jsx)(r.h3,{children:"Generating Functions"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"// Fibonacci generating function\r\nfunction fibonacciGeneratingFunction() {\r\n  /*\r\n  F(x) = Σ(n=0 to ∞) fib(n) \xd7 xⁿ\r\n  \r\n  From recurrence fib(n) = fib(n-1) + fib(n-2):\r\n  F(x) = x + x\xb2F(x) + xF(x)\r\n  F(x) = x / (1 - x - x\xb2)\r\n  \r\n  Partial fractions and series expansion give:\r\n  fib(n) = (φⁿ - ψⁿ) / √5\r\n  \r\n  Where φ = (1 + √5)/2 ≈ 1.618 (golden ratio)\r\n        ψ = (1 - √5)/2 ≈ -0.618\r\n  \r\n  Since |ψ| < 1, for large n:\r\n  fib(n) ≈ φⁿ / √5 = O(φⁿ) = O(1.618ⁿ)\r\n  */\r\n}\n"})}),"\n",(0,t.jsx)(r.h2,{children:"Practical Analysis Workflow"}),"\n",(0,t.jsx)(r.h3,{children:"Step-by-Step Method"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"function analyzeAlgorithm(code) {\r\n  /*\r\n  1. Identify the input size parameter(s)\r\n  2. Set up recurrence relation or count operations\r\n  3. Choose appropriate analysis technique:\r\n     - Simple loops: Direct counting\r\n     - Divide-and-conquer: Master theorem or recursion tree\r\n     - Complex patterns: Amortized analysis\r\n     - Linear recurrences: Characteristic equations\r\n  4. Simplify using Big O rules\r\n  5. Verify with small examples\r\n  */\r\n}\n"})}),"\n",(0,t.jsx)(r.h3,{children:"Common Pitfalls and Solutions"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"// Pitfall: Hidden complexity in library functions\r\nfunction badAnalysis(arr) {\r\n  const result = [];\r\n  for (let item of arr) {\r\n    result.push(...item.sort()); // sort() is O(k log k)!\r\n  }\r\n  return result;\r\n}\r\n// Actual complexity: O(n \xd7 k log k), not O(n)\r\n\r\n// Pitfall: Ignoring best-case optimizations\r\nfunction quicksort(arr) {\r\n  // Worst case: O(n\xb2) - sorted array\r\n  // Average case: O(n log n) - random array\r\n  // Best case: O(n log n) - optimal pivot\r\n  \r\n  // Report: O(n\xb2) worst case, but mention average case\r\n}\n"})}),"\n",(0,t.jsx)(r.h2,{children:"Key Takeaways"}),"\n",(0,t.jsxs)(r.ol,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Master Theorem"})," handles most divide-and-conquer recurrences efficiently"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Recursion trees"})," provide intuitive visualization of recursive algorithms"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Advanced loop analysis"})," requires careful counting of nested dependencies"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Amortized analysis"})," reveals true cost over operation sequences"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Mathematical techniques"})," provide rigorous proofs for complex cases"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Systematic workflow"})," prevents analysis errors and oversights"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Consider hidden complexity"})," in library functions and nested calls"]}),"\n"]}),"\n",(0,t.jsx)(r.hr,{}),"\n",(0,t.jsx)(r.p,{children:"Next up: understanding when Big O doesn't tell the whole story and how to optimize for real-world performance."}),"\n",(0,t.jsx)(r.h3,{children:"What's Next?"}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.strong,{children:"Part 7: Real-World Performance"})," - When Big O isn't enough: constants, cache effects, and practical optimization strategies that matter in production systems."]})]})}function o(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:r}={...(0,i.a)(),...n.components};return r?(0,t.jsx)(r,{...n,children:(0,t.jsx)(a,{...n})}):a(n)}},6641:function(n,r,e){e.r(r),e.d(r,{default:function(){return o},frontmatter:function(){return s}});var t=e(7437),i=e(4229);let s=void 0;function a(n){let r={code:"code",h1:"h1",h2:"h2",h3:"h3",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,i.a)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(r.h1,{children:"Real-World Performance"}),"\n",(0,t.jsx)(r.p,{children:"Big O notation is a powerful starting point, but real-world performance depends on much more than asymptotic complexity. Understanding constants, cache behavior, and hardware characteristics is crucial for building truly efficient systems."}),"\n",(0,t.jsx)(r.h2,{children:"When Big O Doesn't Tell the Whole Story"}),"\n",(0,t.jsx)(r.h3,{children:"The Constant Factor Problem"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"// Algorithm A: O(n) with large constant\r\nfunction linearSearchA(arr, target) {\r\n  let comparisons = 0;\r\n  for (let i = 0; i < arr.length; i++) {\r\n    comparisons++; // Tracking overhead\r\n    if (arr[i] === target) {\r\n      console.log(`Found after ${comparisons} comparisons`);\r\n      return i;\r\n    }\r\n    // Additional unnecessary work\r\n    let temp = arr[i] * 2;\r\n    temp = temp / 2;\r\n  }\r\n  return -1;\r\n}\r\n\r\n// Algorithm B: O(n\xb2) with small constant\r\nfunction quadraticSearchB(arr, target) {\r\n  for (let i = 0; i < Math.min(arr.length, 10); i++) {\r\n    for (let j = 0; j < Math.min(arr.length, 10); j++) {\r\n      if (arr[i] === target) return i;\r\n    }\r\n  }\r\n  return -1; // Limited to first 10 elements\r\n}\r\n\r\n/*\r\nFor arrays with n ≤ 50:\r\n- Algorithm A: ~50n operations (high constant)\r\n- Algorithm B: ~100 operations (capped at 10\xd710)\r\n\r\nAlgorithm B might be faster despite O(n\xb2) complexity!\r\n*/\n"})}),"\n",(0,t.jsx)(r.h3,{children:"Small Input Size Paradox"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"// Insertion sort vs Merge sort for small arrays\r\nfunction hybridSort(arr) {\r\n  if (arr.length <= 10) {\r\n    return insertionSort(arr);    // O(n\xb2) but fast for small n\r\n  }\r\n  return mergeSort(arr);          // O(n log n) but has overhead\r\n}\r\n\r\nfunction insertionSort(arr) {\r\n  for (let i = 1; i < arr.length; i++) {\r\n    let key = arr[i];\r\n    let j = i - 1;\r\n    \r\n    // Simple, cache-friendly operations\r\n    while (j >= 0 && arr[j] > key) {\r\n      arr[j + 1] = arr[j];\r\n      j--;\r\n    }\r\n    arr[j + 1] = key;\r\n  }\r\n  return arr;\r\n}\r\n\r\n/*\r\nReality check:\r\n- Insertion sort: ~n\xb2/4 comparisons, minimal overhead\r\n- Merge sort: ~n log n comparisons, recursion overhead\r\n\r\nFor n = 10: insertion sort ≈ 25 operations vs merge sort ≈ 33 operations\r\nPlus merge sort has higher constant factors\r\n*/\n"})}),"\n",(0,t.jsx)(r.h2,{children:"Memory Hierarchy and Cache Effects"}),"\n",(0,t.jsx)(r.h3,{children:"Cache-Friendly vs Cache-Hostile Algorithms"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"// Cache-hostile: Column-major traversal\r\nfunction sumMatrixBad(matrix) {\r\n  let sum = 0;\r\n  const rows = matrix.length;\r\n  const cols = matrix[0].length;\r\n  \r\n  // Accessing columns first - poor cache locality\r\n  for (let col = 0; col < cols; col++) {\r\n    for (let row = 0; row < rows; row++) {\r\n      sum += matrix[row][col];       // Cache miss every access\r\n    }\r\n  }\r\n  return sum;\r\n}\r\n\r\n// Cache-friendly: Row-major traversal\r\nfunction sumMatrixGood(matrix) {\r\n  let sum = 0;\r\n  \r\n  // Accessing rows first - good cache locality\r\n  for (let row = 0; row < matrix.length; row++) {\r\n    for (let col = 0; col < matrix[row].length; col++) {\r\n      sum += matrix[row][col];       // Sequential memory access\r\n    }\r\n  }\r\n  return sum;\r\n}\r\n\r\n/*\r\nPerformance difference:\r\n- Both algorithms: O(n\xd7m) time complexity\r\n- Cache-friendly: 2-10x faster in practice\r\n- Difference increases with matrix size\r\n*/\n"})}),"\n",(0,t.jsx)(r.h3,{children:"Data Structure Layout Impact"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"// Array of Objects (AoS) - poor cache performance\r\nclass PointAoS {\r\n  constructor() {\r\n    this.points = []; // [{x: 1, y: 2, z: 3}, {x: 4, y: 5, z: 6}, ...]\r\n  }\r\n  \r\n  translateX(delta) {\r\n    for (let point of this.points) {\r\n      point.x += delta;              // Scattered memory access\r\n    }\r\n  }\r\n}\r\n\r\n// Structure of Arrays (SoA) - better cache performance\r\nclass PointSoA {\r\n  constructor() {\r\n    this.x = [];     // [1, 4, 7, ...]\r\n    this.y = [];     // [2, 5, 8, ...]\r\n    this.z = [];     // [3, 6, 9, ...]\r\n  }\r\n  \r\n  translateX(delta) {\r\n    for (let i = 0; i < this.x.length; i++) {\r\n      this.x[i] += delta;            // Sequential memory access\r\n    }\r\n  }\r\n}\r\n\r\n/*\r\nCache analysis:\r\n- AoS: Each point access loads unused y,z coordinates\r\n- SoA: x array access has perfect spatial locality\r\n- SoA can be 2-5x faster for vector operations\r\n*/\n"})}),"\n",(0,t.jsx)(r.h2,{children:"Branch Prediction and Control Flow"}),"\n",(0,t.jsx)(r.h3,{children:"Predictable vs Unpredictable Branches"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"// Unpredictable branching - poor performance\r\nfunction processArrayUnpredictable(arr, threshold) {\r\n  let sum = 0;\r\n  for (let value of arr) {\r\n    if (value > threshold) {         // Random branch pattern\r\n      sum += value * value;          // Expensive operation\r\n    } else {\r\n      sum += value;                  // Cheap operation\r\n    }\r\n  }\r\n  return sum;\r\n}\r\n\r\n// Predictable branching - better performance\r\nfunction processArrayPredictable(arr, threshold) {\r\n  let sum = 0;\r\n  \r\n  // Sort to make branches predictable\r\n  arr.sort((a, b) => a - b);\r\n  \r\n  for (let value of arr) {\r\n    if (value > threshold) {         // Predictable pattern\r\n      sum += value * value;\r\n    } else {\r\n      sum += value;\r\n    }\r\n  }\r\n  return sum;\r\n}\r\n\r\n/*\r\nBranch prediction impact:\r\n- Random data: ~50% branch misprediction rate\r\n- Sorted data: Near 0% misprediction rate\r\n- Each misprediction costs 10-20 CPU cycles\r\n- Sorting overhead may be worth it for large arrays\r\n*/\n"})}),"\n",(0,t.jsx)(r.h3,{children:"Eliminating Branches"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"// Branch-heavy conditional assignment\r\nfunction maxWithBranches(a, b) {\r\n  if (a > b) {\r\n    return a;\r\n  } else {\r\n    return b;\r\n  }\r\n}\r\n\r\n// Branchless alternative\r\nfunction maxBranchless(a, b) {\r\n  return a * (a > b) + b * (b >= a);  // Relies on boolean → number conversion\r\n}\r\n\r\n// Even better: use built-in optimized function\r\nfunction maxBuiltIn(a, b) {\r\n  return Math.max(a, b);              // Heavily optimized by JS engines\r\n}\r\n\r\n/*\r\nPerformance notes:\r\n- Branchless code avoids CPU pipeline stalls\r\n- But may do unnecessary work\r\n- Modern CPUs have excellent branch predictors\r\n- Profile to determine if optimization is worthwhile\r\n*/\n"})}),"\n",(0,t.jsx)(r.h2,{children:"Algorithm Constant Factors"}),"\n",(0,t.jsx)(r.h3,{children:"Hidden Operations in Big O"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"// Looks like O(n) but has hidden sorting\r\nfunction uniqueElementsSlow(arr) {\r\n  return [...new Set(arr.sort())];    // sort() is O(n log n)!\r\n}\r\n\r\n// Actually O(n) with better constant\r\nfunction uniqueElementsFast(arr) {\r\n  return [...new Set(arr)];           // True O(n)\r\n}\r\n\r\n// Even better constant factor\r\nfunction uniqueElementsOptimal(arr) {\r\n  const seen = new Set();\r\n  const result = [];\r\n  \r\n  for (let item of arr) {\r\n    if (!seen.has(item)) {\r\n      seen.add(item);\r\n      result.push(item);\r\n    }\r\n  }\r\n  return result;\r\n}\r\n\r\n/*\r\nConstant factor analysis:\r\n- Slow: O(n log n) disguised as O(n)\r\n- Fast: O(n) but with Set creation overhead\r\n- Optimal: O(n) with minimal overhead\r\n*/\n"})}),"\n",(0,t.jsx)(r.h3,{children:"Memory Allocation Overhead"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"// Heavy memory allocation\r\nfunction processDataHeavy(arr) {\r\n  const results = [];\r\n  \r\n  for (let item of arr) {\r\n    const temp = [item, item * 2, item * 3];  // New array each iteration\r\n    results.push(processTemp(temp));\r\n  }\r\n  \r\n  return results;\r\n}\r\n\r\n// Reduced allocation\r\nfunction processDataLight(arr) {\r\n  const results = [];\r\n  const temp = new Array(3);             // Reuse array\r\n  \r\n  for (let item of arr) {\r\n    temp[0] = item;\r\n    temp[1] = item * 2;\r\n    temp[2] = item * 3;\r\n    results.push(processTemp(temp));\r\n  }\r\n  \r\n  return results;\r\n}\r\n\r\n/*\r\nMemory allocation costs:\r\n- Each allocation requires OS/GC interaction\r\n- Garbage collection pauses\r\n- Memory fragmentation\r\n- Reusing objects reduces these costs significantly\r\n*/\n"})}),"\n",(0,t.jsx)(r.h2,{children:"Platform and Hardware Considerations"}),"\n",(0,t.jsx)(r.h3,{children:"CPU Architecture Awareness"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"// CPU-friendly: Fewer function calls\r\nfunction sumArrayMonolithic(arr) {\r\n  let sum = 0;\r\n  for (let i = 0; i < arr.length; i++) {\r\n    sum += arr[i];\r\n  }\r\n  return sum;\r\n}\r\n\r\n// CPU-unfriendly: Excessive function call overhead\r\nfunction sumArrayFragmented(arr) {\r\n  return arr.reduce((sum, value) => addTwo(sum, value), 0);\r\n}\r\n\r\nfunction addTwo(a, b) {\r\n  return a + b;\r\n}\r\n\r\n/*\r\nFunction call overhead:\r\n- Each call: save registers, jump, restore registers\r\n- Small functions may have overhead > actual work\r\n- Inlining optimizations help but aren't guaranteed\r\n*/\n"})}),"\n",(0,t.jsx)(r.h3,{children:"SIMD and Vectorization"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"// Vectorization-friendly: Simple operations\r\nfunction scaleArrayVectorizable(arr, factor) {\r\n  for (let i = 0; i < arr.length; i++) {\r\n    arr[i] *= factor;                 // CPU can vectorize this\r\n  }\r\n}\r\n\r\n// Vectorization-hostile: Complex control flow\r\nfunction scaleArrayComplex(arr, factor) {\r\n  for (let i = 0; i < arr.length; i++) {\r\n    if (arr[i] > 0) {\r\n      arr[i] *= factor;\r\n    } else if (arr[i] < 0) {\r\n      arr[i] *= factor * 0.5;\r\n    } else {\r\n      arr[i] = 1;\r\n    }\r\n  }\r\n}\r\n\r\n/*\r\nSIMD (Single Instruction, Multiple Data):\r\n- Modern CPUs can process 4-8 numbers simultaneously\r\n- Simple operations enable automatic vectorization\r\n- Complex branching prevents vectorization\r\n*/\n"})}),"\n",(0,t.jsx)(r.h2,{children:"Profiling and Measurement"}),"\n",(0,t.jsx)(r.h3,{children:"Proper Performance Testing"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"class PerformanceProfiler {\r\n  static measure(algorithm, input, iterations = 1000) {\r\n    // Warm-up phase\r\n    for (let i = 0; i < 100; i++) {\r\n      algorithm(input);\r\n    }\r\n    \r\n    // Actual measurement\r\n    const start = performance.now();\r\n    for (let i = 0; i < iterations; i++) {\r\n      algorithm(input);\r\n    }\r\n    const end = performance.now();\r\n    \r\n    return (end - start) / iterations;\r\n  }\r\n  \r\n  static profile(algorithms, inputs) {\r\n    const results = {};\r\n    \r\n    for (let [name, algorithm] of Object.entries(algorithms)) {\r\n      results[name] = {};\r\n      \r\n      for (let [inputName, input] of Object.entries(inputs)) {\r\n        results[name][inputName] = this.measure(algorithm, input);\r\n      }\r\n    }\r\n    \r\n    return results;\r\n  }\r\n}\r\n\r\n// Usage\r\nconst algorithms = {\r\n  'insertion': insertionSort,\r\n  'merge': mergeSort,\r\n  'quick': quickSort\r\n};\r\n\r\nconst inputs = {\r\n  'random100': generateRandomArray(100),\r\n  'sorted100': generateSortedArray(100),\r\n  'reverse100': generateReverseArray(100)\r\n};\r\n\r\nconst results = PerformanceProfiler.profile(algorithms, inputs);\n"})}),"\n",(0,t.jsx)(r.h3,{children:"Memory Usage Analysis"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"class MemoryProfiler {\r\n  static measureMemory(fn, input) {\r\n    // Force garbage collection if available\r\n    if (global.gc) global.gc();\r\n    \r\n    const memBefore = process.memoryUsage();\r\n    const result = fn(input);\r\n    const memAfter = process.memoryUsage();\r\n    \r\n    return {\r\n      result,\r\n      heapUsed: memAfter.heapUsed - memBefore.heapUsed,\r\n      external: memAfter.external - memBefore.external\r\n    };\r\n  }\r\n}\n"})}),"\n",(0,t.jsx)(r.h2,{children:"Optimization Strategies"}),"\n",(0,t.jsx)(r.h3,{children:"Algorithm Selection Based on Input Characteristics"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"class AdaptiveSort {\r\n  static sort(arr) {\r\n    const n = arr.length;\r\n    \r\n    // Small arrays: insertion sort\r\n    if (n <= 10) {\r\n      return insertionSort(arr);\r\n    }\r\n    \r\n    // Check if nearly sorted\r\n    if (this.isNearlySorted(arr)) {\r\n      return insertionSort(arr);        // O(n) for nearly sorted\r\n    }\r\n    \r\n    // Check if many duplicates\r\n    if (this.hasManyDuplicates(arr)) {\r\n      return threeWayQuickSort(arr);    // Handles duplicates well\r\n    }\r\n    \r\n    // Default: merge sort\r\n    return mergeSort(arr);\r\n  }\r\n  \r\n  static isNearlySorted(arr) {\r\n    let inversions = 0;\r\n    for (let i = 0; i < arr.length - 1; i++) {\r\n      if (arr[i] > arr[i + 1]) inversions++;\r\n      if (inversions > arr.length * 0.1) return false;\r\n    }\r\n    return true;\r\n  }\r\n  \r\n  static hasManyDuplicates(arr) {\r\n    const unique = new Set(arr);\r\n    return unique.size < arr.length * 0.5;\r\n  }\r\n}\n"})}),"\n",(0,t.jsx)(r.h3,{children:"Micro-optimizations That Matter"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"// Loop optimization: reduce function calls\r\nfunction optimizedLoop(arr) {\r\n  const len = arr.length;              // Cache length\r\n  let sum = 0;\r\n  \r\n  for (let i = 0; i < len; i++) {      // Use cached length\r\n    sum += arr[i];\r\n  }\r\n  return sum;\r\n}\r\n\r\n// Memory access optimization: locality\r\nfunction optimizedMatrixMultiply(A, B, C) {\r\n  const n = A.length;\r\n  \r\n  // Block matrix multiplication for better cache usage\r\n  const blockSize = 64;\r\n  \r\n  for (let kk = 0; kk < n; kk += blockSize) {\r\n    for (let jj = 0; jj < n; jj += blockSize) {\r\n      for (let i = 0; i < n; i++) {\r\n        for (let k = kk; k < Math.min(kk + blockSize, n); k++) {\r\n          for (let j = jj; j < Math.min(jj + blockSize, n); j++) {\r\n            C[i][j] += A[i][k] * B[k][j];\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\n"})}),"\n",(0,t.jsx)(r.h2,{children:"When to Optimize"}),"\n",(0,t.jsx)(r.h3,{children:"Optimization Decision Framework"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"class OptimizationDecision {\r\n  static shouldOptimize(currentPerformance, requirements) {\r\n    const factors = {\r\n      isBottleneck: this.isPerformanceBottleneck(currentPerformance),\r\n      meetsRequirements: currentPerformance.time < requirements.maxTime,\r\n      complexityGain: this.estimateComplexityGain(currentPerformance),\r\n      developmentCost: this.estimateDevelopmentCost(),\r\n      maintainabilityImpact: this.assessMaintainabilityImpact()\r\n    };\r\n    \r\n    // Only optimize if it's a bottleneck and gain is significant\r\n    return factors.isBottleneck && \r\n           factors.complexityGain > 2 &&\r\n           factors.developmentCost < factors.complexityGain * 10;\r\n  }\r\n  \r\n  static isPerformanceBottleneck(perf) {\r\n    // Profile shows this function takes >10% of total runtime\r\n    return perf.percentage > 0.1;\r\n  }\r\n}\n"})}),"\n",(0,t.jsx)(r.h2,{children:"Key Takeaways"}),"\n",(0,t.jsxs)(r.ol,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Big O is the starting point"}),", not the end of performance analysis"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Constants matter"})," - especially for small to medium inputs"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Cache performance"})," can dominate asymptotic complexity"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Branch prediction"})," affects control-heavy algorithms"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Memory allocation"})," overhead is often underestimated"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Platform-specific optimizations"})," can provide significant gains"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Profile before optimizing"})," - measure, don't guess"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Consider input characteristics"})," when choosing algorithms"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Readability vs performance"})," is always a tradeoff decision"]}),"\n"]}),"\n",(0,t.jsx)(r.hr,{}),"\n",(0,t.jsx)(r.p,{children:"Ready for the final part? Let's explore real-world case studies and interview preparation strategies."}),"\n",(0,t.jsx)(r.h3,{children:"What's Next?"}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.strong,{children:"Part 8: Case Studies & Interview Prep"})," - Analyze complex real-world problems, master common interview questions, and learn optimization strategies used in production systems."]})]})}function o(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:r}={...(0,i.a)(),...n.components};return r?(0,t.jsx)(r,{...n,children:(0,t.jsx)(a,{...n})}):a(n)}},6407:function(n,r,e){e.r(r),e.d(r,{default:function(){return o},frontmatter:function(){return s}});var t=e(7437),i=e(4229);let s=void 0;function a(n){let r={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.a)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(r.h1,{children:"Case Studies & Interview Preparation"}),"\n",(0,t.jsx)(r.p,{children:"Put your Big O mastery to the test with real-world problems and interview challenges. This final section combines everything you've learned into practical, applicable knowledge."}),"\n",(0,t.jsx)(r.h2,{children:"Real-World Case Studies"}),"\n",(0,t.jsx)(r.h3,{children:"Case Study 1: Social Media Feed Ranking"}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.strong,{children:"Problem"}),": Design an algorithm to rank posts in a user's social media feed."]}),"\n",(0,t.jsx)(r.h4,{children:"Initial Approach - Naive Solution"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"function rankFeedNaive(posts, user) {\r\n  const scoredPosts = [];\r\n  \r\n  for (let post of posts) {                    // O(n)\r\n    let score = 0;\r\n    \r\n    // Calculate engagement score\r\n    for (let interaction of post.interactions) { // O(k) per post\r\n      score += calculateEngagementWeight(interaction);\r\n    }\r\n    \r\n    // Calculate relevance score\r\n    for (let tag of post.tags) {               // O(t) per post\r\n      if (user.interests.includes(tag)) {      // O(i) per tag\r\n        score += getRelevanceWeight(tag);\r\n      }\r\n    }\r\n    \r\n    scoredPosts.push({ post, score });\r\n  }\r\n  \r\n  // Sort by score\r\n  scoredPosts.sort((a, b) => b.score - a.score); // O(n log n)\r\n  \r\n  return scoredPosts.slice(0, 50);              // Return top 50\r\n}\r\n\r\n/*\r\nAnalysis:\r\n- Posts: n\r\n- Interactions per post: k (average)\r\n- Tags per post: t (average)\r\n- User interests: i\r\n\r\nTime complexity: O(n \xd7 k + n \xd7 t \xd7 i + n log n)\r\nSpace complexity: O(n)\r\n\r\nFor n = 10,000, k = 100, t = 5, i = 50:\r\n≈ 1M + 2.5M + 133K = 3.6M operations per ranking\r\n*/\n"})}),"\n",(0,t.jsx)(r.h4,{children:"Optimized Solution"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"class OptimizedFeedRanker {\r\n  constructor() {\r\n    this.userInterestMap = new Map();     // Preprocessed user interests\r\n    this.engagementCache = new Map();     // Cached engagement scores\r\n  }\r\n  \r\n  preprocessUserInterests(user) {\r\n    // Convert array to Set for O(1) lookups\r\n    this.userInterestMap.set(user.id, new Set(user.interests));\r\n  }\r\n  \r\n  rankFeed(posts, user) {\r\n    const userInterests = this.userInterestMap.get(user.id);\r\n    const scoredPosts = [];\r\n    \r\n    for (let post of posts) {             // O(n)\r\n      let score = 0;\r\n      \r\n      // Use cached engagement score if available\r\n      if (this.engagementCache.has(post.id)) {\r\n        score += this.engagementCache.get(post.id);\r\n      } else {\r\n        score += this.calculateAndCacheEngagement(post);\r\n      }\r\n      \r\n      // Optimized relevance calculation\r\n      for (let tag of post.tags) {       // O(t) per post\r\n        if (userInterests.has(tag)) {     // O(1) lookup\r\n          score += getRelevanceWeight(tag);\r\n        }\r\n      }\r\n      \r\n      scoredPosts.push({ post, score });\r\n    }\r\n    \r\n    // Use partial sort for top-k\r\n    return this.partialSort(scoredPosts, 50); // O(n + k log k)\r\n  }\r\n  \r\n  partialSort(arr, k) {\r\n    // Min-heap of size k\r\n    const heap = new MinHeap();\r\n    \r\n    for (let item of arr) {             // O(n)\r\n      if (heap.size() < k) {\r\n        heap.insert(item);              // O(log k)\r\n      } else if (item.score > heap.peek().score) {\r\n        heap.removeMin();               // O(log k)\r\n        heap.insert(item);              // O(log k)\r\n      }\r\n    }\r\n    \r\n    return heap.toArray().sort((a, b) => b.score - a.score);\r\n  }\r\n}\r\n\r\n/*\r\nOptimized complexity:\r\nTime: O(n \xd7 t + n log k) where k = 50\r\nSpace: O(n + cache_size)\r\n\r\nFor same input: ≈ 50K + 33K = 83K operations\r\n43x improvement!\r\n*/\n"})}),"\n",(0,t.jsx)(r.h3,{children:"Case Study 2: Database Query Optimization"}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.strong,{children:"Problem"}),": Optimize a join operation between user and order tables."]}),"\n",(0,t.jsx)(r.h4,{children:"Query Analysis"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-sql",children:"-- Original query\r\nSELECT u.name, COUNT(o.id) as order_count\r\nFROM users u\r\nLEFT JOIN orders o ON u.id = o.user_id\r\nWHERE u.created_at > '2023-01-01'\r\nGROUP BY u.id, u.name\r\nORDER BY order_count DESC;\n"})}),"\n",(0,t.jsx)(r.h4,{children:"Algorithm Complexity Analysis"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"// Nested loop join (worst case)\r\nfunction nestedLoopJoin(users, orders) {\r\n  const result = [];\r\n  \r\n  for (let user of users) {               // O(n)\r\n    let orderCount = 0;\r\n    for (let order of orders) {           // O(m)\r\n      if (order.user_id === user.id) {\r\n        orderCount++;\r\n      }\r\n    }\r\n    if (user.created_at > '2023-01-01') {\r\n      result.push({ name: user.name, orderCount });\r\n    }\r\n  }\r\n  \r\n  return result.sort((a, b) => b.orderCount - a.orderCount); // O(n log n)\r\n}\r\n// Time: O(n \xd7 m + n log n), Space: O(n)\r\n\r\n// Hash join (optimized)\r\nfunction hashJoin(users, orders) {\r\n  // Build hash table of orders by user_id\r\n  const orderCounts = new Map();          // O(m) time, O(m) space\r\n  \r\n  for (let order of orders) {\r\n    const count = orderCounts.get(order.user_id) || 0;\r\n    orderCounts.set(order.user_id, count + 1);\r\n  }\r\n  \r\n  // Probe phase\r\n  const result = [];\r\n  for (let user of users) {               // O(n)\r\n    if (user.created_at > '2023-01-01') {\r\n      const orderCount = orderCounts.get(user.id) || 0;\r\n      result.push({ name: user.name, orderCount });\r\n    }\r\n  }\r\n  \r\n  return result.sort((a, b) => b.orderCount - a.orderCount); // O(n log n)\r\n}\r\n// Time: O(m + n + n log n), Space: O(m + n)\n"})}),"\n",(0,t.jsx)(r.h3,{children:"Case Study 3: Real-Time Analytics Pipeline"}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.strong,{children:"Problem"}),": Process streaming data with sliding window calculations."]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"class SlidingWindowAnalytics {\r\n  constructor(windowSizeMs) {\r\n    this.windowSize = windowSizeMs;\r\n    this.events = [];                     // Ordered by timestamp\r\n    this.metrics = {\r\n      count: 0,\r\n      sum: 0,\r\n      avg: 0\r\n    };\r\n  }\r\n  \r\n  // Naive approach: O(n) per event\r\n  addEventNaive(timestamp, value) {\r\n    this.events.push({ timestamp, value });\r\n    \r\n    // Remove old events\r\n    const cutoff = timestamp - this.windowSize;\r\n    this.events = this.events.filter(e => e.timestamp > cutoff);\r\n    \r\n    // Recalculate metrics\r\n    this.metrics.count = this.events.length;\r\n    this.metrics.sum = this.events.reduce((sum, e) => sum + e.value, 0);\r\n    this.metrics.avg = this.metrics.sum / this.metrics.count;\r\n  }\r\n  \r\n  // Optimized approach: Amortized O(1) per event\r\n  addEventOptimized(timestamp, value) {\r\n    // Add new event\r\n    this.events.push({ timestamp, value });\r\n    this.metrics.count++;\r\n    this.metrics.sum += value;\r\n    \r\n    // Remove old events (amortized O(1))\r\n    const cutoff = timestamp - this.windowSize;\r\n    while (this.events.length > 0 && this.events[0].timestamp <= cutoff) {\r\n      const removed = this.events.shift();\r\n      this.metrics.count--;\r\n      this.metrics.sum -= removed.value;\r\n    }\r\n    \r\n    this.metrics.avg = this.metrics.count > 0 ? \r\n                      this.metrics.sum / this.metrics.count : 0;\r\n  }\r\n}\r\n\r\n/*\r\nPerformance comparison for 1M events:\r\n- Naive: O(n\xb2) total = 1 trillion operations\r\n- Optimized: O(n) total = 1 million operations\r\n1000x improvement!\r\n*/\n"})}),"\n",(0,t.jsx)(r.h2,{children:"Common Interview Problems"}),"\n",(0,t.jsx)(r.h3,{children:"Problem 1: Two Sum Variations"}),"\n",(0,t.jsx)(r.h4,{children:"Basic Two Sum"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"// Brute force: O(n\xb2)\r\nfunction twoSumBrute(nums, target) {\r\n  for (let i = 0; i < nums.length; i++) {\r\n    for (let j = i + 1; j < nums.length; j++) {\r\n      if (nums[i] + nums[j] === target) {\r\n        return [i, j];\r\n      }\r\n    }\r\n  }\r\n  return null;\r\n}\r\n\r\n// Hash map: O(n)\r\nfunction twoSumOptimal(nums, target) {\r\n  const seen = new Map();\r\n  \r\n  for (let i = 0; i < nums.length; i++) {\r\n    const complement = target - nums[i];\r\n    if (seen.has(complement)) {\r\n      return [seen.get(complement), i];\r\n    }\r\n    seen.set(nums[i], i);\r\n  }\r\n  return null;\r\n}\n"})}),"\n",(0,t.jsx)(r.h4,{children:"Follow-up: Two Sum with Sorted Array"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"// Two pointers: O(n), O(1) space\r\nfunction twoSumSorted(nums, target) {\r\n  let left = 0;\r\n  let right = nums.length - 1;\r\n  \r\n  while (left < right) {\r\n    const sum = nums[left] + nums[right];\r\n    if (sum === target) {\r\n      return [left, right];\r\n    } else if (sum < target) {\r\n      left++;\r\n    } else {\r\n      right--;\r\n    }\r\n  }\r\n  return null;\r\n}\n"})}),"\n",(0,t.jsx)(r.h3,{children:"Problem 2: Sliding Window Maximum"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"// Naive approach: O(nk)\r\nfunction maxSlidingWindowNaive(nums, k) {\r\n  const result = [];\r\n  \r\n  for (let i = 0; i <= nums.length - k; i++) {\r\n    let max = nums[i];\r\n    for (let j = i; j < i + k; j++) {\r\n      max = Math.max(max, nums[j]);\r\n    }\r\n    result.push(max);\r\n  }\r\n  \r\n  return result;\r\n}\r\n\r\n// Deque approach: O(n)\r\nfunction maxSlidingWindowOptimal(nums, k) {\r\n  const deque = [];  // Stores indices\r\n  const result = [];\r\n  \r\n  for (let i = 0; i < nums.length; i++) {\r\n    // Remove indices outside window\r\n    while (deque.length > 0 && deque[0] <= i - k) {\r\n      deque.shift();\r\n    }\r\n    \r\n    // Remove smaller elements\r\n    while (deque.length > 0 && nums[deque[deque.length - 1]] <= nums[i]) {\r\n      deque.pop();\r\n    }\r\n    \r\n    deque.push(i);\r\n    \r\n    // Add to result when window is complete\r\n    if (i >= k - 1) {\r\n      result.push(nums[deque[0]]);\r\n    }\r\n  }\r\n  \r\n  return result;\r\n}\r\n\r\n/*\r\nInterview analysis:\r\n- Start with brute force: Shows you understand the problem\r\n- Optimize step by step: Shows problem-solving process\r\n- Explain complexity: Shows analytical thinking\r\n*/\n"})}),"\n",(0,t.jsx)(r.h3,{children:"Problem 3: Design LRU Cache"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"class LRUCache {\r\n  constructor(capacity) {\r\n    this.capacity = capacity;\r\n    this.cache = new Map();\r\n  }\r\n  \r\n  get(key) {\r\n    if (this.cache.has(key)) {\r\n      // Move to end (most recently used)\r\n      const value = this.cache.get(key);\r\n      this.cache.delete(key);\r\n      this.cache.set(key, value);\r\n      return value;\r\n    }\r\n    return -1;\r\n  }\r\n  \r\n  put(key, value) {\r\n    if (this.cache.has(key)) {\r\n      // Update existing key\r\n      this.cache.delete(key);\r\n    } else if (this.cache.size >= this.capacity) {\r\n      // Remove least recently used (first item)\r\n      const firstKey = this.cache.keys().next().value;\r\n      this.cache.delete(firstKey);\r\n    }\r\n    \r\n    this.cache.set(key, value);\r\n  }\r\n}\r\n\r\n/*\r\nTime complexity: O(1) for both operations\r\nSpace complexity: O(capacity)\r\n\r\nKey insight: JavaScript Map maintains insertion order\r\nThis makes LRU implementation much simpler than with objects\r\n*/\n"})}),"\n",(0,t.jsx)(r.h2,{children:"Interview Strategy and Communication"}),"\n",(0,t.jsx)(r.h3,{children:"How to Approach Algorithm Problems"}),"\n",(0,t.jsx)(r.h4,{children:"The UMPIRE Method"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"/*\r\nU - Understand the problem\r\n  - What are the inputs/outputs?\r\n  - What are the constraints?\r\n  - Any edge cases?\r\n\r\nM - Match to known patterns\r\n  - Two pointers, sliding window, etc.\r\n  - Similar problems you've solved\r\n\r\nP - Plan the approach\r\n  - Start with brute force\r\n  - Identify optimization opportunities\r\n  - Choose data structures\r\n\r\nI - Implement the solution\r\n  - Write clean, readable code\r\n  - Handle edge cases\r\n  - Use good variable names\r\n\r\nR - Review and test\r\n  - Walk through with examples\r\n  - Check edge cases\r\n  - Verify complexity\r\n\r\nE - Evaluate and optimize\r\n  - Can you do better?\r\n  - Space-time tradeoffs?\r\n  - Alternative approaches?\r\n*/\n"})}),"\n",(0,t.jsx)(r.h4,{children:"Communication During Interviews"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:'function demonstrateThinking(nums, target) {\r\n  /*\r\n  TALKING THROUGH THE PROBLEM:\r\n  \r\n  "Let me understand this problem first...\r\n  We need to find two numbers that sum to target.\r\n  \r\n  Input: array of integers, target sum\r\n  Output: indices of the two numbers\r\n  \r\n  Constraints: exactly one solution exists\r\n  \r\n  Let me start with a brute force approach to make sure I understand,\r\n  then we can optimize...\r\n  */\r\n  \r\n  // Brute force approach - O(n\xb2)\r\n  /*\r\n  "The brute force is to check every pair.\r\n  This would be O(n\xb2) time, O(1) space.\r\n  For each element, check all elements after it..."\r\n  */\r\n  \r\n  // Show the optimization thinking process\r\n  /*\r\n  "Can we do better? What if we use a hash map?\r\n  As we iterate, we can store what we\'ve seen.\r\n  For each number, check if its complement exists.\r\n  This would be O(n) time, O(n) space..."\r\n  */\r\n  \r\n  const seen = new Map();\r\n  \r\n  for (let i = 0; i < nums.length; i++) {\r\n    const complement = target - nums[i];\r\n    \r\n    /*\r\n    "Let me trace through an example:\r\n    nums = [2, 7, 11, 15], target = 9\r\n    \r\n    i=0: nums[0]=2, complement=7, not in map, add 2->0\r\n    i=1: nums[1]=7, complement=2, found in map! return [0,1]\r\n    "\r\n    */\r\n    \r\n    if (seen.has(complement)) {\r\n      return [seen.get(complement), i];\r\n    }\r\n    seen.set(nums[i], i);\r\n  }\r\n  \r\n  /*\r\n  "Time complexity: O(n) - single pass\r\n  Space complexity: O(n) - hash map storage\r\n  \r\n  This is optimal for the general case.\r\n  If the array were sorted, we could use two pointers for O(1) space."\r\n  */\r\n}\n'})}),"\n",(0,t.jsx)(r.h3,{children:"Complexity Analysis in Interviews"}),"\n",(0,t.jsx)(r.h4,{children:"Common Mistakes to Avoid"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:'// MISTAKE 1: Forgetting about hidden complexity\r\nfunction badAnalysis(arr) {\r\n  for (let item of arr) {\r\n    console.log(item.toString());  // toString() might be O(k)\r\n  }\r\n}\r\n// Say "O(n)" but actual complexity might be O(n\xd7k)\r\n\r\n// MISTAKE 2: Confusing space complexity\r\nfunction confusingSpace(n) {\r\n  if (n <= 1) return 1;\r\n  return confusingSpace(n-1) + confusingSpace(n-2);\r\n}\r\n// Time: O(2^n), Space: O(n) not O(2^n)!\r\n\r\n// MISTAKE 3: Ignoring input characteristics\r\nfunction contextMatters(arr) {\r\n  return arr.sort();  // O(n log n) but what if nearly sorted?\r\n}\r\n// Insertion sort might be O(n) for nearly sorted arrays\n'})}),"\n",(0,t.jsx)(r.h4,{children:"How to Present Complexity Analysis"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:'function presentAnalysis() {\r\n  /*\r\n  GOOD APPROACH:\r\n  \r\n  1. State your assumptions\r\n     "Assuming n is the array length..."\r\n  \r\n  2. Walk through the algorithm\r\n     "We iterate through the array once (O(n))..."\r\n     "For each element, we do a hash lookup (O(1))..."\r\n  \r\n  3. Consider all parts\r\n     "The loop is O(n), the operations inside are O(1),\r\n      so total time is O(n)"\r\n  \r\n  4. Don\'t forget space\r\n     "We use a hash map that could store up to n elements,\r\n      so space complexity is O(n)"\r\n  \r\n  5. Consider edge cases\r\n     "If all elements are unique, we use O(n) space.\r\n      If all elements are the same, we use O(1) space."\r\n  */\r\n}\n'})}),"\n",(0,t.jsx)(r.h2,{children:"Advanced Interview Topics"}),"\n",(0,t.jsx)(r.h3,{children:"System Design Complexity Analysis"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:'class DistributedCache {\r\n  /*\r\n  INTERVIEW QUESTION:\r\n  "Design a distributed cache system. How do you handle:\r\n  - Consistent hashing for node selection\r\n  - Cache eviction policies\r\n  - Replication and fault tolerance"\r\n  \r\n  COMPLEXITY CONSIDERATIONS:\r\n  - Hash function: O(1)\r\n  - Node lookup with consistent hashing: O(log n) nodes\r\n  - Replication factor r: O(r) for writes\r\n  - Cache size per node: O(k/n) where k = total data\r\n  */\r\n  \r\n  constructor(numNodes, replicationFactor = 3) {\r\n    this.nodes = numNodes;\r\n    this.replicationFactor = replicationFactor;\r\n    this.ring = new ConsistentHashRing(numNodes);\r\n  }\r\n  \r\n  put(key, value) {\r\n    const nodes = this.ring.getNodes(key, this.replicationFactor);\r\n    // Time: O(log n + r) where n = nodes, r = replication factor\r\n    // Space: O(1) for the operation\r\n  }\r\n  \r\n  get(key) {\r\n    const primaryNode = this.ring.getPrimaryNode(key);\r\n    // Time: O(log n)\r\n    // Space: O(1)\r\n  }\r\n}\n'})}),"\n",(0,t.jsx)(r.h3,{children:"Machine Learning Algorithm Complexity"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:'// K-Means Clustering Analysis\r\nclass KMeansInterview {\r\n  /*\r\n  INTERVIEW QUESTION:\r\n  "Implement K-means clustering and analyze its complexity"\r\n  \r\n  COMPLEXITY ANALYSIS:\r\n  - n = number of data points\r\n  - k = number of clusters\r\n  - d = number of dimensions\r\n  - i = number of iterations\r\n  \r\n  Time: O(i \xd7 k \xd7 n \xd7 d)\r\n  Space: O(n \xd7 d + k \xd7 d)\r\n  */\r\n  \r\n  kmeans(data, k, maxIterations = 100) {\r\n    // Initialize centroids: O(k \xd7 d)\r\n    let centroids = this.initializeCentroids(data, k);\r\n    \r\n    for (let iter = 0; iter < maxIterations; iter++) {  // i iterations\r\n      // Assign points to clusters: O(n \xd7 k \xd7 d)\r\n      const clusters = this.assignClusters(data, centroids);\r\n      \r\n      // Update centroids: O(n \xd7 d)\r\n      const newCentroids = this.updateCentroids(clusters);\r\n      \r\n      // Check convergence: O(k \xd7 d)\r\n      if (this.hasConverged(centroids, newCentroids)) break;\r\n      \r\n      centroids = newCentroids;\r\n    }\r\n    \r\n    return centroids;\r\n  }\r\n  \r\n  /*\r\n  OPTIMIZATION DISCUSSION:\r\n  - K-means++: Better initialization, same asymptotic complexity\r\n  - Mini-batch K-means: O(b \xd7 k \xd7 d) per iteration where b << n\r\n  - Approximate methods: Trade accuracy for speed\r\n  */\r\n}\n'})}),"\n",(0,t.jsx)(r.h2,{children:"Problem-Solving Patterns"}),"\n",(0,t.jsx)(r.h3,{children:"Pattern 1: Two Pointers"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"// When to use: Sorted arrays, palindromes, pairs\r\nfunction isPalindrome(s) {\r\n  let left = 0, right = s.length - 1;\r\n  \r\n  while (left < right) {\r\n    if (s[left] !== s[right]) return false;\r\n    left++;\r\n    right--;\r\n  }\r\n  return true;\r\n}\r\n// Time: O(n), Space: O(1)\n"})}),"\n",(0,t.jsx)(r.h3,{children:"Pattern 2: Sliding Window"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"// When to use: Subarrays, substrings with constraints\r\nfunction maxSubarraySum(arr, k) {\r\n  let maxSum = 0;\r\n  let windowSum = 0;\r\n  \r\n  // Initial window\r\n  for (let i = 0; i < k; i++) {\r\n    windowSum += arr[i];\r\n  }\r\n  maxSum = windowSum;\r\n  \r\n  // Slide window\r\n  for (let i = k; i < arr.length; i++) {\r\n    windowSum = windowSum - arr[i - k] + arr[i];\r\n    maxSum = Math.max(maxSum, windowSum);\r\n  }\r\n  \r\n  return maxSum;\r\n}\r\n// Time: O(n), Space: O(1)\n"})}),"\n",(0,t.jsx)(r.h3,{children:"Pattern 3: Hash Map for Frequency"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"// When to use: Counting, finding duplicates\r\nfunction findAnagrams(s, p) {\r\n  const pFreq = {};\r\n  for (let char of p) {\r\n    pFreq[char] = (pFreq[char] || 0) + 1;\r\n  }\r\n  \r\n  const result = [];\r\n  const windowFreq = {};\r\n  let left = 0;\r\n  \r\n  for (let right = 0; right < s.length; right++) {\r\n    // Expand window\r\n    const rightChar = s[right];\r\n    windowFreq[rightChar] = (windowFreq[rightChar] || 0) + 1;\r\n    \r\n    // Contract window if needed\r\n    if (right - left + 1 > p.length) {\r\n      const leftChar = s[left];\r\n      windowFreq[leftChar]--;\r\n      if (windowFreq[leftChar] === 0) delete windowFreq[leftChar];\r\n      left++;\r\n    }\r\n    \r\n    // Check if anagram\r\n    if (right - left + 1 === p.length && \r\n        JSON.stringify(windowFreq) === JSON.stringify(pFreq)) {\r\n      result.push(left);\r\n    }\r\n  }\r\n  \r\n  return result;\r\n}\r\n// Time: O(n), Space: O(k) where k = unique characters\n"})}),"\n",(0,t.jsx)(r.h2,{children:"Final Tips for Success"}),"\n",(0,t.jsx)(r.h3,{children:"Before the Interview"}),"\n",(0,t.jsxs)(r.ol,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Practice complexity analysis"})," on every problem you solve"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Learn to recognize patterns"})," - it speeds up problem-solving"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Time yourself"})," - aim for optimal solution in 20-30 minutes"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Practice explaining"})," your thought process out loud"]}),"\n"]}),"\n",(0,t.jsx)(r.h3,{children:"During the Interview"}),"\n",(0,t.jsxs)(r.ol,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Start with clarifying questions"})," - show you think about edge cases"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Begin with brute force"})," - demonstrates understanding"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Optimize step by step"})," - don't jump to optimal solution"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Test with examples"})," - catch bugs early"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Discuss tradeoffs"})," - time vs space, readability vs performance"]}),"\n"]}),"\n",(0,t.jsx)(r.h3,{children:"After Implementation"}),"\n",(0,t.jsxs)(r.ol,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Walk through complexity analysis"})," systematically"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Consider edge cases"})," you might have missed"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Discuss potential optimizations"})," or alternative approaches"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Think about real-world concerns"})," - what if data doesn't fit in memory?"]}),"\n"]}),"\n",(0,t.jsx)(r.h2,{children:"Key Takeaways"}),"\n",(0,t.jsxs)(r.ol,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Big O mastery"})," is essential for technical interviews and system design"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Practice systematic analysis"})," - it becomes second nature with repetition"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Communication skills"})," matter as much as coding ability"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Pattern recognition"})," accelerates problem-solving"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Real-world optimization"})," goes beyond Big O to include constants and hardware"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Continuous learning"})," - algorithms evolve with new research and hardware"]}),"\n"]}),"\n",(0,t.jsx)(r.hr,{}),"\n",(0,t.jsxs)(r.p,{children:["Congratulations! You've completed the ",(0,t.jsx)(r.strong,{children:"Big O Notation Mastery"})," series. You now have the tools to analyze any algorithm, optimize performance systematically, and excel in technical interviews. Keep practicing, and remember: the best algorithm is the one that solves the problem correctly, efficiently, and maintainably."]}),"\n",(0,t.jsx)(r.h3,{children:"Series Complete! \uD83C\uDF89"}),"\n",(0,t.jsx)(r.p,{children:"You've mastered:"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsx)(r.li,{children:"✅ Big O fundamentals and notation"}),"\n",(0,t.jsx)(r.li,{children:"✅ Common time and space complexities"}),"\n",(0,t.jsx)(r.li,{children:"✅ Systematic analysis techniques"}),"\n",(0,t.jsx)(r.li,{children:"✅ Advanced concepts and amortized analysis"}),"\n",(0,t.jsx)(r.li,{children:"✅ Real-world performance optimization"}),"\n",(0,t.jsx)(r.li,{children:"✅ Interview strategies and problem patterns"}),"\n"]}),"\n",(0,t.jsx)(r.p,{children:"Ready to apply your knowledge? Check out our Algorithm Design Patterns series for advanced problem-solving techniques!"})]})}function o(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:r}={...(0,i.a)(),...n.components};return r?(0,t.jsx)(r,{...n,children:(0,t.jsx)(a,{...n})}):a(n)}}}]);